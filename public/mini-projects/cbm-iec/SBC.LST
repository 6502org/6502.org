
6502/65C02 Turbo Assembler listing file of "sbc.asm"
done on Fri Sep 05 20:48:33 2003


>8002  41 30 c3 c2 cd              	.byte "A0",$C3,$C2,$CD		; ROM signature
.a300                              lab_cold

.a300  a0 04      ldy #$04         	LDY	#PG2_TABE-PG2_TABS-1	; byte count-1
.a302                              lab_2d13
.a302  b9 c3 c3   lda $c3c3,y      	LDA	PG2_TABS,Y		; get byte
.a305  99 00 02   sta $0200,y      	STA	ccflag,Y		; store in page 2
.a308  88         dey              	DEY				; decrement count
.a309  10 f7      bpl $a302        	BPL	LAB_2D13		; loop if not done
.a30b  a2 ff      ldx #$ff         	LDX	#$FF			; set byte
.a30d  8e 22 02   stx $0222        	stx   ibuffs-1		; *** added by Daryl Rictor for SBC compatibility***	
.a310  86 88      stx $88          	STX	Clineh		; set current line high byte (set immediate mode)
.a312  9a         txs              	TXS				; reset stack pointer
.a313  a9 4c      lda #$4c         	LDA	#$4C			; code for JMP
.a315  85 a1      sta $a1          	STA	Fnxjmp		; save for jump vector for functions
.a317  a2 18      ldx #$18         	LDX	#StrTab-LAB_2CEE	; set byte count
.a319                              lab_2d4e
.a319  bd c7 c3   lda $c3c7,x      	LDA	LAB_2CEE-1,X	; get byte from table
.a31c  95 bb      sta $bb,x        	STA	LAB_IGBY-1,X	; save byte in page zero
.a31e  ca         dex              	DEX				; decrement count
.a31f  d0 f8      bne $a319        	BNE	LAB_2D4E		; loop if not all done
.a321                              lab_gmem
.a321  a2 12      ldx #$12         	LDX	#EndTab-StrTab-1	; set byte count-1
.a323                              tabloop
.a323  bd e0 c3   lda $c3e0,x      	LDA	StrTab,X		; get byte from table
.a326  95 00      sta $00,x        	STA	PLUS_0,X		; save byte in page zero
.a328  ca         dex              	DEX				; decrement count
.a329  10 f8      bpl $a323        	BPL	TabLoop		; loop if not all done
.a32b  a9 00      lda #$00         	LDA	#$00			; clear A
.a32d  85 d8      sta $d8          	STA	NmiBase		; clear NMI handler enabled flag
.a32f  85 db      sta $db          	STA	IrqBase		; clear IRQ handler enabled flag
.a331  85 b2      sta $b2          	STA	FAC1_o		; clear FAC1 overflow byte
.a333  85 67      sta $67          	STA	last_sh		; clear descriptor stack top item pointer high byte
.a335  a9 0e      lda #$0e         	LDA	#$0E			; set default tab size
.a337  85 64      sta $64          	STA	TabSiz		; save it
.a339  a9 03      lda #$03         	LDA	#$03			; set garbage collect step size for descriptor stack
.a33b  85 a0      sta $a0          	STA	g_step		; save it
.a33d  a2 68      ldx #$68         	LDX	#des_sk		; descriptor stack start
.a33f  86 65      stx $65          	STX	next_s		; set descriptor stack pointer
.a341  20 64 ab   jsr $ab64        	JSR	LAB_CRLF		; print CR/LF
.a344  a9 f3      lda #$f3         	LDA	#<LAB_MSZM		; point to memory size message (low addr)
.a346  a0 c3      ldy #$c3         	LDY	#>LAB_MSZM		; point to memory size message (high addr)
.a348  20 a4 ab   jsr $aba4        	JSR	LAB_18C3		; print null terminated string from memory
.a34b  20 48 a5   jsr $a548        	JSR	LAB_INLN		; print "? " and get BASIC input
.a34e  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.a350  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.a352  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.a355  d0 1f      bne $a376        	BNE	LAB_2DAA		; branch if not null (user typed something)
.a357  a0 00      ldy #$00         	LDY	#$00			; else clear Y
.a359                              lab_2d93
.a359  e6 11      inc $11          	INC	Itempl		; increment temporary integer low byte
.a35b  d0 08      bne $a365        	BNE	LAB_2D99		; branch if no overflow
.a35d  e6 12      inc $12          	INC	Itemph		; increment temporary integer high byte
.a35f  a5 12      lda $12          	LDA	Itemph		; get high byte
.a361  c9 7f      cmp #$7f         	CMP	#>Ram_top		; compare with top of RAM+1
.a363  f0 1d      beq $a382        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
.a365                              lab_2d99
.a365  a9 55      lda #$55         	LDA	#$55			; set test byte
.a367  91 11      sta ($11),y      	STA	(Itempl),Y		; save via temporary integer
.a369  d1 11      cmp ($11),y      	CMP	(Itempl),Y		; compare via temporary integer
.a36b  d0 15      bne $a382        	BNE	LAB_2DB6		; branch if fail
.a36d  0a         asl              	ASL	A			; shift test byte left (now $AA)
.a36e  91 11      sta ($11),y      	STA	(Itempl),Y		; save via temporary integer
.a370  d1 11      cmp ($11),y      	CMP	(Itempl),Y		; compare via temporary integer
.a372  f0 e5      beq $a359        	BEQ	LAB_2D93		; if ok go do next byte
.a374  d0 0c      bne $a382        	BNE	LAB_2DB6		; branch if fail
.a376                              lab_2daa
.a376  20 70 bc   jsr $bc70        	JSR	LAB_2887		; get FAC1 from string
.a379  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a37b  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.a37d  b0 a2      bcs $a321        	BCS	LAB_GMEM		; if too large go try again
.a37f  20 bb b7   jsr $b7bb        	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
.a382                              lab_2db6
.a382  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.a384  a4 12      ldy $12          	LDY	Itemph		; get temporary integer high byte
.a386  c0 05      cpy #$05         	CPY	#(>Ram_base)+1	; compare with start of RAM+$100 high byte
.a388  90 97      bcc $a321        	BCC	LAB_GMEM		; if too small go try again
.a38a  85 85      sta $85          	STA	Ememl			; set end of mem low byte
.a38c  84 86      sty $86          	STY	Ememh			; set end of mem high byte
.a38e  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.a390  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.a392  a0 00      ldy #$00         	LDY	#<Ram_base		; set start addr low byte
.a394  a2 04      ldx #$04         	LDX	#>Ram_base		; set start addr high byte
.a396  84 79      sty $79          	STY	Smeml			; save start of mem low byte
.a398  86 7a      stx $7a          	STX	Smemh			; save start of mem high byte
.a39a  98         tya              	TYA				; clear A
.a39b  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first byte
.a39d  e6 79      inc $79          	INC	Smeml			; increment start of mem low byte
.a39f                              lab_2e05
.a39f  20 64 ab   jsr $ab64        	JSR	LAB_CRLF		; print CR/LF
.a3a2  20 5a a6   jsr $a65a        	JSR	LAB_1463		; do "NEW" and "CLEAR"
.a3a5  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.a3a7  38         sec              	SEC				; set carry for subtract
.a3a8  e5 79      sbc $79          	SBC	Smeml			; subtract start of mem low byte
.a3aa  aa         tax              	TAX				; copy to X
.a3ab  a5 86      lda $86          	LDA	Ememh			; get end of mem high byte
.a3ad  e5 7a      sbc $7a          	SBC	Smemh			; subtract start of mem high byte
.a3af  20 4b bd   jsr $bd4b        	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
.a3b2  a9 02      lda #$02         	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
.a3b4  a0 c4      ldy #$c4         	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
.a3b6  20 a4 ab   jsr $aba4        	JSR	LAB_18C3		; print null terminated string from memory
.a3b9  a9 5c      lda #$5c         	LDA	#<LAB_1274		; warm start vector low byte
.a3bb  a0 a4      ldy #$a4         	LDY	#>LAB_1274		; warm start vector high byte
.a3bd  85 01      sta $01          	STA	Wrmjpl		; save warm start vector low byte
.a3bf  84 02      sty $02          	STY	Wrmjph		; save warm start vector high byte
.a3c1  6c 01 00   jmp ($0001)      	JMP	(Wrmjpl)		; go do warm start
.a3c4                              lab_11cf
.a3c4  20 0f a4   jsr $a40f        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.a3c7  85 7f      sta $7f          	STA	Earryl		; save new array mem end low byte
.a3c9  84 80      sty $80          	STY	Earryh		; save new array mem end high byte
.a3cb                              lab_11d6
.a3cb  38         sec              	SEC				; set carry for subtract
.a3cc  a5 a6      lda $a6          	LDA	Obendl		; get block end low byte
.a3ce  e5 aa      sbc $aa          	SBC	Ostrtl		; subtract block start low byte
.a3d0  85 71      sta $71          	STA	Temp_2		; save MOD(block length/$100) byte
.a3d2  a8         tay              	TAY				; copy MOD(block length/$100) byte to Y
.a3d3  a5 a7      lda $a7          	LDA	Obendh		; get block end high byte
.a3d5  e5 ab      sbc $ab          	SBC	Ostrth		; subtract block start high byte
.a3d7  aa         tax              	TAX				; copy block length high byte to X
.a3d8  e8         inx              	INX				; +1 to allow for count=0 exit
.a3d9  98         tya              	TYA				; copy block length low byte to A
.a3da  f0 23      beq $a3ff        	BEQ	LAB_120A		; branch if length low byte=0
.a3dc  a5 a6      lda $a6          	LDA	Obendl		; get block end low byte
.a3de  38         sec              	SEC				; set carry for subtract
.a3df  e5 71      sbc $71          	SBC	Temp_2		; subtract MOD(block length/$100) byte
.a3e1  85 a6      sta $a6          	STA	Obendl		; save corrected old block end low byte
.a3e3  b0 03      bcs $a3e8        	BCS	LAB_11F3		; branch if no underflow
.a3e5  c6 a7      dec $a7          	DEC	Obendh		; else decrement block end high byte
.a3e7  38         sec              	SEC				; set carry for subtract
.a3e8                              lab_11f3
.a3e8  a5 a4      lda $a4          	LDA	Nbendl		; get destination end low byte
.a3ea  e5 71      sbc $71          	SBC	Temp_2		; subtract MOD(block length/$100) byte
.a3ec  85 a4      sta $a4          	STA	Nbendl		; save modified new block end low byte
.a3ee  b0 08      bcs $a3f8        	BCS	LAB_1203		; branch if no underflow
.a3f0  c6 a5      dec $a5          	DEC	Nbendh		; else decrement block end high byte
.a3f2  90 04      bcc $a3f8        	BCC	LAB_1203		; branch always
.a3f4                              lab_11ff
.a3f4  b1 a6      lda ($a6),y      	LDA	(Obendl),Y		; get byte from source
.a3f6  91 a4      sta ($a4),y      	STA	(Nbendl),Y		; copy byte to destination
.a3f8                              lab_1203
.a3f8  88         dey              	DEY				; decrement index
.a3f9  d0 f9      bne $a3f4        	BNE	LAB_11FF		; loop until Y=0
.a3fb  b1 a6      lda ($a6),y      	LDA	(Obendl),Y		; get byte from source
.a3fd  91 a4      sta ($a4),y      	STA	(Nbendl),Y		; save byte to destination
.a3ff                              lab_120a
.a3ff  c6 a7      dec $a7          	DEC	Obendh		; decrement source pointer high byte
.a401  c6 a5      dec $a5          	DEC	Nbendh		; decrement destination pointer high byte
.a403  ca         dex              	DEX				; decrement block count
.a404  d0 f2      bne $a3f8        	BNE	LAB_1203		; loop until count = $0
.a406  60         rts              	RTS				;
.a407                              lab_1212
.a407  85 78      sta $78          	STA	TempB			; save result in temp byte
.a409  ba         tsx              	TSX				; copy stack
.a40a  e4 78      cpx $78          	CPX	TempB			; compare new "limit" with stack
.a40c  90 2e      bcc $a43c        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error, then warm start
.a40e  60         rts              	RTS				;
.a40f                              lab_121f
.a40f  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string mem high byte
.a411  90 28      bcc $a43b        	BCC	LAB_124B		; if less then exit (is ok)
.a413  d0 04      bne $a419        	BNE	LAB_1229		; skip next test if greater (tested <)
.a415  c5 81      cmp $81          	CMP	Sstorl		; compare with bottom of string mem low byte
.a417  90 22      bcc $a43b        	BCC	LAB_124B		; if less then exit (is ok)
.a419                              lab_1229
.a419  48         pha              	PHA				; push addr low byte
.a41a  a2 08      ldx #$08         	LDX	#$08			; set index to save Adatal to expneg inclusive
.a41c  98         tya              	TYA				; copy addr high byte (to push on stack)
.a41d                              lab_122d
.a41d  48         pha              	PHA				; push byte
.a41e  b5 a3      lda $a3,x        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
.a420  ca         dex              	DEX				; decrement index
.a421  10 fa      bpl $a41d        	BPL	LAB_122D		; loop until all done
.a423  20 b4 b4   jsr $b4b4        	JSR	LAB_GARB		; garbage collection routine
.a426  a2 f8      ldx #$f8         	LDX	#$F8			; set index to restore bytes
.a428                              lab_1238
.a428  68         pla              	PLA				; pop byte
.a429  95 ac      sta $ac,x        	STA	expneg+1,X		; save byte to Adatal to expneg ( ,$00 not pulled)
.a42b  e8         inx              	INX				; increment index
.a42c  30 fa      bmi $a428        	BMI	LAB_1238		; loop while -ve
.a42e  68         pla              	PLA				; pop addr high byte
.a42f  a8         tay              	TAY				; copy back to Y
.a430  68         pla              	PLA				; pop addr low byte
.a431  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string mem high byte
.a433  90 06      bcc $a43b        	BCC	LAB_124B		; if less then exit (is ok)
.a435  d0 05      bne $a43c        	BNE	LAB_OMER		; if greater do "Out of memory" error, then warm start
.a437  c5 81      cmp $81          	CMP	Sstorl		; compare with bottom of string mem low byte
.a439  b0 01      bcs $a43c        	BCS	LAB_OMER		; if >= do "Out of memory" error, then warm start
.a43b                              lab_124b
.a43b  60         rts              	RTS				;
.a43c                              lab_omer
.a43c  a2 0c      ldx #$0c         	LDX	#$0C			; error code $0C ("Out of memory" error)
.a43e                              lab_xerr
.a43e  20 64 ab   jsr $ab64        	JSR	LAB_CRLF		; print CR/LF
.a441  bd 03 c9   lda $c903,x      	LDA	LAB_BAER,X		; get error message pointer low byte
.a444  bc 04 c9   ldy $c904,x      	LDY	LAB_BAER+1,X	; get error message pointer high byte
.a447  20 a4 ab   jsr $aba4        	JSR	LAB_18C3		; print null terminated string from memory
.a44a  20 93 a6   jsr $a693        	JSR	LAB_1491		; flush stack & clear continue flag
.a44d  a9 40      lda #$40         	LDA	#<LAB_EMSG		; point to " Error" low addr
.a44f  a0 ca      ldy #$ca         	LDY	#>LAB_EMSG		; point to " Error" high addr
.a451                              lab_1269
.a451  20 a4 ab   jsr $aba4        	JSR	LAB_18C3		; print null terminated string from memory
.a454  a4 88      ldy $88          	LDY	Clineh		; get current line high byte
.a456  c8         iny              	INY				; increment it
.a457  f0 03      beq $a45c        	BEQ	LAB_1274		; go do warm start (was immediate mode)
.a459  20 40 bd   jsr $bd40        	JSR	LAB_2953		; print " in line [LINE #]"
.a45c                              lab_1274
.a45c  a9 00      lda #$00         	LDA	#$00			; clear A
.a45e  85 db      sta $db          	STA	IrqBase		; clear enabled byte
.a460  85 d8      sta $d8          	STA	NmiBase		; clear enabled byte
.a462  a9 50      lda #$50         	LDA	#<LAB_RMSG		; point to "Ready" message low byte
.a464  a0 ca      ldy #$ca         	LDY	#>LAB_RMSG		; point to "Ready" message high byte
.a466  20 a4 ab   jsr $aba4        	JSR	LAB_18C3		; go do print string
.a469                              lab_127d
.a469  20 55 a5   jsr $a555        	JSR	LAB_1357		; call for BASIC input
.a46c                              lab_1280
.a46c  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.a46e  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.a470  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.a473  f0 f4      beq $a469        	BEQ	LAB_127D		; loop while null
.a475  a2 ff      ldx #$ff         	LDX	#$FF			; current line to null value
.a477  86 88      stx $88          	STX	Clineh		; set current line high byte
.a479  90 06      bcc $a481        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
.a47b  20 86 a5   jsr $a586        	JSR	LAB_13A6		; crunch keywords into Basic tokens
.a47e  4c fd a7   jmp $a7fd        	JMP	LAB_15F6		; go scan & interpret code
.a481                              lab_1295
.a481  20 1c aa   jsr $aa1c        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.a484  20 86 a5   jsr $a586        	JSR	LAB_13A6		; crunch keywords into Basic tokens
.a487  84 5d      sty $5d          	STY	Ibptr			; save index pointer to end of crunched line
.a489  20 2c a6   jsr $a62c        	JSR	LAB_SSLN		; search BASIC for temp integer line number
.a48c  90 44      bcc $a4d2        	BCC	LAB_12E6		; branch if not found
.a48e  a0 01      ldy #$01         	LDY	#$01			; set index to next line pointer high byte
.a490  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.a492  85 72      sta $72          	STA	ut1_ph		; save it
.a494  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.a496  85 71      sta $71          	STA	ut1_pl		; save it
.a498  a5 ab      lda $ab          	LDA	Baslnh		; get found line pointer high byte
.a49a  85 74      sta $74          	STA	ut2_ph		; save it
.a49c  a5 aa      lda $aa          	LDA	Baslnl		; get found line pointer low byte
.a49e  88         dey              	DEY				; decrement index
.a49f  f1 aa      sbc ($aa),y      	SBC	(Baslnl),Y		; subtract next line pointer low byte
.a4a1  18         clc              	CLC				; clear carry for add
.a4a2  65 7b      adc $7b          	ADC	Svarl			; add start of vars low byte
.a4a4  85 7b      sta $7b          	STA	Svarl			; save new start of vars low byte
.a4a6  85 73      sta $73          	STA	ut2_pl		; save destination pointer low byte
.a4a8  a5 7c      lda $7c          	LDA	Svarh			; get start of vars high byte
.a4aa  69 ff      adc #$ff         	ADC	#$FF			; -1 + carry
.a4ac  85 7c      sta $7c          	STA	Svarh			; save start of vars high byte
.a4ae  e5 ab      sbc $ab          	SBC	Baslnh		; subtract found line pointer high byte
.a4b0  aa         tax              	TAX				; copy to block count
.a4b1  38         sec              	SEC				; set carry for subtract
.a4b2  a5 aa      lda $aa          	LDA	Baslnl		; get found line pointer low byte
.a4b4  e5 7b      sbc $7b          	SBC	Svarl			; subtract start of vars low byte
.a4b6  a8         tay              	TAY				; copy to bytes in first block count
.a4b7  b0 03      bcs $a4bc        	BCS	LAB_12D0		; branch if overflow
.a4b9  e8         inx              	INX				; increment block count (correct for =0 loop exit)
.a4ba  c6 74      dec $74          	DEC	ut2_ph		; decrement destination high byte
.a4bc                              lab_12d0
.a4bc  18         clc              	CLC				; clear carry for add
.a4bd  65 71      adc $71          	ADC	ut1_pl		; add source pointer low byte
.a4bf  90 03      bcc $a4c4        	BCC	LAB_12D8		; branch if no overflow
.a4c1  c6 72      dec $72          	DEC	ut1_ph		; else decrement source pointer high byte
.a4c3  18         clc              	CLC				; clear carry
.a4c4                              lab_12d8
.a4c4  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from source
.a4c6  91 73      sta ($73),y      	STA	(ut2_pl),Y		; copy to destination
.a4c8  c8         iny              	INY				; increment index
.a4c9  d0 f9      bne $a4c4        	BNE	LAB_12D8		; while <> 0 do this block
.a4cb  e6 72      inc $72          	INC	ut1_ph		; increment source pointer high byte
.a4cd  e6 74      inc $74          	INC	ut2_ph		; increment destination pointer high byte
.a4cf  ca         dex              	DEX				; decrement block count
.a4d0  d0 f2      bne $a4c4        	BNE	LAB_12D8		; loop until all done
.a4d2                              lab_12e6
.a4d2  ad 23 02   lda $0223        	LDA	Ibuffs		; get byte from start if input buffer
.a4d5  f0 3f      beq $a516        	BEQ	LAB_1319		; if null line just go flush stack/vars & exit
.a4d7  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.a4d9  a4 86      ldy $86          	LDY	Ememh			; get end of mem high byte
.a4db  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.a4dd  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.a4df  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte	(end of BASIC)
.a4e1  85 a6      sta $a6          	STA	Obendl		; save old block end low byte
.a4e3  a4 7c      ldy $7c          	LDY	Svarh			; get start of vars high byte	(end of BASIC)
.a4e5  84 a7      sty $a7          	STY	Obendh		; save old block end high byte
.a4e7  65 5d      adc $5d          	ADC	Ibptr			; add input buffer pointer	(also buffer length)
.a4e9  90 01      bcc $a4ec        	BCC	LAB_1301		; branch if no overflow from add
.a4eb  c8         iny              	INY				; else increment high byte
.a4ec                              lab_1301
.a4ec  85 a4      sta $a4          	STA	Nbendl		; save new block end low byte	(move to, low byte)
.a4ee  84 a5      sty $a5          	STY	Nbendh		; save new block end high byte
.a4f0  20 c4 a3   jsr $a3c4        	JSR	LAB_11CF		; open up space in memory
.a4f3  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.a4f5  a4 80      ldy $80          	LDY	Earryh		; get array mem end high byte
.a4f7  85 7b      sta $7b          	STA	Svarl			; save start of vars low byte
.a4f9  84 7c      sty $7c          	STY	Svarh			; save start of vars high byte
.a4fb  a4 5d      ldy $5d          	LDY	Ibptr			; get input buffer pointer	(also buffer length)
.a4fd  88         dey              	DEY				; adjust for loop type
.a4fe                              lab_1311
.a4fe  b9 1f 02   lda $021f,y      	LDA	Ibuffs-4,Y		; get byte from crunched line
.a501  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.a503  88         dey              	DEY				; decrement count
.a504  c0 03      cpy #$03         	CPY	#$03			; compare with first byte-1
.a506  d0 f6      bne $a4fe        	BNE	LAB_1311		; continue while count <> 3
.a508  a5 12      lda $12          	LDA	Itemph		; get line # high byte
.a50a  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.a50c  88         dey              	DEY				; decrement count
.a50d  a5 11      lda $11          	LDA	Itempl		; get line # low byte
.a50f  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.a511  88         dey              	DEY				; decrement count
.a512  a9 ff      lda #$ff         	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
.a514  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.a516                              lab_1319
.a516  20 6f a6   jsr $a66f        	JSR	LAB_1477		; reset execution to start, clear vars & flush stack
.a519  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.a51b  a4 7a      ldy $7a          	LDY	Smemh			; get start of mem high byte
.a51d  85 71      sta $71          	STA	ut1_pl		; set line start pointer low byte
.a51f  84 72      sty $72          	STY	ut1_ph		; set line start pointer high byte
.a521  18         clc              	CLC				; clear carry for possible later add
.a522                              lab_1325
.a522  a0 01      ldy #$01         	LDY	#$01			; index to high byte of next line pointer
.a524  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get it
.a526  d0 03      bne $a52b        	BNE	LAB_132E		; there is a program (or not reached end yet) so we must
.a528  4c 69 a4   jmp $a469        	JMP	LAB_127D		; wait for Basic command (no "Ready")
.a52b                              lab_132e
.a52b  a0 04      ldy #$04         	LDY	#$04			; point to first code byte of line
.a52d                              lab_1330
.a52d  c8         iny              	INY				; next code byte
.a52e  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte
.a530  d0 fb      bne $a52d        	BNE	LAB_1330		; loop if not [EOL]
.a532  c8         iny              	INY				; point to byte past [EOL] (start of next line)
.a533  98         tya              	TYA				; copy it
.a534  65 71      adc $71          	ADC	ut1_pl		; add to line start pointer low byte
.a536  aa         tax              	TAX				; copy to X
.a537  a0 00      ldy #$00         	LDY	#$00			; clear index (point to this line's next line pointer)
.a539  91 71      sta ($71),y      	STA	(ut1_pl),Y		; set next line pointer low byte
.a53b  a5 72      lda $72          	LDA	ut1_ph		; get line start pointer high byte
.a53d  69 00      adc #$00         	ADC	#$00			; add any overflow
.a53f  c8         iny              	INY				; increment index to high byte
.a540  91 71      sta ($71),y      	STA	(ut1_pl),Y		; set next line pointer low byte
.a542  86 71      stx $71          	STX	ut1_pl		; set line start pointer low byte
.a544  85 72      sta $72          	STA	ut1_ph		; set line start pointer high byte
.a546  90 da      bcc $a522        	BCC	LAB_1325		; go do next line (carry always clear)
.a548                              lab_inln
.a548  20 bc ab   jsr $abbc        	JSR	LAB_18E3		; print "?" character
.a54b  20 b9 ab   jsr $abb9        	JSR	LAB_18E0		; print " "
.a54e  d0 05      bne $a555        	BNE	LAB_1357		; call for BASIC input & return
.a550                              lab_134b
.a550  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.a553  ca         dex              	DEX				; decrement the buffer counter (delete)

>a554  2c                          	.byte	$2C			; make LDX into BIT abs
.a555                              lab_1357

.a555  a2 00      ldx #$00         	LDX	#$00			; clear BASIC line buffer pointer
.a557                              lab_1359
.a557  20 b7 c3   jsr $c3b7        	JSR	V_INPT		; call scan input device
.a55a  90 fb      bcc $a557        	BCC	LAB_1359		; loop if no byte
.a55c  f0 f9      beq $a557        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
.a55e  c9 07      cmp #$07         	CMP	#$07			; compare with [BELL]
.a560  f0 10      beq $a572        	BEQ	LAB_1378		; branch if [BELL]
.a562  c9 0d      cmp #$0d         	CMP	#$0D			; compare with [CR]
.a564  f0 19      beq $a57f        	BEQ	LAB_1384		; do CR/LF exit if [CR]
.a566  e0 00      cpx #$00         	CPX	#$00			; compare pointer with $00
.a568  d0 04      bne $a56e        	BNE	LAB_1374		; branch if not empty
.a56a  c9 21      cmp #$21         	CMP	#$21			; compare with [SP]+1
.a56c  90 e9      bcc $a557        	BCC	LAB_1359		; if < ignore character
.a56e                              lab_1374
.a56e  c9 08      cmp #$08         	CMP	#$08			; compare with [BACKSPACE] (delete last character)
.a570  f0 de      beq $a550        	BEQ	LAB_134B		; go delete last character
.a572                              lab_1378
.a572  e0 47      cpx #$47         	CPX	#Ibuffe-Ibuffs	; compare character count with max
.a574  b0 0c      bcs $a582        	BCS	LAB_138E		; skip store & do [BELL] if buffer full
.a576  9d 23 02   sta $0223,x      	STA	Ibuffs,X		; else store in buffer
.a579  e8         inx              	INX				; increment pointer
.a57a                              lab_137f
.a57a  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.a57d  d0 d8      bne $a557        	BNE	LAB_1359		; always loop for next character
.a57f                              lab_1384
.a57f  4c 5b ab   jmp $ab5b        	JMP	LAB_1866		; do CR/LF exit to BASIC
.a582                              lab_138e
.a582  a9 07      lda #$07         	LDA	#$07			; [BELL] character into A
.a584  d0 f4      bne $a57a        	BNE	LAB_137F		; go print the [BELL] but ignore input character
.a586                              lab_13a6
.a586  a0 ff      ldy #$ff         	LDY	#$FF			; set save index (makes for easy math later)
.a588  38         sec              	SEC				; set carry for subtract
.a589  a5 c3      lda $c3          	LDA	Bpntrl		; get basic execute pointer low byte
.a58b  e9 23      sbc #$23         	SBC	#<Ibuffs		; subtract input buffer start pointer
.a58d  aa         tax              	TAX				; copy result to X (index past line # if any)
.a58e  86 60      stx $60          	STX	Oquote		; clear open quote/DATA flag
.a590                              lab_13ac
.a590  bd 23 02   lda $0223,x      	LDA	Ibuffs,X		; get byte from input buffer
.a593  f0 51      beq $a5e6        	BEQ	LAB_13EC		; if null save byte then exit
.a595  c9 5f      cmp #$5f         	CMP	#"_"			; compare with "_"
.a597  b0 4d      bcs $a5e6        	BCS	LAB_13EC		; if >= go save byte then continue crunching
.a599  c9 3c      cmp #$3c         	CMP	#"<"			; compare with "<"
.a59b  b0 0e      bcs $a5ab        	BCS	LAB_13CC		; if >= go crunch now
.a59d  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.a59f  b0 45      bcs $a5e6        	BCS	LAB_13EC		; if >= go save byte then continue crunching
.a5a1  85 5c      sta $5c          	STA	Scnquo		; save buffer byte as search character
.a5a3  c9 22      cmp #$22         	CMP	#$22			; is it quote character?
.a5a5  f0 61      beq $a608        	BEQ	LAB_1410		; branch if so (copy quoted string)
.a5a7  c9 2a      cmp #$2a         	CMP	#"*"			; compare with "*"
.a5a9  90 3b      bcc $a5e6        	BCC	LAB_13EC		; if < go save byte then continue crunching
.a5ab                              lab_13cc
.a5ab  24 60      bit $60          	BIT	Oquote		; get open quote/DATA token flag
.a5ad  70 37      bvs $a5e6        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
.a5af  86 78      stx $78          	STX	TempB			; save buffer read index
.a5b1  84 ba      sty $ba          	STY	csidx			; copy buffer save index
.a5b3  a0 93      ldy #$93         	LDY	#<TAB_1STC		; get keyword first character table low address
.a5b5  84 73      sty $73          	STY	ut2_pl		; save pointer low byte
.a5b7  a0 c5      ldy #$c5         	LDY	#>TAB_1STC		; get keyword first character table high address
.a5b9  84 74      sty $74          	STY	ut2_ph		; save pointer high byte
.a5bb  a0 00      ldy #$00         	LDY	#$00			; clear table pointer
.a5bd                              lab_13d0
.a5bd  d1 73      cmp ($73),y      	CMP	(ut2_pl),Y		; compare with keyword first character table byte
.a5bf  f0 05      beq $a5c6        	BEQ	LAB_13D1		; go do word_table_chr if match
.a5c1  90 21      bcc $a5e4        	BCC	LAB_13EA		; if < keyword first character table byte go restore
.a5c3  c8         iny              	INY				; else increment pointer
.a5c4  d0 f7      bne $a5bd        	BNE	LAB_13D0		; and loop (branch always)
.a5c6                              lab_13d1
.a5c6  98         tya              	TYA				; copy matching index
.a5c7  0a         asl              	ASL				; *2 (bytes per pointer)
.a5c8  aa         tax              	TAX				; copy to new index
.a5c9  bd b1 c5   lda $c5b1,x      	LDA	TAB_CHRT,X		; get keyword table pointer low byte
.a5cc  85 73      sta $73          	STA	ut2_pl		; save pointer low byte
.a5ce  bd b2 c5   lda $c5b2,x      	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
.a5d1  85 74      sta $74          	STA	ut2_ph		; save pointer high byte
.a5d3  a0 ff      ldy #$ff         	LDY	#$FF			; clear table pointer (make -1 for start)
.a5d5  a6 78      ldx $78          	LDX	TempB			; restore buffer read index
.a5d7                              lab_13d6
.a5d7  c8         iny              	INY				; next table byte
.a5d8  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get byte from table
.a5da                              lab_13d8
.a5da  30 08      bmi $a5e4        	BMI	LAB_13EA		; all bytes matched so go save token
.a5dc  e8         inx              	INX				; next buffer byte
.a5dd  dd 23 02   cmp $0223,x      	CMP	Ibuffs,X		; compare with byte from input buffer
.a5e0  f0 f5      beq $a5d7        	BEQ	LAB_13D6		; go compare next if match
.a5e2  d0 2b      bne $a60f        	BNE	LAB_1417		; branch if >< (not found keyword)
.a5e4                              lab_13ea
.a5e4  a4 ba      ldy $ba          	LDY	csidx			; restore save index
.a5e6                              lab_13ec
.a5e6  e8         inx              	INX				; increment buffer index (to next input byte)
.a5e7  c8         iny              	INY				; increment save index (to next output byte)
.a5e8  99 23 02   sta $0223,y      	STA	Ibuffs,Y		; save byte to output
.a5eb  c9 00      cmp #$00         	CMP	#$00			; set the flags, set carry
.a5ed  f0 32      beq $a621        	BEQ	LAB_142A		; do exit if was null [EOL]
.a5ef  e9 3a      sbc #$3a         	SBC	#$3A			; subtract ":" (carry set by CMP #00)
.a5f1  f0 04      beq $a5f7        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
.a5f3  c9 49      cmp #$49         	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
.a5f5  d0 02      bne $a5f9        	BNE	LAB_1401		; branch if not DATA
.a5f7                              lab_13ff
.a5f7  85 60      sta $60          	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
.a5f9                              lab_1401
.a5f9  49 57      eor #$57         	EOR	#TK_REM-$3A		; effectively subtract REM token offset
.a5fb  d0 93      bne $a590        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
.a5fd  85 5c      sta $5c          	STA	Asrch			; else was REM so set search for [EOL]
.a5ff                              lab_1408
.a5ff  bd 23 02   lda $0223,x      	LDA	Ibuffs,X		; get byte from input buffer
.a602  f0 e2      beq $a5e6        	BEQ	LAB_13EC		; branch if null [EOL]
.a604  c5 5c      cmp $5c          	CMP	Asrch			; compare with stored character
.a606  f0 de      beq $a5e6        	BEQ	LAB_13EC		; branch if match (end quote)
.a608                              lab_1410
.a608  c8         iny              	INY				; increment buffer save index
.a609  99 23 02   sta $0223,y      	STA	Ibuffs,Y		; save byte to output
.a60c  e8         inx              	INX				; increment buffer read index
.a60d  d0 f0      bne $a5ff        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
.a60f                              lab_1417
.a60f  a6 78      ldx $78          	LDX	TempB			; compare has failed, restore buffer index (start byte!)
.a611                              lab_141b
.a611  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get table byte
.a613  08         php              	PHP				; save status
.a614  c8         iny              	INY				; increment table index
.a615  28         plp              	PLP				; restore byte status
.a616  10 f9      bpl $a611        	BPL	LAB_141B		; if not end of keyword go do next
.a618  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get byte from keyword table
.a61a  d0 be      bne $a5da        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
.a61c  bd 23 02   lda $0223,x      	LDA	Ibuffs,X		; restore byte from input buffer
.a61f  10 c3      bpl $a5e4        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
.a621                              lab_142a
.a621  c8         iny              	INY				; increment pointer
.a622  c8         iny              	INY				; increment pointer (makes it next line pointer high byte)
.a623  99 23 02   sta $0223,y      	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
.a626  c8         iny              	INY				; adjust for line copy
.a627  c8         iny              	INY				; adjust for line copy
.a628  c8         iny              	INY				; adjust for line copy
.a629  c6 c3      dec $c3          	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
.a62b  60         rts              	RTS				;
.a62c                              lab_ssln
.a62c  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.a62e  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.a630                              lab_shln
.a630  a0 01      ldy #$01         	LDY	#$01			; set index
.a632  85 aa      sta $aa          	STA	Baslnl		; save low byte as current
.a634  86 ab      stx $ab          	STX	Baslnh		; save high byte as current
.a636  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get pointer high byte from addr
.a638  f0 1c      beq $a656        	BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
.a63a  c8         iny              	INY				; increment index ...
.a63b  c8         iny              	INY				; ... to line # high byte
.a63c  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # high byte
.a63e  88         dey              	DEY				; decrement index (point to low byte)
.a63f  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.a641  f0 0b      beq $a64e        	BEQ	LAB_144D		; if = go check low byte
.a643  b0 11      bcs $a656        	BCS	LAB_145F		; else if temp < this line, exit (passed line#)
.a645                              lab_1456
.a645  88         dey              	DEY				; decrement index to next line ptr high byte
.a646  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.a648  aa         tax              	TAX				; copy to X
.a649  88         dey              	DEY				; decrement index to next line ptr low byte
.a64a  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer low byte
.a64c  90 e2      bcc $a630        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
.a64e                              lab_144d
.a64e  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # low byte
.a650  c5 11      cmp $11          	CMP	Itempl		; compare with temporary integer low byte
.a652  90 f1      bcc $a645        	BCC	LAB_1456		; loop if temp > this line (not reached line #)
.a654  f0 01      beq $a657        	BEQ	LAB_1460		; exit if temp = (found line #, carry is set)
.a656                              lab_145f
.a656  18         clc              	CLC				; clear found flag
.a657                              lab_1460
.a657  60         rts              	RTS				;
.a658                              lab_new
.a658  d0 fd      bne $a657        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
.a65a                              lab_1463
.a65a  a9 00      lda #$00         	LDA	#$00			; clear A
.a65c  a8         tay              	TAY				; clear Y
.a65d  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first line, next line pointer, low byte
.a65f  c8         iny              	INY				; increment index
.a660  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first line, next line pointer, high byte
.a662  18         clc              	CLC				; clear carry
.a663  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.a665  69 02      adc #$02         	ADC	#$02			; calculate end of BASIC low byte
.a667  85 7b      sta $7b          	STA	Svarl			; save start of vars low byte
.a669  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.a66b  69 00      adc #$00         	ADC	#$00			; add any carry
.a66d  85 7c      sta $7c          	STA	Svarh			; save start of vars high byte
.a66f                              lab_1477
.a66f  18         clc              	CLC				; clear carry
.a670  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.a672  69 ff      adc #$ff         	ADC	#$FF			; -1
.a674  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.a676  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.a678  69 ff      adc #$ff         	ADC	#$FF			; -1+carry
.a67a  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.a67c                              lab_147a
.a67c  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.a67e  a4 86      ldy $86          	LDY	Ememh			; get end of mem high byte
.a680  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.a682  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.a684  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.a686  a4 7c      ldy $7c          	LDY	Svarh			; get start of vars high byte
.a688  85 7d      sta $7d          	STA	Sarryl		; save var mem end low byte
.a68a  84 7e      sty $7e          	STY	Sarryh		; save var mem end high byte
.a68c  85 7f      sta $7f          	STA	Earryl		; save array mem end low byte
.a68e  84 80      sty $80          	STY	Earryh		; save array mem end high byte
.a690  20 50 a8   jsr $a850        	JSR	LAB_161A		; perform RESTORE command
.a693                              lab_1491
.a693  a2 68      ldx #$68         	LDX	#des_sk		; set descriptor stack pointer
.a695  86 65      stx $65          	STX	next_s		; save descriptor stack pointer
.a697  68         pla              	PLA				; pull return address low byte
.a698  aa         tax              	TAX				; copy return address low byte
.a699  68         pla              	PLA				; pull return address high byte
.a69a  8e fe 01   stx $01fe        	STX	LAB_01FE		; save to cleared stack
.a69d  8d ff 01   sta $01ff        	STA	LAB_01FF		; save to cleared stack
.a6a0  a2 fd      ldx #$fd         	LDX	#$FD			; new stack pointer
.a6a2  9a         txs              	TXS				; reset stack
.a6a3  a9 00      lda #$00         	LDA	#$00			; clear byte
.a6a5  85 8c      sta $8c          	STA	Cpntrh		; clear continue pointer high byte
.a6a7  85 61      sta $61          	STA	Sufnxf		; clear subscript/FNX flag
.a6a9                              lab_14a6
.a6a9  60         rts              	RTS				;
.a6aa                              lab_clear
.a6aa  f0 d0      beq $a67c        	BEQ	LAB_147A		; if no following token go do "CLEAR"
.a6ac  60         rts              	RTS				; was following token (go do syntax error)
.a6ad                              lab_list
.a6ad  90 06      bcc $a6b5        	BCC	LAB_14BD		; branch if next character numeric (LIST n...)
.a6af  f0 04      beq $a6b5        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
.a6b1  c9 b6      cmp #$b6         	CMP	#TK_MINUS		; compare with token for -
.a6b3  d0 f4      bne $a6a9        	BNE	LAB_14A6		; exit if not - (LIST -m)
.a6b5                              lab_14bd
.a6b5  20 1c aa   jsr $aa1c        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.a6b8  20 2c a6   jsr $a62c        	JSR	LAB_SSLN		; search BASIC for temp integer line number
.a6bb  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a6be  f0 0c      beq $a6cc        	BEQ	LAB_14D4		; branch if no more characters
.a6c0  c9 b6      cmp #$b6         	CMP	#TK_MINUS		; compare with token for -
.a6c2  d0 93      bne $a657        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
.a6c4  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.a6c7  20 1c aa   jsr $aa1c        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.a6ca  d0 8b      bne $a657        	BNE	LAB_1460		; exit if not ok
.a6cc                              lab_14d4
.a6cc  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.a6ce  05 12      ora $12          	ORA	Itemph		; OR temporary integer high byte
.a6d0  d0 06      bne $a6d8        	BNE	LAB_14E2		; branch if start set
.a6d2  a9 ff      lda #$ff         	LDA	#$FF			; set for -1
.a6d4  85 11      sta $11          	STA	Itempl		; set temporary integer low byte
.a6d6  85 12      sta $12          	STA	Itemph		; set temporary integer high byte
.a6d8                              lab_14e2
.a6d8  a0 01      ldy #$01         	LDY	#$01			; set index for line
.a6da  84 60      sty $60          	STY	Oquote		; clear open quote flag
.a6dc  20 64 ab   jsr $ab64        	JSR	LAB_CRLF		; print CR/LF
.a6df  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.a6e1  f0 3e      beq $a721        	BEQ	LAB_152B		; if null all done so exit
.a6e3  20 20 a8   jsr $a820        	JSR	LAB_1629		; do CRTL-C check vector
.a6e6  c8         iny              	INY				; increment index for line
.a6e7  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # low byte
.a6e9  aa         tax              	TAX				; copy to X
.a6ea  c8         iny              	INY				; increment index
.a6eb  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # high byte
.a6ed  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.a6ef  d0 04      bne $a6f5        	BNE	LAB_14FF		; branch if no high byte match
.a6f1  e4 11      cpx $11          	CPX	Itempl		; compare with temporary integer low byte
.a6f3  f0 02      beq $a6f7        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
.a6f5                              lab_14ff
.a6f5  b0 2a      bcs $a721        	BCS	LAB_152B		; if greater all done so exit
.a6f7                              lab_1501
.a6f7  84 97      sty $97          	STY	Tidx1			; save index for line
.a6f9  20 4b bd   jsr $bd4b        	JSR	LAB_295E		; print XA as unsigned integer
.a6fc  a9 20      lda #$20         	LDA	#$20			; space is the next character
.a6fe                              lab_1508
.a6fe  a4 97      ldy $97          	LDY	Tidx1			; get index for line
.a700  29 7f      and #$7f         	AND	#$7F			; mask top out bit of character
.a702                              lab_150c
.a702  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.a705  c9 22      cmp #$22         	CMP	#$22			; was it " character
.a707  d0 06      bne $a70f        	BNE	LAB_1519		; branch if not
.a709  a5 60      lda $60          	LDA	Oquote		; get open quote flag
.a70b  49 ff      eor #$ff         	EOR	#$FF			; toggle it
.a70d  85 60      sta $60          	STA	Oquote		; save it back
.a70f                              lab_1519
.a70f  c8         iny              	INY				; increment index
.a710  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next byte
.a712  d0 0e      bne $a722        	BNE	LAB_152E		; branch if not [EOL] (go print character)
.a714  a8         tay              	TAY				; else clear index
.a715  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer low byte
.a717  aa         tax              	TAX				; copy to X
.a718  c8         iny              	INY				; increment index
.a719  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.a71b  86 aa      stx $aa          	STX	Baslnl		; set pointer to line low byte
.a71d  85 ab      sta $ab          	STA	Baslnh		; set pointer to line high byte
.a71f  d0 b7      bne $a6d8        	BNE	LAB_14E2		; go do next line if not [EOT]
.a721                              lab_152b
.a721  60         rts              	RTS
.a722                              lab_152e
.a722  10 de      bpl $a702        	BPL	LAB_150C		; just go print it if not token byte
.a724  24 60      bit $60          	BIT	Oquote		; test the open quote flag
.a726  30 da      bmi $a702        	BMI	LAB_150C		; just go print character if open quote set
.a728  a2 c7      ldx #$c7         	LDX	#>LAB_KEYT		; get table address high byte
.a72a  0a         asl              	ASL				; *2
.a72b  0a         asl              	ASL				; *4
.a72c  90 02      bcc $a730        	BCC	LAB_152F		; branch if no carry
.a72e  e8         inx              	INX				; else increment high byte
.a72f  18         clc              	CLC				; clear carry for add
.a730                              lab_152f
.a730  69 6f      adc #$6f         	ADC	#<LAB_KEYT		; add low byte
.a732  90 01      bcc $a735        	BCC	LAB_1530		; branch if no carry
.a734  e8         inx              	INX				; else increment high byte
.a735                              lab_1530
.a735  85 73      sta $73          	STA	ut2_pl		; save table pointer low byte
.a737  86 74      stx $74          	STX	ut2_ph		; save table pointer high byte
.a739  84 97      sty $97          	STY	Tidx1			; save index for line
.a73b  a0 00      ldy #$00         	LDY	#$00			; clear index
.a73d  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get length
.a73f  aa         tax              	TAX				; copy length
.a740  c8         iny              	INY				; increment index
.a741  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get 1st character
.a743  ca         dex              	DEX				; decrement length
.a744  f0 b8      beq $a6fe        	BEQ	LAB_1508		; if no more characters exit & print
.a746  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.a749  c8         iny              	INY				; increment index
.a74a  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get keyword address low byte
.a74c  48         pha              	PHA				; save it for now
.a74d  c8         iny              	INY				; increment index
.a74e  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get keyword address high byte
.a750  a0 00      ldy #$00         	LDY	#$00
.a752  85 74      sta $74          	STA	ut2_ph		; save keyword pointer high byte
.a754  68         pla              	PLA				; pull low byte
.a755  85 73      sta $73          	STA	ut2_pl		; save keyword pointer low byte
.a757                              lab_1540
.a757  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get character
.a759  ca         dex              	DEX				; decrement character count
.a75a  f0 a2      beq $a6fe        	BEQ	LAB_1508		; if last character exit & print
.a75c  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.a75f  c8         iny              	INY				; increment index
.a760  d0 f5      bne $a757        	BNE	LAB_1540		; loop for next character
.a762                              lab_for
.a762  a9 80      lda #$80         	LDA	#$80			; set FNX
.a764  85 61      sta $61          	STA	Sufnxf		; set subscript/FNX flag
.a766  20 84 aa   jsr $aa84        	JSR	LAB_LET		; go do LET
.a769  68         pla              	PLA				; pull return address
.a76a  68         pla              	PLA				; pull return address
.a76b  a9 10      lda #$10         	LDA	#$10			; we need 16d bytes !
.a76d  20 07 a4   jsr $a407        	JSR	LAB_1212		; check room on stack for A bytes
.a770  20 a9 a9   jsr $a9a9        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.a773  18         clc              	CLC				; clear carry for add
.a774  98         tya              	TYA				; copy index to A
.a775  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.a777  48         pha              	PHA				; push onto stack
.a778  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.a77a  69 00      adc #$00         	ADC	#$00			; add carry
.a77c  48         pha              	PHA				; push onto stack
.a77d  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.a77f  48         pha              	PHA				; push onto stack
.a780  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.a782  48         pha              	PHA				; push onto stack
.a783  a9 ac      lda #$ac         	LDA	#TK_TO		; get "TO" token
.a785  20 f2 ae   jsr $aef2        	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error, then warm start
.a788  20 9c ad   jsr $ad9c        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.a78b  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.a78e  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.a790  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.a792  25 ad      and $ad          	AND	FAC1_1		; and FAC1 mantissa1
.a794  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.a796  a9 a1      lda #$a1         	LDA	#<LAB_159F		; set return address low byte
.a798  a0 a7      ldy #$a7         	LDY	#>LAB_159F		; set return address high byte
.a79a  85 71      sta $71          	STA	ut1_pl		; save return address low byte
.a79c  84 72      sty $72          	STY	ut1_ph		; save return address high byte
.a79e  4c 4e ae   jmp $ae4e        	JMP	LAB_1B66		; round FAC1 & put on stack (returns to next instruction)
.a7a1                              lab_159f
.a7a1  a9 a9      lda #$a9         	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
.a7a3  a0 c4      ldy #$c4         	LDY	#>LAB_259C		; set 1 pointer high addr
.a7a5  20 44 bb   jsr $bb44        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.a7a8  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a7ab  c9 b1      cmp #$b1         	CMP	#TK_STEP		; compare with STEP token
.a7ad  d0 06      bne $a7b5        	BNE	LAB_15B3		; jump if not "STEP"
.a7af  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.a7b2  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.a7b5                              lab_15b3
.a7b5  20 b3 bb   jsr $bbb3        	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
.a7b8  85 b0      sta $b0          	STA	FAC1_s		; set FAC1 sign (b7)
.a7ba  20 43 ae   jsr $ae43        	JSR	LAB_1B5B		; push sign, round FAC1 & put on stack
.a7bd  a5 98      lda $98          	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.a7bf  48         pha              	PHA				; push on stack
.a7c0  a5 97      lda $97          	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.a7c2  48         pha              	PHA				; push on stack
.a7c3  a9 81      lda #$81         	LDA	#TK_FOR		; get FOR token
.a7c5  48         pha              	PHA				; push on stack
.a7c6                              lab_15c2
.a7c6  20 20 a8   jsr $a820        	JSR	LAB_1629		; do CRTL-C check vector
.a7c9  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.a7cb  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.a7cd  a6 88      ldx $88          	LDX	Clineh		; continue line is $FFxx for immediate mode
.a7cf  e8         inx              	INX				; increment it (now $00 if immediate mode)
.a7d0  f0 04      beq $a7d6        	BEQ	LAB_15D1		; branch if null (immediate mode)
.a7d2  85 8b      sta $8b          	STA	Cpntrl		; save continue pointer low byte
.a7d4  84 8c      sty $8c          	STY	Cpntrh		; save continue pointer high byte
.a7d6                              lab_15d1
.a7d6  a0 00      ldy #$00         	LDY	#$00			; clear index
.a7d8  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next byte
.a7da  f0 07      beq $a7e3        	BEQ	LAB_15DC		; branch if null [EOL]
.a7dc  c9 3a      cmp #$3a         	CMP	#$3A			; compare with ":"
.a7de  f0 1d      beq $a7fd        	BEQ	LAB_15F6		; branch if = (statement separator)
.a7e0                              lab_15d9
.a7e0  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; else syntax error, then warm start
.a7e3                              lab_15dc
.a7e3  a0 02      ldy #$02         	LDY	#$02			; set index
.a7e5  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line pointer high byte
.a7e7  18         clc              	CLC				; clear carry for no "BREAK" message
.a7e8  f0 58      beq $a842        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
.a7ea  c8         iny              	INY				; increment index
.a7eb  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get line # low byte
.a7ed  85 87      sta $87          	STA	Clinel		; save current line low byte
.a7ef  c8         iny              	INY				; increment index
.a7f0  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get line # high byte
.a7f2  85 88      sta $88          	STA	Clineh		; save current line high byte
.a7f4  98         tya              	TYA				; A now = 4
.a7f5  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.a7f7  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.a7f9  90 02      bcc $a7fd        	BCC	LAB_15F6		; branch if no overflow
.a7fb  e6 c4      inc $c4          	INC	Bpntrh		; else increment BASIC execute pointer high byte
.a7fd                              lab_15f6
.a7fd  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.a800                              lab_15f9
.a800  20 06 a8   jsr $a806        	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
.a803                              lab_15fc
.a803  4c c6 a7   jmp $a7c6        	JMP	LAB_15C2		; loop
.a806                              lab_15ff
.a806  f0 56      beq $a85e        	BEQ	LAB_1628		; exit if zero [EOL]
.a808                              lab_1602
.a808  49 80      eor #$80         	EOR	#$80			; normalise token (was SEC, SBC)
.a80a  10 03      bpl $a80f        	BPL	LAB_1609		; branch if token
.a80c  4c 84 aa   jmp $aa84        	JMP	LAB_LET		; else go do implied LET
.a80f                              lab_1609
.a80f  c9 2b      cmp #$2b         	CMP	#(TK_TAB-$80)	; compare normalised token with TAB
.a811  b0 cd      bcs $a7e0        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error, then warm start)
.a813  0a         asl              	ASL	A			; *2 (2 bytes per vector)
.a814  a8         tay              	TAY				; copy to index
.a815  b9 d1 c4   lda $c4d1,y      	LDA	LAB_CTBL+1,Y	; get vector high byte
.a818  48         pha              	PHA				; onto stack
.a819  b9 d0 c4   lda $c4d0,y      	LDA	LAB_CTBL,Y		; get vector low byte
.a81c  48         pha              	PHA				; onto stack
.a81d  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; jump to increment & scan memory
.a820                              lab_1629
.a820  6c 03 02   jmp ($0203)      	JMP	(VEC_CC)		; ctrl c check vector
.a823                              lab_1636
.a823  c9 03      cmp #$03         	CMP	#$03			; compare with CTRL-C
.a825                              lab_stop
.a825  b0 01      bcs $a828        	BCS	LAB_163B		; branch if token follows STOP
.a827                              lab_end
.a827  18         clc              	CLC				; clear carry (indicate program end)
.a828                              lab_163b
.a828  d0 67      bne $a891        	BNE	LAB_167A		; return if wasn't CTRL-C
.a82a  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.a82c  49 02      eor #$02         	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
.a82e  f0 10      beq $a840        	BEQ	LAB_164F		; branch if BASIC pointer is in buffer
.a830  49 02      eor #$02         	EOR	#>Ibuffs		; correct the bits
.a832  a4 c3      ldy $c3          	LDY	Bpntrl		; get BASIC execute pointer low byte
.a834  84 8b      sty $8b          	STY	Cpntrl		; save continue pointer low byte
.a836  85 8c      sta $8c          	STA	Cpntrh		; save continue pointer high byte
.a838                              lab_1647
.a838  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.a83a  a4 88      ldy $88          	LDY	Clineh		; get current line high byte
.a83c  85 89      sta $89          	STA	Blinel		; save break line low byte
.a83e  84 8a      sty $8a          	STY	Blineh		; save break line high byte
.a840                              lab_164f
.a840  68         pla              	PLA				; pull return address low
.a841  68         pla              	PLA				; pull return address high
.a842                              lab_1651
.a842  90 07      bcc $a84b        	BCC	LAB_165E		; jump if was program end
.a844  a9 38      lda #$38         	LDA	#<LAB_BMSG		; point to "Break" (low byte)
.a846  a0 ca      ldy #$ca         	LDY	#>LAB_BMSG		; point to "Break" (high byte)
.a848  4c 51 a4   jmp $a451        	JMP	LAB_1269		; print "Break" and do warm start
.a84b                              lab_165e
.a84b  4c 5c a4   jmp $a45c        	JMP	LAB_1274		; go do warm start
.a84e                              lab_restore
.a84e  d0 0f      bne $a85f        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
.a850                              lab_161a
.a850  38         sec              	SEC				; set carry for subtract
.a851  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.a853  e9 01      sbc #$01         	SBC	#$01			; -1
.a855  a4 7a      ldy $7a          	LDY	Smemh			; get start of mem high byte
.a857  b0 01      bcs $a85a        	BCS	LAB_1624		; branch if no underflow
.a859                              lab_uflow
.a859  88         dey              	DEY				; else decrement high byte
.a85a                              lab_1624
.a85a  85 8f      sta $8f          	STA	Dptrl			; save DATA pointer low byte
.a85c  84 90      sty $90          	STY	Dptrh			; save DATA pointer high byte
.a85e                              lab_1628
.a85e  60         rts              	RTS				;
.a85f                              lab_restoren
.a85f  20 1c aa   jsr $aa1c        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.a862  20 ac a9   jsr $a9ac        	JSR	LAB_SNBL		; scan for next BASIC line
.a865  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.a867  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.a869  b0 0b      bcs $a876        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
.a86b  98         tya              	TYA				; else copy line index to A
.a86c  38         sec              	SEC				; set carry (+1)
.a86d  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.a86f  a6 c4      ldx $c4          	LDX	Bpntrh		; get BASIC execute pointer high byte
.a871  90 07      bcc $a87a        	BCC	LAB_go_search	; branch if no overflow to high byte
.a873  e8         inx              	INX				; increment high byte
.a874  b0 04      bcs $a87a        	BCS	LAB_go_search	; branch always (can never be carry clear)
.a876                              lab_reset_search
.a876  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.a878  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.a87a                              lab_go_search
.a87a  20 30 a6   jsr $a630        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.a87d  b0 03      bcs $a882        	BCS	LAB_line_found	; if carry set go set pointer
.a87f  4c 7e a9   jmp $a97e        	JMP	LAB_16F7		; else go do "Undefined statement" error
.a882                              lab_line_found
.a882  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.a884  e9 01      sbc #$01         	SBC	#$01			; -1
.a886  a4 ab      ldy $ab          	LDY	Baslnh		; get pointer high byte
.a888  b0 d0      bcs $a85a        	BCS	LAB_1624		; branch if no underflow (save DATA pointer & return)
.a88a  90 cd      bcc $a859        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer &
.a88c                              lab_null
.a88c  20 50 b7   jsr $b750        	JSR	LAB_GTBY		; get byte parameter
.a88f  86 0d      stx $0d          	STX	Nullct		; save new NULL count
.a891                              lab_167a
.a891  60         rts              	RTS				;
.a892                              lab_cont
.a892  d0 fd      bne $a891        	BNE	LAB_167A		; if following byte exit to do syntax error
.a894  a4 8c      ldy $8c          	LDY	Cpntrh		; get continue pointer high byte
.a896  d0 05      bne $a89d        	BNE	LAB_166C		; go do continue if we can
.a898  a2 1e      ldx #$1e         	LDX	#$1E			; error code $1E ("Can't continue" error)
.a89a  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.a89d                              lab_166c
.a89d  a9 93      lda #$93         	LDA	#TK_ON		; set token for ON
.a89f  20 d6 c1   jsr $c1d6        	JSR	LAB_IRQ		; set IRQ flags
.a8a2  a9 93      lda #$93         	LDA	#TK_ON		; set token for ON
.a8a4  20 d9 c1   jsr $c1d9        	JSR	LAB_NMI		; set NMI flags
.a8a7  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.a8a9  a5 8b      lda $8b          	LDA	Cpntrl		; get continue pointer low byte
.a8ab  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.a8ad  a5 89      lda $89          	LDA	Blinel		; get break line low byte
.a8af  a4 8a      ldy $8a          	LDY	Blineh		; get break line high byte
.a8b1  85 87      sta $87          	STA	Clinel		; set current line low byte
.a8b3  84 88      sty $88          	STY	Clineh		; set current line high byte
.a8b5  60         rts              	RTS				;
.a8b6                              lab_run
.a8b6  d0 03      bne $a8bb        	BNE	LAB_1696		; branch if RUN n
.a8b8  4c 6f a6   jmp $a66f        	JMP	LAB_1477		; reset execution to start, clear vars, flush stack & RET
.a8bb                              lab_1696
.a8bb  20 7c a6   jsr $a67c        	JSR	LAB_147A		; go do "CLEAR"
.a8be  f0 2e      beq $a8ee        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
.a8c0                              lab_do
.a8c0  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for DO
.a8c2  20 07 a4   jsr $a407        	JSR	LAB_1212		; check room on stack for A bytes
.a8c5  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.a8c7  48         pha              	PHA				; push on stack
.a8c8  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.a8ca  48         pha              	PHA				; push on stack
.a8cb  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.a8cd  48         pha              	PHA				; push on stack
.a8ce  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.a8d0  48         pha              	PHA				; push on stack
.a8d1  a9 9d      lda #$9d         	LDA	#TK_DO		; token for DO
.a8d3  48         pha              	PHA				; push on stack
.a8d4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a8d7  4c c6 a7   jmp $a7c6        	JMP	LAB_15C2		; go do interpreter inner loop
.a8da                              lab_gosub
.a8da  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for GOSUB
.a8dc  20 07 a4   jsr $a407        	JSR	LAB_1212		; check room on stack for A bytes
.a8df  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.a8e1  48         pha              	PHA				; push on stack
.a8e2  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.a8e4  48         pha              	PHA				; push on stack
.a8e5  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.a8e7  48         pha              	PHA				; push on stack
.a8e8  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.a8ea  48         pha              	PHA				; push on stack
.a8eb  a9 8d      lda #$8d         	LDA	#TK_GOSUB		; token for GOSUB
.a8ed  48         pha              	PHA				; push on stack
.a8ee                              lab_16b0
.a8ee  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a8f1  20 f7 a8   jsr $a8f7        	JSR	LAB_GOTO		; perform GOTO n
.a8f4  4c c6 a7   jmp $a7c6        	JMP	LAB_15C2		; go do interpreter inner loop
.a8f7                              lab_goto
.a8f7  20 1c aa   jsr $aa1c        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.a8fa  20 ac a9   jsr $a9ac        	JSR	LAB_SNBL		; scan for next BASIC line
.a8fd  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.a8ff  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.a901  b0 0b      bcs $a90e        	BCS	LAB_16D0		; branch if >= (start search from beginning)
.a903  98         tya              	TYA				; else copy line index to A
.a904  38         sec              	SEC				; set carry (+1)
.a905  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.a907  a6 c4      ldx $c4          	LDX	Bpntrh		; get BASIC execute pointer high byte
.a909  90 07      bcc $a912        	BCC	LAB_16D4		; branch if no overflow to high byte
.a90b  e8         inx              	INX				; increment high byte
.a90c  b0 04      bcs $a912        	BCS	LAB_16D4		; branch always (can never be carry)
.a90e                              lab_16d0
.a90e  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.a910  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.a912                              lab_16d4
.a912  20 30 a6   jsr $a630        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.a915  90 67      bcc $a97e        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
.a917  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.a919  e9 01      sbc #$01         	SBC	#$01			; -1
.a91b  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.a91d  a5 ab      lda $ab          	LDA	Baslnh		; get pointer high byte
.a91f  e9 00      sbc #$00         	SBC	#$00			; subtract carry
.a921  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.a923                              lab_16e5
.a923  60         rts              	RTS				;
.a924                              lab_donok
.a924  a2 22      ldx #$22         	LDX	#$22			; error code $22 ("LOOP without DO" error)
.a926  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.a929                              lab_loop
.a929  a8         tay              	TAY				; save following token
.a92a  ba         tsx              	TSX				; copy stack pointer
.a92b  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get token byte from stack
.a92e  c9 9d      cmp #$9d         	CMP	#TK_DO		; compare with DO token
.a930  d0 f2      bne $a924        	BNE	LAB_DONOK		; branch if no matching DO
.a932  e8         inx              	INX				; dump calling routine return address
.a933  e8         inx              	INX				; dump calling routine return address
.a934  9a         txs              	TXS				; correct stack
.a935  98         tya              	TYA				; get saved following token back
.a936  f0 20      beq $a958        	BEQ	LoopAlways		; if no following token loop forever
.a938  c9 3a      cmp #$3a         	CMP	#$3A			; could be ':'
.a93a  f0 1c      beq $a958        	BEQ	LoopAlways		; if :... loop forever
.a93c  e9 b2      sbc #$b2         	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
.a93e  aa         tax              	TAX				; copy to X (if it was UNTIL then X will be correct)
.a93f  f0 04      beq $a945        	BEQ	DoRest		; branch if was UNTIL
.a941  ca         dex              	DEX				; decrement result
.a942  d0 62      bne $a9a6        	BNE	LAB_16FC		; if not WHILE go do syntax error & warm start
.a944  ca         dex              	DEX				; set invert result byte
.a945                              dorest
.a945  86 98      stx $98          	STX	Frnxth		; save invert result byte
.a947  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.a94a  20 ad ad   jsr $adad        	JSR	LAB_EVEX		; evaluate expression
.a94d  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a94f  f0 02      beq $a953        	BEQ	DoCmp			; if =0 go do straight compare
.a951  a9 ff      lda #$ff         	LDA	#$FF			; else set all bits
.a953                              docmp
.a953  ba         tsx              	TSX				; copy stack pointer
.a954  45 98      eor $98          	EOR	Frnxth		; EOR with invert byte
.a956  d0 1a      bne $a972        	BNE	LoopDone		; if <> 0 clear stack & back to interpreter loop
.a958                              loopalways
.a958  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get current line low byte
.a95b  85 87      sta $87          	STA	Clinel		; save current line low byte
.a95d  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get current line high byte
.a960  85 88      sta $88          	STA	Clineh		; save current line high byte
.a962  bd 04 01   lda $0104,x      	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
.a965  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.a967  bd 05 01   lda $0105,x      	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
.a96a  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.a96c  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a96f  4c c6 a7   jmp $a7c6        	JMP	LAB_15C2		; go do interpreter inner loop
.a972                              loopdone
.a972  e8         inx              	INX				; dump DO token
.a973  e8         inx              	INX				; dump current line low byte
.a974  e8         inx              	INX				; dump current line high byte
.a975  e8         inx              	INX				; dump BASIC execute pointer low byte
.a976  e8         inx              	INX				; dump BASIC execute pointer high byte
.a977  9a         txs              	TXS				; correct stack
.a978  4c 98 a9   jmp $a998        	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
.a97b                              lab_16f4
.a97b  a2 04      ldx #$04         	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)

>a97d  2c                          	.byte	$2C			; makes next line BIT LAB_0EA2
.a97e                              lab_16f7

.a97e  a2 0e      ldx #$0e         	LDX	#$0E			; error code $0E ("Undefined statement" error)
.a980  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.a983                              lab_return
.a983  d0 9e      bne $a923        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
.a985                              lab_16e8
.a985  68         pla              	PLA				; dump calling routine return address
.a986  68         pla              	PLA				; dump calling routine return address
.a987  68         pla              	PLA				; pull token
.a988  c9 8d      cmp #$8d         	CMP	#TK_GOSUB		; compare with GOSUB token
.a98a  d0 ef      bne $a97b        	BNE	LAB_16F4		; branch if no matching GOSUB
.a98c                              lab_16ff
.a98c  68         pla              	PLA				; pull current line low byte
.a98d  85 87      sta $87          	STA	Clinel		; save current line low byte
.a98f  68         pla              	PLA				; pull current line high byte
.a990  85 88      sta $88          	STA	Clineh		; save current line high byte
.a992  68         pla              	PLA				; pull BASIC execute pointer low byte
.a993  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.a995  68         pla              	PLA				; pull BASIC execute pointer high byte
.a996  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.a998                              lab_data
.a998  20 a9 a9   jsr $a9a9        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.a99b                              lab_170f
.a99b  98         tya              	TYA				; copy index to A
.a99c  18         clc              	CLC				; clear carry for add
.a99d  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.a99f  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.a9a1  90 02      bcc $a9a5        	BCC	LAB_1719		; skip next if no carry
.a9a3  e6 c4      inc $c4          	INC	Bpntrh		; else increment BASIC execute pointer high byte
.a9a5                              lab_1719
.a9a5  60         rts              	RTS				;
.a9a6                              lab_16fc
.a9a6  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; do syntax error, then warm start
.a9a9                              lab_snbs
.a9a9  a2 3a      ldx #$3a         	LDX	#$3A			; set look for character = ":"

>a9ab  2c                          	.byte	$2C			; makes next line BIT $00A2
.a9ac                              lab_snbl

.a9ac  a2 00      ldx #$00         	LDX	#$00			; set alt search character = [EOL]
.a9ae  86 5b      stx $5b          	STX	Srchc			; store alt search character
.a9b0  a0 00      ldy #$00         	LDY	#$00			; set search character = [EOL]
.a9b2  84 5c      sty $5c          	STY	Asrch			; store search character
.a9b4                              lab_1725
.a9b4  a5 5c      lda $5c          	LDA	Asrch			; get search character
.a9b6  a6 5b      ldx $5b          	LDX	Srchc			; get alt search character
.a9b8  85 5b      sta $5b          	STA	Srchc			; make search character = alt search character
.a9ba  86 5c      stx $5c          	STX	Asrch			; make alt search character = search character
.a9bc                              lab_172d
.a9bc  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next byte
.a9be  f0 e5      beq $a9a5        	BEQ	LAB_1719		; exit if null [EOL]
.a9c0  c5 5c      cmp $5c          	CMP	Asrch			; compare with search character
.a9c2  f0 e1      beq $a9a5        	BEQ	LAB_1719		; exit if found
.a9c4  c8         iny              	INY				; increment index
.a9c5  c9 22      cmp #$22         	CMP	#$22			; compare current character with open quote
.a9c7  f0 eb      beq $a9b4        	BEQ	LAB_1725		; if found go swap search character for alt search character
.a9c9  d0 f1      bne $a9bc        	BNE	LAB_172D		; go get next character
.a9cb                              lab_if
.a9cb  20 ad ad   jsr $adad        	JSR	LAB_EVEX		; evaluate expression
.a9ce  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a9d1  c9 89      cmp #$89         	CMP	#TK_GOTO		; compare with "GOTO" token
.a9d3  f0 05      beq $a9da        	BEQ	LAB_174B		; jump if was "GOTO"
.a9d5  a9 af      lda #$af         	LDA	#TK_THEN		; get THEN token
.a9d7  20 f2 ae   jsr $aef2        	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error, then warm start
.a9da                              lab_174b
.a9da  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.a9dc  d0 05      bne $a9e3        	BNE	LAB_1754		; branch if result was non zero
.a9de                              lab_rem
.a9de  20 ac a9   jsr $a9ac        	JSR	LAB_SNBL		; scan for next BASIC line
.a9e1  f0 b8      beq $a99b        	BEQ	LAB_170F		; go set BASIC execute pointer & RET (always)
.a9e3                              lab_1754
.a9e3  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.a9e6  b0 03      bcs $a9eb        	BCS	LAB_175C		; branch if not numeric character (is var or keyword)
.a9e8  4c f7 a8   jmp $a8f7        	JMP	LAB_GOTO		; else do GOTO n (was numeric)
.a9eb                              lab_175c
.a9eb  4c 06 a8   jmp $a806        	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
.a9ee                              lab_on
.a9ee  c9 a9      cmp #$a9         	CMP	#TK_IRQ		; was it IRQ token ?
.a9f0  d0 03      bne $a9f5        	BNE	LAB_NOIN		; if not go check NMI
.a9f2  4c fb c1   jmp $c1fb        	JMP	LAB_SIRQ		; else go set-up IRQ
.a9f5                              lab_noin
.a9f5  c9 aa      cmp #$aa         	CMP	#TK_NMI		; was it NMI token ?
.a9f7  d0 03      bne $a9fc        	BNE	LAB_NONM		; if not go do normal ON command
.a9f9  4c ff c1   jmp $c1ff        	JMP	LAB_SNMI		; else go set-up NMI
.a9fc                              lab_nonm
.a9fc  20 50 b7   jsr $b750        	JSR	LAB_GTBY		; get byte parameter
.a9ff  48         pha              	PHA				; push GOTO/GOSUB token
.aa00  c9 8d      cmp #$8d         	CMP	#TK_GOSUB		; compare with GOSUB token
.aa02  f0 04      beq $aa08        	BEQ	LAB_176B		; branch if GOSUB
.aa04                              lab_1767
.aa04  c9 89      cmp #$89         	CMP	#TK_GOTO		; compare with GOTO token
.aa06  d0 9e      bne $a9a6        	BNE	LAB_16FC		; if not GOTO do syntax error, then warm start
.aa08                              lab_176b
.aa08  c6 af      dec $af          	DEC	FAC1_3		; decrement index (byte value)
.aa0a  d0 04      bne $aa10        	BNE	LAB_1773		; branch if not zero
.aa0c  68         pla              	PLA				; pull GOTO/GOSUB token
.aa0d  4c 08 a8   jmp $a808        	JMP	LAB_1602		; go execute it
.aa10                              lab_1773
.aa10  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.aa13  20 1c aa   jsr $aa1c        	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
.aa16  c9 2c      cmp #$2c         	CMP	#$2C			; compare next character with ","
.aa18  f0 ee      beq $aa08        	BEQ	LAB_176B		; loop if ","
.aa1a                              lab_177e
.aa1a  68         pla              	PLA				; else pull keyword token (run out of options)
.aa1b                              lab_177f
.aa1b  60         rts              	RTS				; and exit
.aa1c                              lab_gfpn
.aa1c  a2 00      ldx #$00         	LDX	#$00			; clear reg
.aa1e  86 11      stx $11          	STX	Itempl		; clear temporary integer low byte
.aa20  86 12      stx $12          	STX	Itemph		; clear temporary integer high byte
.aa22                              lab_1785
.aa22  b0 f7      bcs $aa1b        	BCS	LAB_177F		; return if carry set (end of scan, character was not 0-9)
.aa24  e9 2f      sbc #$2f         	SBC	#$2F			; subtract $30 ($2F+carry) from byte
.aa26  85 5b      sta $5b          	STA	Temp3			; store #
.aa28  a5 12      lda $12          	LDA	Itemph		; get temporary integer high byte
.aa2a  85 71      sta $71          	STA	ut1_pl		; save it for now
.aa2c  c9 19      cmp #$19         	CMP	#$19			; compare with $19
.aa2e  b0 d4      bcs $aa04        	BCS	LAB_1767		; branch if >= (makes max line # 63999 because next
.aa30  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.aa32  0a         asl              	ASL	A			; *2 low byte
.aa33  26 71      rol $71          	ROL	ut1_pl		; *2 high byte
.aa35  0a         asl              	ASL	A			; *2 low byte
.aa36  26 71      rol $71          	ROL	ut1_pl		; *2 high byte (*4)
.aa38  65 11      adc $11          	ADC	Itempl		; + low byte (*5)
.aa3a  85 11      sta $11          	STA	Itempl		; save it
.aa3c  a5 71      lda $71          	LDA	ut1_pl		; get high byte temp
.aa3e  65 12      adc $12          	ADC	Itemph		; + high byte (*5)
.aa40  85 12      sta $12          	STA	Itemph		; save it
.aa42  06 11      asl $11          	ASL	Itempl		; *2 low byte (*10d)
.aa44  26 12      rol $12          	ROL	Itemph		; *2 high byte (*10d)
.aa46  a5 11      lda $11          	LDA	Itempl		; get low byte
.aa48  65 5b      adc $5b          	ADC	Temp3			; add #
.aa4a  85 11      sta $11          	STA	Itempl		; save low byte
.aa4c  90 02      bcc $aa50        	BCC	LAB_17B3		; branch if no overflow to high byte
.aa4e  e6 12      inc $12          	INC	Itemph		; else increment high byte
.aa50                              lab_17b3
.aa50  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.aa53  4c 22 aa   jmp $aa22        	JMP	LAB_1785		; loop for next character
.aa56                              lab_dec
.aa56  a9 ad      lda #$ad         	LDA	#<LAB_2AFD		; set -1 pointer low byte

>aa58  2c                          	.byte	$2C			; BIT abs to skip the LDA below
.aa59                              lab_inc

.aa59  a9 a9      lda #$a9         	LDA	#<LAB_259C		; set 1 pointer low byte
.aa5b                              lab_17b5
.aa5b  48         pha              	PHA				; save +/-1 pointer low byte
.aa5c                              lab_17b7
.aa5c  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get var address
.aa5f  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.aa61  30 1e      bmi $aa81        	BMI	IncrErr		; exit if string
.aa63  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.aa65  84 98      sty $98          	STY	Lvarph		; save var address high byte
.aa67  20 44 bb   jsr $bb44        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.aa6a  68         pla              	PLA				; get +/-1 pointer low byte
.aa6b  48         pha              	PHA				; save +/-1 pointer low byte
.aa6c  a0 c4      ldy #$c4         	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
.aa6e  20 82 b8   jsr $b882        	JSR	LAB_246C		; add (AY) to FAC1
.aa71  20 6d bb   jsr $bb6d        	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
.aa74  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.aa77  c9 2c      cmp #$2c         	CMP	#$2C			; compare with ","
.aa79  d0 9f      bne $aa1a        	BNE	LAB_177E		; exit if not "," (either end or error)
.aa7b  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.aa7e  4c 5c aa   jmp $aa5c        	JMP	LAB_17B7		; go do next var
.aa81                              increrr
.aa81  4c a8 ad   jmp $ada8        	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.aa84                              lab_let
.aa84  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get var address
.aa87  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.aa89  84 98      sty $98          	STY	Lvarph		; save var address high byte
.aa8b  a9 c0      lda #$c0         	LDA	#TK_EQUAL		; get = token
.aa8d  20 f2 ae   jsr $aef2        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error, then warm start
.aa90  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.aa92  48         pha              	PHA				; push data type flag
.aa93  20 ad ad   jsr $adad        	JSR	LAB_EVEX		; evaluate expression
.aa96  68         pla              	PLA				; pop data type flag
.aa97  2a         rol              	ROL	A			; set carry if type = string
.aa98  20 9f ad   jsr $ad9f        	JSR	LAB_CKTM		; type match check, set C for string
.aa9b  d0 03      bne $aaa0        	BNE	LAB_17D5		; branch if string
.aa9d  4c 6d bb   jmp $bb6d        	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) & RET
.aaa0                              lab_17d5
.aaa0  a0 02      ldy #$02         	LDY	#$02			; set index to pointer high byte
.aaa2  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get string pointer high byte
.aaa4  c5 82      cmp $82          	CMP	Sstorh		; compare bottom of string space high byte
.aaa6  90 17      bcc $aabf        	BCC	LAB_17F4		; if less assign value & exit (was in program memory)
.aaa8  d0 07      bne $aab1        	BNE	LAB_17E6		; branch if >
.aaaa  88         dey              	DEY				; decrement index
.aaab  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get pointer low byte
.aaad  c5 81      cmp $81          	CMP	Sstorl		; compare bottom of string space low byte
.aaaf  90 0e      bcc $aabf        	BCC	LAB_17F4		; if less assign value & exit (was in program memory)
.aab1                              lab_17e6
.aab1  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.aab3  c4 7c      cpy $7c          	CPY	Svarh			; compare start of vars high byte
.aab5  90 08      bcc $aabf        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
.aab7  d0 0d      bne $aac6        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
.aab9  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.aabb  c5 7b      cmp $7b          	CMP	Svarl			; compare start of vars low byte
.aabd  b0 07      bcs $aac6        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
.aabf                              lab_17f4
.aabf  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.aac1  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.aac3  4c dc aa   jmp $aadc        	JMP	LAB_1811		; clean stack, copy descriptor to variable & return
.aac6                              lab_17fb
.aac6  a0 00      ldy #$00         	LDY	#$00			; index to length
.aac8  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get string length
.aaca  20 07 b4   jsr $b407        	JSR	LAB_209C		; copy string
.aacd  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.aacf  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.aad1  85 b8      sta $b8          	STA	ssptr_l		; save descriptor pointer low byte
.aad3  84 b9      sty $b9          	STY	ssptr_h		; save descriptor pointer high byte
.aad5  20 e6 b5   jsr $b5e6        	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.aad8  a9 ac      lda #$ac         	LDA	#$AC			; set descriptor pointer low byte
.aada  a0 00      ldy #$00         	LDY	#$00			; get descriptor pointer high byte
.aadc                              lab_1811
.aadc  85 9e      sta $9e          	STA	des_2l		; save descriptor_2 pointer low byte
.aade  84 9f      sty $9f          	STY	des_2h		; save descriptor_2 pointer high byte
.aae0  20 48 b6   jsr $b648        	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.aae3  a0 00      ldy #$00         	LDY	#$00			; index to length
.aae5  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string length
.aae7  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.aae9  c8         iny              	INY				; index to string pointer low byte
.aaea  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string pointer low byte
.aaec  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.aaee  c8         iny              	INY				; index to string pointer high byte
.aaef  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string pointer high byte
.aaf1  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.aaf3                              lab_1828
.aaf3  60         rts              	RTS				;
.aaf4                              lab_get
.aaf4  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get var address
.aaf7  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.aaf9  84 98      sty $98          	STY	Lvarph		; save var address high byte
.aafb  20 c2 c1   jsr $c1c2        	JSR	INGET			; get input byte
.aafe  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.ab00  30 07      bmi $ab09        	BMI	LAB_GETS		; go get string character
.ab02  a8         tay              	TAY				; copy character to Y
.ab03  20 38 b3   jsr $b338        	JSR	LAB_1FD0		; convert Y to byte in FAC1
.ab06  4c 6d bb   jmp $bb6d        	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) & return
.ab09                              lab_gets
.ab09  48         pha              	PHA				; save character
.ab0a  a9 01      lda #$01         	LDA	#$01			; string is single byte
.ab0c  b0 01      bcs $ab0f        	BCS	LAB_IsByte		; branch if byte received
.ab0e  68         pla              	PLA				; string is null
.ab0f                              lab_isbyte
.ab0f  20 0f b4   jsr $b40f        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.ab12  f0 05      beq $ab19        	BEQ	LAB_NoSt		; skip store if null string
.ab14  68         pla              	PLA				; get character back
.ab15  a0 00      ldy #$00         	LDY	#$00			; clear index
.ab17  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save byte in string (byte IS string!)
.ab19                              lab_nost
.ab19  20 5a b4   jsr $b45a        	JSR	LAB_RTST		; check for space on descriptor stack then put address
.ab1c  4c a0 aa   jmp $aaa0        	JMP	LAB_17D5		; do string LET & return
.ab1f                              lab_1829
.ab1f  20 a7 ab   jsr $aba7        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.ab22                              lab_182c
.ab22  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.ab25                              lab_print
.ab25  f0 3d      beq $ab64        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
.ab27                              lab_1831
.ab27  f0 ca      beq $aaf3        	BEQ	LAB_1828		;.exit if nothing more to print
.ab29  c9 ab      cmp #$ab         	CMP	#TK_TAB		; compare with TAB( token
.ab2b  f0 56      beq $ab83        	BEQ	LAB_18A2		; go do TAB/SPC
.ab2d  c9 ae      cmp #$ae         	CMP	#TK_SPC		; compare with SPC( token
.ab2f  f0 52      beq $ab83        	BEQ	LAB_18A2		; go do TAB/SPC
.ab31  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.ab33  f0 38      beq $ab6d        	BEQ	LAB_188B		; go do move to next TAB mark
.ab35  c9 3b      cmp #$3b         	CMP	#";"			; compare with ";"
.ab37  f0 65      beq $ab9e        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
.ab39  20 ad ad   jsr $adad        	JSR	LAB_EVEX		; evaluate expression
.ab3c  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.ab3e  30 df      bmi $ab1f        	BMI	LAB_1829		; branch if string
.ab40  20 5b bd   jsr $bd5b        	JSR	LAB_296E		; convert FAC1 to string
.ab43  20 19 b4   jsr $b419        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.ab46  a0 00      ldy #$00         	LDY	#$00			; clear index
.ab48  a5 0f      lda $0f          	LDA	TWidth		; get terminal width byte
.ab4a  f0 0a      beq $ab56        	BEQ	LAB_185E		; skip check if zero
.ab4c  38         sec              	SEC				; set carry for subtract
.ab4d  e5 0e      sbc $0e          	SBC	TPos			; subtract terminal position
.ab4f  f1 ae      sbc ($ae),y      	SBC	(des_pl),Y		; subtract string length
.ab51  b0 03      bcs $ab56        	BCS	LAB_185E		; branch if less than terminal width
.ab53  20 64 ab   jsr $ab64        	JSR	LAB_CRLF		; else print CR/LF
.ab56                              lab_185e
.ab56  20 a7 ab   jsr $aba7        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.ab59  f0 c7      beq $ab22        	BEQ	LAB_182C		; always go continue processing line
.ab5b                              lab_1866
.ab5b  a9 00      lda #$00         	LDA	#$00			; clear byte
.ab5d  9d 23 02   sta $0223,x      	STA	Ibuffs,X		; null terminate input
.ab60  a2 22      ldx #$22         	LDX	#<(Ibuffs-1)	; set X to buffer start-1 low byte
.ab62  a0 02      ldy #$02         	LDY	#>(Ibuffs-1)	; set Y to buffer start-1 high byte
.ab64                              lab_crlf
.ab64  a9 0d      lda #$0d         	LDA	#$0D			; load [CR]
.ab66  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.ab69  a9 0a      lda #$0a         	LDA	#$0A			; load [LF]
.ab6b  d0 51      bne $abbe        	BNE	LAB_PRNA		; go print the character & return (always branch)
.ab6d                              lab_188b
.ab6d  a5 0e      lda $0e          	LDA	TPos			; get terminal position
.ab6f  c5 10      cmp $10          	CMP	Iclim			; compare with input column limit
.ab71  90 05      bcc $ab78        	BCC	LAB_1897		; branch if less
.ab73  20 64 ab   jsr $ab64        	JSR	LAB_CRLF		; else print CR/LF (next line)
.ab76  d0 26      bne $ab9e        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
.ab78                              lab_1897
.ab78  38         sec              	SEC				; set carry for subtract
.ab79                              lab_1898
.ab79  e5 64      sbc $64          	SBC	TabSiz		; subtract TAB size
.ab7b  b0 fc      bcs $ab79        	BCS	LAB_1898		; loop if result was +ve
.ab7d  49 ff      eor #$ff         	EOR	#$FF			; complement it
.ab7f  69 01      adc #$01         	ADC	#$01			; +1 (twos complement)
.ab81  d0 14      bne $ab97        	BNE	LAB_18B6		; always print A spaces (result is never $00)
.ab83                              lab_18a2
.ab83  48         pha              	PHA				; save token
.ab84  20 4d b7   jsr $b74d        	JSR	LAB_SGBY		; scan and get byte parameter
.ab87  c9 29      cmp #$29         	CMP	#$29			; is next character )
.ab89  d0 7b      bne $ac06        	BNE	LAB_1910		; if not do syntax error, then warm start
.ab8b  68         pla              	PLA				; get token back
.ab8c  c9 ab      cmp #$ab         	CMP	#TK_TAB		; was it TAB ?
.ab8e  d0 08      bne $ab98        	BNE	LAB_18B7		; branch if not (was SPC)
.ab90  8a         txa              	TXA				; copy integer value to A
.ab91  e5 0e      sbc $0e          	SBC	TPos			; subtract terminal position
.ab93  90 09      bcc $ab9e        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
.ab95  f0 07      beq $ab9e        	BEQ	LAB_18BD		; branch if result was = $0 (already here)
.ab97                              lab_18b6
.ab97  aa         tax              	TAX				; copy result to X
.ab98                              lab_18b7
.ab98  20 b9 ab   jsr $abb9        	JSR	LAB_18E0		; print " "
.ab9b  ca         dex              	DEX				; decrement count
.ab9c  d0 fa      bne $ab98        	BNE	LAB_18B7		; loop if not all done
.ab9e                              lab_18bd
.ab9e  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.aba1  4c 27 ab   jmp $ab27        	JMP	LAB_1831		; continue executing PRINT
.aba4                              lab_18c3
.aba4  20 19 b4   jsr $b419        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.aba7                              lab_18c6
.aba7  20 13 b6   jsr $b613        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.abaa  a0 00      ldy #$00         	LDY	#$00			; reset index
.abac  aa         tax              	TAX				; copy length to X
.abad  f0 4a      beq $abf9        	BEQ	LAB_188C		; exit (RTS) if null string
.abaf                              lab_18cd
.abaf  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get next byte
.abb1  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.abb4  c8         iny              	INY				; increment index
.abb5  ca         dex              	DEX				; decrement count
.abb6  d0 f7      bne $abaf        	BNE	LAB_18CD		; loop if not done yet
.abb8  60         rts              	RTS				;
.abb9                              lab_18e0
.abb9  a9 20      lda #$20         	LDA	#$20			; load " "

>abbb  2c                          	.byte	$2C			; change next line to BIT LAB_3FA9
.abbc                              lab_18e3

.abbc  a9 3f      lda #$3f         	LDA	#$3F			; load "?" character
.abbe                              lab_prna
.abbe  c9 20      cmp #$20         	CMP	#$20			; compare with " "
.abc0  90 1a      bcc $abdc        	BCC	LAB_18F9		; branch if less (non printing)
.abc2  48         pha              	PHA				; save the character
.abc3  a5 0f      lda $0f          	LDA	TWidth		; get terminal width
.abc5  d0 0b      bne $abd2        	BNE	LAB_18F0		; branch if not zero (not infinite length)
.abc7  38         sec              	SEC				; set carry for subtract
.abc8  a5 0e      lda $0e          	LDA	TPos			; get position
.abca  e5 64      sbc $64          	SBC	TabSiz		; subtract TAB size
.abcc  d0 0b      bne $abd9        	BNE	LAB_18F7		; skip reset if different
.abce  85 0e      sta $0e          	STA	TPos			; else reset position
.abd0  f0 07      beq $abd9        	BEQ	LAB_18F7		; go print character
.abd2                              lab_18f0
.abd2  c5 0e      cmp $0e          	CMP	TPos			; compare with terminal character position
.abd4  d0 03      bne $abd9        	BNE	LAB_18F7		; branch if not at end of line
.abd6  20 64 ab   jsr $ab64        	JSR	LAB_CRLF		; else print CR/LF
.abd9                              lab_18f7
.abd9  e6 0e      inc $0e          	INC	TPos			; increment terminal position
.abdb  68         pla              	PLA				; get character back
.abdc                              lab_18f9
.abdc  20 ba c3   jsr $c3ba        	JSR	V_OUTP		; output byte via output vector
.abdf  c9 0d      cmp #$0d         	CMP	#$0D			; compare with [CR]
.abe1  d0 14      bne $abf7        	BNE	LAB_188A		; branch if not [CR]
.abe3                              lab_1878
.abe3  86 78      stx $78          	STX	TempB			; save buffer index
.abe5  a6 0d      ldx $0d          	LDX	Nullct		; get null count
.abe7  f0 0a      beq $abf3        	BEQ	LAB_1886		; branch if no nulls
.abe9  a9 00      lda #$00         	LDA	#$00			; load [NULL]
.abeb                              lab_1880
.abeb  20 be ab   jsr $abbe        	JSR	LAB_PRNA		; go print the character
.abee  ca         dex              	DEX				; decrement count
.abef  d0 fa      bne $abeb        	BNE	LAB_1880		; loop if not all done
.abf1  a9 0d      lda #$0d         	LDA	#$0D			; restore the character (and set the flags)
.abf3                              lab_1886
.abf3  86 0e      stx $0e          	STX	TPos			; clear terminal position (X always = zero when we get here)
.abf5  a6 78      ldx $78          	LDX	TempB			; restore buffer index
.abf7                              lab_188a
.abf7  29 ff      and #$ff         	AND	#$FF			; set the flags
.abf9                              lab_188c
.abf9  60         rts              	RTS				;
.abfa                              lab_1904
.abfa  a5 62      lda $62          	LDA	Imode			; get input mode flag, $00=INPUT, $98=READ
.abfc  10 0b      bpl $ac09        	BPL	LAB_1913		; branch if INPUT (go do redo)
.abfe  a5 8d      lda $8d          	LDA	Dlinel		; get current DATA line low byte
.ac00  a4 8e      ldy $8e          	LDY	Dlineh		; get current DATA line high byte
.ac02  85 87      sta $87          	STA	Clinel		; save current line low byte
.ac04  84 88      sty $88          	STY	Clineh		; save current line high byte
.ac06                              lab_1910
.ac06  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; do syntax error, then warm start
.ac09                              lab_1913
.ac09  a9 6b      lda #$6b         	LDA	#<LAB_REDO		; point to redo message (low addr)
.ac0b  a0 ca      ldy #$ca         	LDY	#>LAB_REDO		; point to redo message (high addr)
.ac0d  20 a4 ab   jsr $aba4        	JSR	LAB_18C3		; print null terminated string from memory
.ac10  a5 8b      lda $8b          	LDA	Cpntrl		; get continue pointer low byte
.ac12  a4 8c      ldy $8c          	LDY	Cpntrh		; get continue pointer high byte
.ac14  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.ac16  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.ac18  60         rts              	RTS				;
.ac19                              lab_input
.ac19  c9 22      cmp #$22         	CMP	#$22			; compare next byte with open quote
.ac1b  d0 0b      bne $ac28        	BNE	LAB_1934		; branch if no prompt string
.ac1d  20 b1 ae   jsr $aeb1        	JSR	LAB_1BC1		;.print "..." string
.ac20  a9 3b      lda #$3b         	LDA	#$3B			; load A with ";"
.ac22  20 f2 ae   jsr $aef2        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error, then warm start
.ac25  20 a7 ab   jsr $aba7        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.ac28                              lab_1934
.ac28  20 3c b3   jsr $b33c        	JSR	LAB_CKRN		; check not Direct (back here if ok)
.ac2b  20 48 a5   jsr $a548        	JSR	LAB_INLN		; print "? " and get BASIC input
.ac2e  ad 23 02   lda $0223        	LDA	Ibuffs		; get first byte from buffer
.ac31  d0 09      bne $ac3c        	BNE	(LAB_1953+1)	; branch if not null input (this is a strange branch, it
.ac33  18         clc              	CLC				; was null input so clear carry to exit prog
.ac34  4c 38 a8   jmp $a838        	JMP	LAB_1647		; go do BREAK exit
.ac37                              lab_read
.ac37  a6 8f      ldx $8f          	LDX	Dptrl			; get DATA pointer low byte
.ac39  a4 90      ldy $90          	LDY	Dptrh			; get DATA pointer high byte
.ac3b                              lab_1953
.ac3b  a9 98      lda #$98         	LDA	#$98			; set mode = READ
.ac3d  85 62      sta $62          	STA	Imode			; set input mode flag, <=$7F=INPUT, $98=READ
.ac3f  86 91      stx $91          	STX	Rdptrl		; save READ pointer low byte
.ac41  84 92      sty $92          	STY	Rdptrh		; save READ pointer high byte
.ac43                              lab_195b
.ac43  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get (var) address
.ac46  85 97      sta $97          	STA	Lvarpl		; save address low byte
.ac48  84 98      sty $98          	STY	Lvarph		; save address high byte
.ac4a  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.ac4c  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.ac4e  85 11      sta $11          	STA	Itempl		; save as temporary integer low byte
.ac50  84 12      sty $12          	STY	Itemph		; save as temporary integer high byte
.ac52  a6 91      ldx $91          	LDX	Rdptrl		; get READ pointer low byte
.ac54  a4 92      ldy $92          	LDY	Rdptrh		; get READ pointer high byte
.ac56  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.ac58  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.ac5a  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.ac5d  d0 0e      bne $ac6d        	BNE	LAB_1985		; branch if not null
.ac5f  24 62      bit $62          	BIT	Imode			; test input mode flag, $00=INPUT, $98=READ
.ac61  30 62      bmi $acc5        	BMI	LAB_19DD		; branch if READ
.ac63  20 bc ab   jsr $abbc        	JSR	LAB_18E3		; print "?" character (double ? for extended input)
.ac66  20 48 a5   jsr $a548        	JSR	LAB_INLN		; print "? " and get BASIC input
.ac69  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.ac6b  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.ac6d                              lab_1985
.ac6d  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.ac70  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.ac72  10 24      bpl $ac98        	BPL	LAB_19B0		; branch if numeric
.ac74  85 5b      sta $5b          	STA	Srchc			; save search character
.ac76  c9 22      cmp #$22         	CMP	#$22			; was it " ?
.ac78  f0 07      beq $ac81        	BEQ	LAB_1999		; branch if so
.ac7a  a9 3a      lda #$3a         	LDA	#":"			; else search character is ":"
.ac7c  85 5b      sta $5b          	STA	Srchc			; set new search character
.ac7e  a9 2c      lda #$2c         	LDA	#","			; other search character is ","
.ac80  18         clc              	CLC				; clear carry for add
.ac81                              lab_1999
.ac81  85 5c      sta $5c          	STA	Asrch			; set second search character
.ac83  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.ac85  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.ac87  69 00      adc #$00         	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
.ac89  90 01      bcc $ac8c        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
.ac8b  c8         iny              	INY				; else increment high byte
.ac8c                              lab_19a4
.ac8c  20 1f b4   jsr $b41f        	JSR	LAB_20B4		; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
.ac8f  20 93 b7   jsr $b793        	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
.ac92  20 a0 aa   jsr $aaa0        	JSR	LAB_17D5		; go do string LET
.ac95  4c 9e ac   jmp $ac9e        	JMP	LAB_19B6		; go check string terminator
.ac98                              lab_19b0
.ac98  20 70 bc   jsr $bc70        	JSR	LAB_2887		; get FAC1 from string
.ac9b  20 6d bb   jsr $bb6d        	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
.ac9e                              lab_19b6
.ac9e  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.aca1  f0 07      beq $acaa        	BEQ	LAB_19C2		; branch if null (last entry)
.aca3  c9 2c      cmp #$2c         	CMP	#","			; else compare with ","
.aca5  f0 03      beq $acaa        	BEQ	LAB_19C2		; branch if ","
.aca7  4c fa ab   jmp $abfa        	JMP	LAB_1904		; else go handle bad input data
.acaa                              lab_19c2
.acaa  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
.acac  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
.acae  85 91      sta $91          	STA	Rdptrl		; save for now
.acb0  84 92      sty $92          	STY	Rdptrh		; save for now
.acb2  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
.acb4  a4 12      ldy $12          	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
.acb6  85 c3      sta $c3          	STA	Bpntrl		; set BASIC execute pointer low byte
.acb8  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.acba  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.acbd  f0 2b      beq $acea        	BEQ	LAB_1A03		; if null go do extra ignored message
.acbf  20 f0 ae   jsr $aef0        	JSR	LAB_1C01		; else scan for "," , else do syntax error, then warm start
.acc2  4c 43 ac   jmp $ac43        	JMP	LAB_195B		; go INPUT next variable from list
.acc5                              lab_19dd
.acc5  20 a9 a9   jsr $a9a9        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.acc8  c8         iny              	INY				; increment index
.acc9  aa         tax              	TAX				; copy character ([:] or [EOL])
.acca  d0 12      bne $acde        	BNE	LAB_19F6		; branch if [:]
.accc  a2 06      ldx #$06         	LDX	#$06			; set for "Out of DATA" error
.acce  c8         iny              	INY				; increment index (now points to next line pointer high byte)
.accf  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line pointer high byte
.acd1  f0 72      beq $ad45        	BEQ	LAB_1A54		; branch if end (eventually does error X)
.acd3  c8         iny              	INY				; increment index
.acd4  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line # low byte
.acd6  85 8d      sta $8d          	STA	Dlinel		; save current DATA line low byte
.acd8  c8         iny              	INY				; increment index
.acd9  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line # high byte
.acdb  c8         iny              	INY				; increment index
.acdc  85 8e      sta $8e          	STA	Dlineh		; save current DATA line high byte
.acde                              lab_19f6
.acde  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get byte
.ace0  aa         tax              	TAX				; copy to X
.ace1  20 9b a9   jsr $a99b        	JSR	LAB_170F		; set BASIC execute pointer
.ace4  e0 83      cpx #$83         	CPX	#TK_DATA		; compare with "DATA" token
.ace6  f0 85      beq $ac6d        	BEQ	LAB_1985		; was "DATA" so go do next READ
.ace8  d0 db      bne $acc5        	BNE	LAB_19DD		; go find next statement if not "DATA"
.acea                              lab_1a03
.acea  a5 91      lda $91          	LDA	Rdptrl		; get temp READ pointer low byte
.acec  a4 92      ldy $92          	LDY	Rdptrh		; get temp READ pointer high byte
.acee  a6 62      ldx $62          	LDX	Imode			; get input mode flag, $00=INPUT, $98=READ
.acf0  10 03      bpl $acf5        	BPL	LAB_1A0E		; branch if INPUT
.acf2  4c 5a a8   jmp $a85a        	JMP	LAB_1624		; save AY as DATA pointer & RET
.acf5                              lab_1a0e
.acf5  a0 00      ldy #$00         	LDY	#$00			; clear index
.acf7  b1 91      lda ($91),y      	LDA	(Rdptrl),Y		; get next byte
.acf9  d0 01      bne $acfc        	BNE	LAB_1A1B		; error if not end of INPUT
.acfb  60         rts              	RTS				;
.acfc                              lab_1a1b
.acfc  a9 5a      lda #$5a         	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
.acfe  a0 ca      ldy #$ca         	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
.ad00  4c a4 ab   jmp $aba4        	JMP	LAB_18C3		; print null terminated string from memory & return
.ad03                              lab_11a1
.ad03  ba         tsx              	TSX				; copy stack pointer
.ad04  e8         inx              	INX				; +1 pass return address
.ad05  e8         inx              	INX				; +2 pass return address
.ad06  e8         inx              	INX				; +3 pass calling routine return address
.ad07  e8         inx              	INX				; +4 pass calling routine return address
.ad08                              lab_11a6
.ad08  bd 01 01   lda $0101,x      	LDA	LAB_STAK+1,X	; get token byte from stack
.ad0b  c9 81      cmp #$81         	CMP	#TK_FOR		; is it FOR token
.ad0d  d0 21      bne $ad30        	BNE	LAB_11CE		; exit if not FOR token
.ad0f  a5 98      lda $98          	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.ad11  d0 0a      bne $ad1d        	BNE	LAB_11BB		; branch if not null
.ad13  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
.ad16  85 97      sta $97          	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
.ad18  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
.ad1b  85 98      sta $98          	STA	Frnxth		; save var pointer for FOR/NEXT high byte
.ad1d                              lab_11bb
.ad1d  dd 03 01   cmp $0103,x      	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
.ad20  d0 07      bne $ad29        	BNE	LAB_11C7		; branch if no match
.ad22  a5 97      lda $97          	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.ad24  dd 02 01   cmp $0102,x      	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
.ad27  f0 07      beq $ad30        	BEQ	LAB_11CE		; exit if match found
.ad29                              lab_11c7
.ad29  8a         txa              	TXA				; copy index
.ad2a  18         clc              	CLC				; clear carry for add
.ad2b  69 10      adc #$10         	ADC	#$10			; add FOR stack use size
.ad2d  aa         tax              	TAX				; copy back to index
.ad2e  d0 d8      bne $ad08        	BNE	LAB_11A6		; loop if not at start of stack
.ad30                              lab_11ce
.ad30  60         rts              	RTS				;
.ad31                              lab_next
.ad31  d0 04      bne $ad37        	BNE	LAB_1A46		; branch if NEXT var
.ad33  a0 00      ldy #$00         	LDY	#$00			; else clear Y
.ad35  f0 03      beq $ad3a        	BEQ	LAB_1A49		; branch always (no variable to search for)
.ad37                              lab_1a46
.ad37  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get variable address
.ad3a                              lab_1a49
.ad3a  85 97      sta $97          	STA	Frnxtl		; store variable pointer low byte
.ad3c  84 98      sty $98          	STY	Frnxth		; store variable pointer high byte
.ad3e  20 03 ad   jsr $ad03        	JSR	LAB_11A1		; search the stack for FOR activity
.ad41  f0 04      beq $ad47        	BEQ	LAB_1A56		; branch if found
.ad43  a2 00      ldx #$00         	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
.ad45                              lab_1a54
.ad45  f0 63      beq $adaa        	BEQ	LAB_1ABE		; do error #X, then warm start
.ad47                              lab_1a56
.ad47  9a         txs              	TXS				; set stack pointer (X set by search, dumps return addresses)
.ad48  8a         txa              	TXA				; copy stack pointer
.ad49  38         sec              	SEC				; set carry for subtract
.ad4a  e9 f7      sbc #$f7         	SBC	#$F7			; point to TO var
.ad4c  85 73      sta $73          	STA	ut2_pl		; save pointer to TO var for compare
.ad4e  69 fb      adc #$fb         	ADC	#$FB			; point to STEP var
.ad50  a0 01      ldy #$01         	LDY	#>LAB_STAK		; point to stack page high byte
.ad52  20 44 bb   jsr $bb44        	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
.ad55  ba         tsx              	TSX				; get stack pointer back
.ad56  bd 08 01   lda $0108,x      	LDA	LAB_STAK+8,X	; get step sign
.ad59  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.ad5b  a5 97      lda $97          	LDA	Frnxtl		; get FOR variable pointer low byte
.ad5d  a4 98      ldy $98          	LDY	Frnxth		; get FOR variable pointer high byte
.ad5f  20 82 b8   jsr $b882        	JSR	LAB_246C		; add (FOR variable) to FAC1
.ad62  20 6d bb   jsr $bb6d        	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
.ad65  a0 01      ldy #$01         	LDY	#>lAB_STAK		; point to stack page high byte
.ad67  20 e3 bb   jsr $bbe3        	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
.ad6a  ba         tsx              	TSX				; get stack pointer back
.ad6b  dd 08 01   cmp $0108,x      	CMP	LAB_STAK+8,X	; compare step sign
.ad6e  f0 17      beq $ad87        	BEQ	LAB_1A9B		; branch if = (loop complete)
.ad70  bd 0d 01   lda $010d,x      	LDA	LAB_STAK+$0D,X	; get FOR line low byte
.ad73  85 87      sta $87          	STA	Clinel		; save current line low byte
.ad75  bd 0e 01   lda $010e,x      	LDA	LAB_STAK+$0E,X	; get FOR line high byte
.ad78  85 88      sta $88          	STA	Clineh		; save current line high byte
.ad7a  bd 10 01   lda $0110,x      	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
.ad7d  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.ad7f  bd 0f 01   lda $010f,x      	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
.ad82  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.ad84                              lab_1a98
.ad84  4c c6 a7   jmp $a7c6        	JMP	LAB_15C2		; go do interpreter inner loop
.ad87                              lab_1a9b
.ad87  8a         txa              	TXA				; stack copy to A
.ad88  69 0f      adc #$0f         	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
.ad8a  aa         tax              	TAX				; copy back to index
.ad8b  9a         txs              	TXS				; copy to stack pointer
.ad8c  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.ad8f  c9 2c      cmp #$2c         	CMP	#$2C			; compare with ","
.ad91  d0 f1      bne $ad84        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
.ad93  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; else increment & scan memory
.ad96  20 37 ad   jsr $ad37        	JSR	LAB_1A46		; do NEXT (var)
.ad99                              lab_evnm
.ad99  20 ad ad   jsr $adad        	JSR	LAB_EVEX		; evaluate expression
.ad9c                              lab_ctnm
.ad9c  18         clc              	CLC				; destination is numeric

>ad9d  24                          	.byte	$24			; makes next line BIT $38
.ad9e                              lab_ctst

.ad9e  38         sec              	SEC				; required type is string
.ad9f                              lab_cktm
.ad9f  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.ada1  30 03      bmi $ada6        	BMI	LAB_1ABA		; branch if data type is string
.ada3  b0 03      bcs $ada8        	BCS	LAB_1ABC		; if required type is string do type mismatch error
.ada5                              lab_1ab9
.ada5  60         rts              	RTS				;
.ada6                              lab_1aba
.ada6  b0 fd      bcs $ada5        	BCS	LAB_1AB9		; exit if required type is string
.ada8                              lab_1abc
.ada8  a2 18      ldx #$18         	LDX	#$18			; error code $18 ("Type mismatch" error)
.adaa                              lab_1abe
.adaa  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.adad                              lab_evex
.adad  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.adaf  d0 02      bne $adb3        	BNE	LAB_1AC7		; skip next if not zero
.adb1  c6 c4      dec $c4          	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.adb3                              lab_1ac7
.adb3  c6 c3      dec $c3          	DEC	Bpntrl		; decrement BASIC execute pointer low byte
.adb5  a9 00      lda #$00         	LDA	#$00			; set null precedence (flag done)
.adb7                              lab_1acc
.adb7  48         pha              	PHA				; push precedence byte
.adb8  a9 02      lda #$02         	LDA	#$02			; 2 bytes
.adba  20 07 a4   jsr $a407        	JSR	LAB_1212		; check room on stack for A bytes
.adbd  20 88 ae   jsr $ae88        	JSR	LAB_GVAL		; get value from line
.adc0  a9 00      lda #$00         	LDA	#$00			; clear A
.adc2  85 9b      sta $9b          	STA	comp_f		; clear compare function flag
.adc4                              lab_1adb
.adc4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.adc7                              lab_1ade
.adc7  38         sec              	SEC				; set carry for subtract
.adc8  e9 bf      sbc #$bf         	SBC	#TK_GT		; subtract token for > (lowest comparison function)
.adca  90 17      bcc $ade3        	BCC	LAB_1AFA		; branch if < TK_GT
.adcc  c9 03      cmp #$03         	CMP	#$03			; compare with ">" to "<" tokens
.adce  b0 13      bcs $ade3        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
.add0  c9 01      cmp #$01         	CMP	#$01			; compare with token for =
.add2  2a         rol              	ROL	A			; *2, b0 = carry (=1 if token was = or <)
.add3  49 01      eor #$01         	EOR	#$01			; toggle b0
.add5  45 9b      eor $9b          	EOR	comp_f		; EOR with compare function flag bits
.add7  c5 9b      cmp $9b          	CMP	comp_f		; compare with compare function flag
.add9  90 65      bcc $ae40        	BCC	LAB_1B53		; if <(comp_f) do syntax error, then warm start
.addb  85 9b      sta $9b          	STA	comp_f		; save new compare function flag
.addd  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.ade0  4c c7 ad   jmp $adc7        	JMP	LAB_1ADE		; go do next character
.ade3                              lab_1afa
.ade3  a6 9b      ldx $9b          	LDX	comp_f		; get compare function flag
.ade5  d0 2c      bne $ae13        	BNE	LAB_1B2A		; branch if compare function
.ade7  b0 77      bcs $ae60        	BCS	LAB_1B78		; go do functions
.ade9  69 0a      adc #$0a         	ADC	#(TK_GT-TK_PLUS)	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
.adeb  90 73      bcc $ae60        	BCC	LAB_1B78		; branch if < + operator
.aded  65 5f      adc $5f          	ADC	Dtypef		; add data type flag, $FF=string, $00=numeric
.adef  d0 03      bne $adf4        	BNE	LAB_1B0B		; branch if not string or not + token
.adf1  4c a9 b5   jmp $b5a9        	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
.adf4                              lab_1b0b
.adf4  69 ff      adc #$ff         	ADC	#$FF			; -1 (corrects for carry add)
.adf6  85 71      sta $71          	STA	ut1_pl		; save it
.adf8  0a         asl              	ASL	A			; *2
.adf9  65 71      adc $71          	ADC	ut1_pl		; *3
.adfb  a8         tay              	TAY				; copy to index
.adfc                              lab_1b13
.adfc  68         pla              	PLA				; pull previous precedence
.adfd  d9 6c c5   cmp $c56c,y      	CMP	LAB_OPPT,Y		; compare with precedence byte
.ae00  b0 63      bcs $ae65        	BCS	LAB_1B7D		; branch if A >=
.ae02  20 9c ad   jsr $ad9c        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.ae05                              lab_1b1c
.ae05  48         pha              	PHA				; save precedence
.ae06                              lab_1b1d
.ae06  20 2c ae   jsr $ae2c        	JSR	LAB_1B43		;.get vector, execute function then continue evaluation
.ae09  68         pla              	PLA				; restore precedence
.ae0a  a4 99      ldy $99          	LDY	prstk			; get precedence stacked flag
.ae0c  10 17      bpl $ae25        	BPL	LAB_1B3C		; branch if stacked values
.ae0e  aa         tax              	TAX				; copy precedence (set flags)
.ae0f  f0 74      beq $ae85        	BEQ	LAB_1B9D		; exit if done
.ae11  d0 5b      bne $ae6e        	BNE	LAB_1B86		; else pop FAC2 & return (branch always)
.ae13                              lab_1b2a
.ae13  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.ae15  8a         txa              	TXA				; copy compare function flag
.ae16  2a         rol              	ROL	A			; <<1
.ae17  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.ae19  d0 02      bne $ae1d        	BNE	LAB_1B34		; branch if no underflow
.ae1b  c6 c4      dec $c4          	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.ae1d                              lab_1b34
.ae1d  c6 c3      dec $c3          	DEC	Bpntrl		; decrement BASIC execute pointer low byte
.ae1f  a0 24      ldy #$24         	LDY	#(TK_LT-TK_PLUS)*3; set offset to last operator entry
.ae21  85 9b      sta $9b          	STA	comp_f		; save new compare function flag
.ae23  d0 d7      bne $adfc        	BNE	LAB_1B13		; branch always
.ae25                              lab_1b3c
.ae25  d9 6c c5   cmp $c56c,y      	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
.ae28  b0 44      bcs $ae6e        	BCS	LAB_1B86		; branch if A >=, pop FAC2 & return
.ae2a  90 d9      bcc $ae05        	BCC	LAB_1B1C		; branch always
.ae2c                              lab_1b43
.ae2c  b9 6e c5   lda $c56e,y      	LDA	LAB_OPPT+2,Y	; get function vector high byte
.ae2f  48         pha              	PHA				; onto stack
.ae30  b9 6d c5   lda $c56d,y      	LDA	LAB_OPPT+1,Y	; get function vector low byte
.ae33  48         pha              	PHA				; onto stack
.ae34  20 43 ae   jsr $ae43        	JSR	LAB_1B5B		; function will return here, then the next RTS will call
.ae37  a5 9b      lda $9b          	LDA	comp_f		; get compare function flag
.ae39  48         pha              	PHA				; push compare evaluation byte
.ae3a  b9 6c c5   lda $c56c,y      	LDA	LAB_OPPT,Y		; get precedence byte
.ae3d  4c b7 ad   jmp $adb7        	JMP	LAB_1ACC		; continue evaluating expression
.ae40                              lab_1b53
.ae40  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; do syntax error, then warm start
.ae43                              lab_1b5b
.ae43  68         pla              	PLA				; get return addr low byte
.ae44  85 71      sta $71          	STA	ut1_pl		; save it
.ae46  e6 71      inc $71          	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
.ae48  68         pla              	PLA				; get return addr high byte
.ae49  85 72      sta $72          	STA	ut1_ph		; save it
.ae4b  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.ae4d  48         pha              	PHA				; push sign
.ae4e                              lab_1b66
.ae4e  20 a3 bb   jsr $bba3        	JSR	LAB_27BA		; round FAC1
.ae51  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.ae53  48         pha              	PHA				; push on stack
.ae54  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.ae56  48         pha              	PHA				; push on stack
.ae57  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.ae59  48         pha              	PHA				; push on stack
.ae5a  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ae5c  48         pha              	PHA				; push on stack
.ae5d  6c 71 00   jmp ($0071)      	JMP	(ut1_pl)		; return, sort of
.ae60                              lab_1b78
.ae60  a0 ff      ldy #$ff         	LDY	#$FF			; flag function
.ae62  68         pla              	PLA				; pull precedence byte
.ae63                              lab_1b7b
.ae63  f0 20      beq $ae85        	BEQ	LAB_1B9D		; exit if done
.ae65                              lab_1b7d
.ae65  c9 64      cmp #$64         	CMP	#$64			; compare previous precedence with $64
.ae67  f0 03      beq $ae6c        	BEQ	LAB_1B84		; branch if was $64 (< function)
.ae69  20 9c ad   jsr $ad9c        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.ae6c                              lab_1b84
.ae6c  84 99      sty $99          	STY	prstk			; save precedence stacked flag
.ae6e                              lab_1b86
.ae6e  68         pla              	PLA				; pop byte
.ae6f  4a         lsr              	LSR	A			; shift out comparison evaluation lowest bit
.ae70  85 63      sta $63          	STA	Cflag			; save comparison evaluation flag
.ae72  68         pla              	PLA				; pop exponent
.ae73  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.ae75  68         pla              	PLA				; pop mantissa1
.ae76  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.ae78  68         pla              	PLA				; pop mantissa2
.ae79  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.ae7b  68         pla              	PLA				; pop mantissa3
.ae7c  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.ae7e  68         pla              	PLA				; pop sign
.ae7f  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign (b7)
.ae81  45 b0      eor $b0          	EOR	FAC1_s		; EOR FAC1 sign (b7)
.ae83  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.ae85                              lab_1b9d
.ae85  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ae87  60         rts              	RTS				;
.ae88                              lab_gval
.ae88  a9 00      lda #$00         	LDA	#$00			; clear byte
.ae8a  85 5f      sta $5f          	STA	Dtypef		; clear data type flag, $FF=string, $00=numeric
.ae8c                              lab_1ba4
.ae8c  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.ae8f  b0 03      bcs $ae94        	BCS	LAB_1BAC		; branch if not numeric character
.ae91                              lab_1ba9
.ae91  4c 70 bc   jmp $bc70        	JMP	LAB_2887		; get FAC1 from string & return
.ae94                              lab_1bac
.ae94  c9 24      cmp #$24         	CMP	#"$"			; compare with "$"
.ae96  f0 f9      beq $ae91        	BEQ	LAB_1BA9		; branch if "$", hex number
.ae98  c9 25      cmp #$25         	CMP	#"%"			; else compare with "%"
.ae9a  f0 f5      beq $ae91        	BEQ	LAB_1BA9		; branch if "%", binary number
.ae9c  20 ee b0   jsr $b0ee        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.ae9f  b0 66      bcs $af07        	BCS	LAB_1C18		; get (var), return value in FAC1 & $ flag
.aea1  c9 2e      cmp #$2e         	CMP	#$2E			; compare with "."
.aea3  f0 ec      beq $ae91        	BEQ	LAB_1BA9		; if so get FAC1 from string & return (e.g. was .123)
.aea5  c9 b6      cmp #$b6         	CMP	#TK_MINUS		; compare with token for -
.aea7  f0 57      beq $af00        	BEQ	LAB_1C11		;.branch if - token (do set-up for functions)
.aea9  c9 b5      cmp #$b5         	CMP	#TK_PLUS		; compare with token for +
.aeab  f0 df      beq $ae8c        	BEQ	LAB_1BA4		; branch if + token (+1 = 1 so ignore leading +)
.aead  c9 22      cmp #$22         	CMP	#$22			; compare with "
.aeaf  d0 0f      bne $aec0        	BNE	LAB_1BD0		; branch if not open quote
.aeb1                              lab_1bc1
.aeb1  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.aeb3  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.aeb5  69 00      adc #$00         	ADC	#$00			; add carry to low byte
.aeb7  90 01      bcc $aeba        	BCC	LAB_1BCA		; branch if no overflow
.aeb9  c8         iny              	INY				; increment high byte
.aeba                              lab_1bca
.aeba  20 19 b4   jsr $b419        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.aebd  4c 93 b7   jmp $b793        	JMP	LAB_23F3		; restore BASIC execute pointer from temp & return
.aec0                              lab_1bd0
.aec0  c9 b0      cmp #$b0         	CMP	#TK_NOT		; compare with token for NOT
.aec2  d0 13      bne $aed7        	BNE	LAB_1BE7		; branch if not token for NOT
.aec4  a0 21      ldy #$21         	LDY	#(TK_EQUAL-TK_PLUS)*3
.aec6  d0 3a      bne $af02        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
.aec8                              lab_equal
.aec8  20 76 b1   jsr $b176        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.aecb  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.aecd  49 ff      eor #$ff         	EOR	#$FF			; invert it
.aecf  a8         tay              	TAY				; copy it
.aed0  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.aed2  49 ff      eor #$ff         	EOR	#$FF			; invert it
.aed4  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & RET
.aed7                              lab_1be7
.aed7  c9 ad      cmp #$ad         	CMP	#TK_FN		; compare with token for FN
.aed9  d0 03      bne $aede        	BNE	LAB_1BEE		; branch if not token for FN
.aedb  4c 88 b3   jmp $b388        	JMP	LAB_201E		; go evaluate FNx
.aede                              lab_1bee
.aede  c9 c2      cmp #$c2         	CMP	#TK_SGN		; compare with token for SGN
.aee0  90 02      bcc $aee4        	BCC	LAB_1BF5		; branch if less than SGN token
.aee2  b0 32      bcs $af16        	BCS	LAB_1C27		; go set up function references (branch always)
.aee4                              lab_1bf5
.aee4  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.aee7  20 ad ad   jsr $adad        	JSR	LAB_EVEX		; evaluate expression
.aeea                              lab_1bfb
.aeea  a9 29      lda #$29         	LDA	#$29			; load A with ")"

>aeec  2c                          	.byte	$2C			; makes next line BIT $28A9
.aeed                              lab_1bfe

.aeed  a9 28      lda #$28         	LDA	#$28			; load A with "("

>aeef  2c                          	.byte	$2C			; makes next line BIT $2CA9
.aef0                              lab_1c01

.aef0  a9 2c      lda #$2c         	LDA	#$2C			; load A with ","
.aef2                              lab_scca
.aef2  a0 00      ldy #$00         	LDY	#$00			; clear index
.aef4  d1 c3      cmp ($c3),y      	CMP	(Bpntrl),Y		; check next byte is = A
.aef6  d0 03      bne $aefb        	BNE	LAB_SNER		; if not do syntax error, then warm start
.aef8  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; increment & scan memory then return
.aefb                              lab_sner
.aefb  a2 02      ldx #$02         	LDX	#$02			; error code $02 ("Syntax" error)
.aefd  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.af00                              lab_1c11
.af00  a0 1e      ldy #$1e         	LDY	#(TK_GT-TK_PLUS)*3; set offset from base to > operator
.af02                              lab_1c13
.af02  68         pla              	PLA				; dump return address low byte
.af03  68         pla              	PLA				; dump return address high byte
.af04  4c 06 ae   jmp $ae06        	JMP	LAB_1B1D		; execute function then continue evaluation
.af07                              lab_1c18
.af07  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get (var) address
.af0a  85 ae      sta $ae          	STA	FAC1_2		; save address low byte in FAC1 mantissa2
.af0c  84 af      sty $af          	STY	FAC1_3		; save address high byte in FAC1 mantissa3
.af0e  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.af10  d0 03      bne $af15        	BNE	LAB_1C25		; if string then return (does RTS)
.af12                              lab_1c24
.af12  4c 44 bb   jmp $bb44        	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
.af15                              lab_1c25
.af15  60         rts              	RTS
.af16                              lab_1c27
.af16  0a         asl              	ASL	A			; *2 (2 bytes per function address)
.af17  48         pha              	PHA				; save function offset
.af18  aa         tax              	TAX				; copy function offset
.af19  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.af1c  e0 b3      cpx #$b3         	CPX	#(TK_CHRS-$80)*2+1; compare function offset to CHR$ token offset+1
.af1e  90 56      bcc $af76        	BCC	LAB_1C51		; branch if <HEX$ (can not be =)
.af20  e0 b7      cpx #$b7         	CPX	#(TK_BINS-$80)*2+1; compare function offset to BIN$ token offset+1
.af22  90 24      bcc $af48        	BCC	LAB_BHSS		; branch if <VARPTR (can not be =)
.af24  e0 c3      cpx #$c3         	CPX	#(TK_VPTR-$80)*2+1; compare function offset VARPTR token offset+1
.af26  90 51      bcc $af79        	BCC	LAB_1C54		; branch if <LEFT$ (can not be =)
.af28  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.af2b  20 ad ad   jsr $adad        	JSR	LAB_EVEX		; evaluate (should be string) expression
.af2e  20 f0 ae   jsr $aef0        	JSR	LAB_1C01		; scan for "," , else do syntax error, then warm start
.af31  20 9e ad   jsr $ad9e        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.af34  68         pla              	PLA				; restore function offset
.af35  aa         tax              	TAX				; copy it
.af36  a5 af      lda $af          	LDA	des_ph		; get descriptor pointer high byte
.af38  48         pha              	PHA				; push string pointer high byte
.af39  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.af3b  48         pha              	PHA				; push string pointer low byte
.af3c  8a         txa              	TXA				; restore function offset
.af3d  48         pha              	PHA				; save function offset
.af3e  20 50 b7   jsr $b750        	JSR	LAB_GTBY		; get byte parameter
.af41  68         pla              	PLA				; restore function offset
.af42  a8         tay              	TAY				; copy function offset
.af43  8a         txa              	TXA				; copy byte parameter to A
.af44  48         pha              	PHA				; push byte parameter
.af45  4c 7b af   jmp $af7b        	JMP	LAB_1C56		; go call function
.af48                              lab_bhss
.af48  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.af4b  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.af4e  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.af50  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.af52  b0 1f      bcs $af73        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
.af54  20 1a bc   jsr $bc1a        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.af57  a2 02      ldx #$02         	LDX	#$02			; 3 bytes to do
.af59                              lab_cfac
.af59  b5 ad      lda $ad,x        	LDA	FAC1_1,X		; get byte from FAC1
.af5b  95 11      sta $11,x        	STA	nums_1,X		; save byte to temp
.af5d  ca         dex              	DEX				; decrement index		
.af5e  10 f9      bpl $af59        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
.af60  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.af63  a2 00      ldx #$00         	LDX	#$00			; set default to no leading "0"s
.af65  c9 29      cmp #$29         	CMP	#")"			; compare with close bracket
.af67  f0 10      beq $af79        	BEQ	LAB_1C54		; if ")" go do rest of function
.af69  20 a2 b7   jsr $b7a2        	JSR	LAB_SCGB		; scan for "," and get byte
.af6c  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get last byte back
.af6f  c9 29      cmp #$29         	CMP	#")"			; is next character )
.af71  f0 06      beq $af79        	BEQ	LAB_1C54		; if ")" go do rest of function
.af73                              lab_bher
.af73  4c f9 b1   jmp $b1f9        	JMP	LAB_FCER		; do function call error, then warm start
.af76                              lab_1c51
.af76  20 e4 ae   jsr $aee4        	JSR	LAB_1BF5		; evaluate expression within parentheses
.af79                              lab_1c54
.af79  68         pla              	PLA				; restore function offset
.af7a  a8         tay              	TAY				; copy to index
.af7b                              lab_1c56
.af7b  b9 a2 c4   lda $c4a2,y      	LDA	LAB_FTBL,Y		; get function jump vector low byte
.af7e  85 a2      sta $a2          	STA	Fnxjpl		; save functions jump vector low byte
.af80  b9 a3 c4   lda $c4a3,y      	LDA	LAB_FTBM,Y		; get function jump vector high byte
.af83  85 a3      sta $a3          	STA	Fnxjph		; save functions jump vector high byte
.af85  20 a1 00   jsr $00a1        	JSR	Fnxjmp		; do function call
.af88  4c 9c ad   jmp $ad9c        	JMP	LAB_CTNM		; check if source is numeric & RTS, else do type mismatch
.af8b                              lab_eor
.af8b  20 b2 af   jsr $afb2        	JSR	GetFirst		; get first integer expression (no sign check)
.af8e  45 5b      eor $5b          	EOR	XOAw_l		; EOR with expression 1 low byte
.af90  a8         tay              	TAY				; save in Y
.af91  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.af93  45 5c      eor $5c          	EOR	XOAw_h		; EOR with expression 1 high byte
.af95  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & RET
.af98                              lab_or
.af98  20 b2 af   jsr $afb2        	JSR	GetFirst		; get first integer expression (no sign check)
.af9b  05 5b      ora $5b          	ORA	XOAw_l		; OR with expression 1 low byte
.af9d  a8         tay              	TAY				; save in Y
.af9e  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.afa0  05 5c      ora $5c          	ORA	XOAw_h		; OR with expression 1 high byte
.afa2  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & RET
.afa5                              lab_and
.afa5  20 b2 af   jsr $afb2        	JSR	GetFirst		; get first integer expression (no sign check)
.afa8  25 5b      and $5b          	AND	XOAw_l		; AND with expression 1 low byte
.afaa  a8         tay              	TAY				; save in Y
.afab  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.afad  25 5c      and $5c          	AND	XOAw_h		; AND with expression 1 high byte
.afaf  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & RET
.afb2                              getfirst
.afb2  20 76 b1   jsr $b176        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.afb5  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.afb7  85 5c      sta $5c          	STA	XOAw_h		; save it
.afb9  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.afbb  85 5b      sta $5b          	STA	XOAw_l		; save it
.afbd  20 87 b8   jsr $b887        	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.afc0  20 76 b1   jsr $b176        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.afc3  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.afc5                              lab_1c95
.afc5  60         rts              	RTS				;
.afc6                              lab_lthan
.afc6  20 9f ad   jsr $ad9f        	JSR	LAB_CKTM		; type match check, set C for string
.afc9  b0 13      bcs $afde        	BCS	LAB_1CAE		; branch if string
.afcb  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.afcd  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.afcf  25 b4      and $b4          	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
.afd1  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.afd3  a9 b3      lda #$b3         	LDA	#<FAC2_e		; set pointer low byte to FAC2
.afd5  a0 00      ldy #$00         	LDY	#>FAC2_e		; set pointer high byte to FAC2
.afd7  20 e1 bb   jsr $bbe1        	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
.afda  aa         tax              	TAX				; copy result
.afdb  4c 11 b0   jmp $b011        	JMP	LAB_1CE1		; go evaluate result
.afde                              lab_1cae
.afde  a9 00      lda #$00         	LDA	#$00			; clear byte
.afe0  85 5f      sta $5f          	STA	Dtypef		; clear data type flag, $FF=string, $00=numeric
.afe2  c6 9b      dec $9b          	DEC	comp_f		; clear < bit in compare function flag
.afe4  20 13 b6   jsr $b613        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.afe7  85 ac      sta $ac          	STA	str_ln		; save length
.afe9  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.afeb  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.afed  a5 b5      lda $b5          	LDA	FAC2_2		; get descriptor pointer low byte
.afef  a4 b6      ldy $b6          	LDY	FAC2_3		; get descriptor pointer high byte
.aff1  20 17 b6   jsr $b617        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.aff4  86 b5      stx $b5          	STX	FAC2_2		; save string pointer low byte
.aff6  84 b6      sty $b6          	STY	FAC2_3		; save string pointer high byte
.aff8  aa         tax              	TAX				; copy length
.aff9  38         sec              	SEC				; set carry for subtract
.affa  e5 ac      sbc $ac          	SBC	str_ln		;.subtract string 1 length
.affc  f0 08      beq $b006        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
.affe  a9 01      lda #$01         	LDA	#$01			; set str 1 length > string 2 length
.b000  90 04      bcc $b006        	BCC	LAB_1CD6		; branch if so
.b002  a6 ac      ldx $ac          	LDX	str_ln		; get string 1 length
.b004  a9 ff      lda #$ff         	LDA	#$FF			; set str 1 length < string 2 length
.b006                              lab_1cd6
.b006  85 b0      sta $b0          	STA	FAC1_s		; save length compare
.b008  a0 ff      ldy #$ff         	LDY	#$FF			; set index
.b00a  e8         inx              	INX				; adjust for loop
.b00b                              lab_1cdb
.b00b  c8         iny              	INY				; increment index
.b00c  ca         dex              	DEX				; decrement count
.b00d  d0 07      bne $b016        	BNE	LAB_1CE6		; branch if still bytes to do
.b00f  a6 b0      ldx $b0          	LDX	FAC1_s		; get length compare back
.b011                              lab_1ce1
.b011  30 0f      bmi $b022        	BMI	LAB_1CF2		; branch if str 1 < str 2
.b013  18         clc              	CLC				; flag str 1 <= str 2
.b014  90 0c      bcc $b022        	BCC	LAB_1CF2		; go evaluate result
.b016                              lab_1ce6
.b016  b1 b5      lda ($b5),y      	LDA	(FAC2_2),Y		; get string 2 byte
.b018  d1 ad      cmp ($ad),y      	CMP	(FAC1_1),Y		; compare with string 1 byte
.b01a  f0 ef      beq $b00b        	BEQ	LAB_1CDB		; loop if bytes =
.b01c  a2 ff      ldx #$ff         	LDX	#$FF			; set str 1 < string 2
.b01e  b0 02      bcs $b022        	BCS	LAB_1CF2		; branch if so
.b020  a2 01      ldx #$01         	LDX	#$01			;  set str 1 > string 2
.b022                              lab_1cf2
.b022  e8         inx              	INX				; x = 0, 1 or 2
.b023  8a         txa              	TXA				; copy to A
.b024  2a         rol              	ROL	A			; *2 (1, 2 or 4)
.b025  25 63      and $63          	AND	Cflag			; AND with comparison evaluation flag
.b027  f0 02      beq $b02b        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
.b029  a9 ff      lda #$ff         	LDA	#$FF			; else set result true
.b02b                              lab_1cfb
.b02b  4c c4 bb   jmp $bbc4        	JMP	LAB_27DB		; save A as integer byte & return
.b02e                              lab_1cfe
.b02e  20 f0 ae   jsr $aef0        	JSR	LAB_1C01		; scan for "," , else do syntax error, then warm start
.b031                              lab_dim
.b031  aa         tax              	TAX				; copy "DIM" flag to X
.b032  20 81 b0   jsr $b081        	JSR	LAB_1D10		; search for variable
.b035  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.b038  d0 f4      bne $b02e        	BNE	LAB_1CFE		; scan for "," and loop if not null
.b03a  60         rts              	RTS				;
.b03b                              lab_lshift
.b03b  20 71 b0   jsr $b071        	JSR	GetPair		; get integer expression & byte (no sign check)
.b03e  a5 ae      lda $ae          	LDA	FAC1_2		; get expression high byte
.b040  a6 78      ldx $78          	LDX	TempB			; get shift count
.b042  f0 22      beq $b066        	BEQ	NoShift		; branch if zero
.b044  e0 10      cpx #$10         	CPX	#$10			; compare bit count with 16d
.b046  b0 23      bcs $b06b        	BCS	TooBig		; branch if >=
.b048                              ls_loop
.b048  06 af      asl $af          	ASL	FAC1_3		; shift low byte
.b04a  2a         rol              	ROL				; shift high byte
.b04b  ca         dex              	DEX				; decrement bit count
.b04c  d0 fa      bne $b048        	BNE	Ls_loop		; loop if shift not complete
.b04e  a4 af      ldy $af          	LDY	FAC1_3		; get expression low byte
.b050  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & RET
.b053                              lab_rshift
.b053  20 71 b0   jsr $b071        	JSR	GetPair		; get integer expression & byte (no sign check)
.b056  a5 ae      lda $ae          	LDA	FAC1_2		; get expression high byte
.b058  a6 78      ldx $78          	LDX	TempB			; get shift count
.b05a  f0 0a      beq $b066        	BEQ	NoShift		; branch if zero
.b05c  e0 10      cpx #$10         	CPX	#$10			; compare bit count with 16d
.b05e  b0 0b      bcs $b06b        	BCS	TooBig		; branch if >=
.b060                              rs_loop
.b060  4a         lsr              	LSR				; shift high byte
.b061  66 af      ror $af          	ROR	FAC1_3		; shift low byte
.b063  ca         dex              	DEX				; decrement bit count
.b064  d0 fa      bne $b060        	BNE	Rs_loop		; loop if shift not complete
.b066                              noshift
.b066  a4 af      ldy $af          	LDY	FAC1_3		; get expression low byte
.b068  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & RET
.b06b                              toobig
.b06b  a9 00      lda #$00         	LDA	#$00			; clear high byte
.b06d  a8         tay              	TAY				; copy to low byte
.b06e  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & RET
.b071                              getpair
.b071  20 53 b7   jsr $b753        	JSR	LAB_EVBY		; evaluate byte expression, result in X
.b074  86 78      stx $78          	STX	TempB			; save it
.b076  20 87 b8   jsr $b887        	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.b079  4c 76 b1   jmp $b176        	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
.b07c                              lab_gvar
.b07c  a2 00      ldx #$00         	LDX	#$00			; set DIM flag = $00
.b07e  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory (1st character)
.b081                              lab_1d10
.b081  86 5e      stx $5e          	STX	Defdim		; save DIM flag
.b083                              lab_1d12
.b083  85 93      sta $93          	STA	Varnm1		; save 1st character
.b085  20 ee b0   jsr $b0ee        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.b088  b0 03      bcs $b08d        	BCS	LAB_1D1F		; branch if ok
.b08a  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; else syntax error, then warm start
.b08d                              lab_1d1f
.b08d  a2 00      ldx #$00         	LDX	#$00			; clear 2nd character temp
.b08f  86 5f      stx $5f          	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
.b091  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory (2nd character)
.b094  90 05      bcc $b09b        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
.b096  20 ee b0   jsr $b0ee        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.b099  90 0b      bcc $b0a6        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
.b09b                              lab_1d2d
.b09b  aa         tax              	TAX				; copy 2nd character
.b09c                              lab_1d2e
.b09c  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory (3rd character)
.b09f  90 fb      bcc $b09c        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
.b0a1  20 ee b0   jsr $b0ee        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.b0a4  b0 f6      bcs $b09c        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
.b0a6                              lab_1d38
.b0a6  c9 24      cmp #$24         	CMP	#$24			; compare with "$"
.b0a8  d0 0b      bne $b0b5        	BNE	LAB_1D47		; branch if not string
.b0aa  a9 ff      lda #$ff         	LDA	#$FF			; set data type = string
.b0ac  85 5f      sta $5f          	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
.b0ae  8a         txa              	TXA				; get 2nd character back
.b0af  09 80      ora #$80         	ORA	#$80			; set top bit (indicate string var)
.b0b1  aa         tax              	TAX				; copy back to 2nd character temp
.b0b2  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.b0b5                              lab_1d47
.b0b5  86 94      stx $94          	STX	Varnm2		; save 2nd character
.b0b7  05 61      ora $61          	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
.b0b9  c9 28      cmp #$28         	CMP	#$28			; compare with "("
.b0bb  d0 03      bne $b0c0        	BNE	LAB_1D53		; branch if not "("
.b0bd  4c 88 b1   jmp $b188        	JMP	LAB_1E17		; go find, or make, array
.b0c0                              lab_1d53
.b0c0  a9 00      lda #$00         	LDA	#$00			; clear A
.b0c2  85 61      sta $61          	STA	Sufnxf		; clear subscript/FNX flag
.b0c4  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.b0c6  a6 7c      ldx $7c          	LDX	Svarh			; get start of vars high byte
.b0c8  a0 00      ldy #$00         	LDY	#$00			; clear index
.b0ca                              lab_1d5d
.b0ca  86 ab      stx $ab          	STX	Vrschh		; save search address high byte
.b0cc                              lab_1d5f
.b0cc  85 aa      sta $aa          	STA	Vrschl		; save search address low byte
.b0ce  e4 7e      cpx $7e          	CPX	Sarryh		; compare high address with var space end
.b0d0  d0 04      bne $b0d6        	BNE	LAB_1D69		; skip next compare if <>
.b0d2  c5 7d      cmp $7d          	CMP	Sarryl		; compare low address with var space end
.b0d4  f0 2c      beq $b102        	BEQ	LAB_1D8B		; if not found go make new var
.b0d6                              lab_1d69
.b0d6  a5 93      lda $93          	LDA	Varnm1		; get 1st character of var to find
.b0d8  d1 aa      cmp ($aa),y      	CMP	(Vrschl),Y		; compare with variable name 1st character
.b0da  d0 08      bne $b0e4        	BNE	LAB_1D77		; branch if no match
.b0dc  a5 94      lda $94          	LDA	Varnm2		; get 2nd character of var to find
.b0de  c8         iny              	INY				; index to point to variable name 2nd character
.b0df  d1 aa      cmp ($aa),y      	CMP	(Vrschl),Y		; compare with variable name 2nd character
.b0e1  f0 69      beq $b14c        	BEQ	LAB_1DD7		; branch if match (found var)
.b0e3  88         dey              	DEY				; else decrement index (now = $00)
.b0e4                              lab_1d77
.b0e4  18         clc              	CLC				; clear carry for add
.b0e5  a5 aa      lda $aa          	LDA	Vrschl		; get search address low byte
.b0e7  69 06      adc #$06         	ADC	#$06			; +6 (offset to next var name)
.b0e9  90 e1      bcc $b0cc        	BCC	LAB_1D5F		; loop if no overflow to high byte
.b0eb  e8         inx              	INX				; else increment high byte
.b0ec  d0 dc      bne $b0ca        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
.b0ee                              lab_casc
.b0ee  c9 61      cmp #$61         	CMP	#$61			; compare with "a"
.b0f0  b0 0a      bcs $b0fc        	BCS	LAB_1D83		; go check <"z"+1
.b0f2                              lab_1d82
.b0f2  c9 41      cmp #$41         	CMP	#$41			; compare with "A"
.b0f4  90 05      bcc $b0fb        	BCC	LAB_1D8A		; exit if less
.b0f6  e9 5b      sbc #$5b         	SBC	#$5B			; subtract "Z"+1
.b0f8  38         sec              	SEC				; set carry
.b0f9  e9 a5      sbc #$a5         	SBC	#$A5			; subtract $A5 (restore byte)
.b0fb                              lab_1d8a
.b0fb  60         rts              	RTS				;
.b0fc                              lab_1d83
.b0fc  e9 7b      sbc #$7b         	SBC	#$7B			; subtract "z"+1
.b0fe  38         sec              	SEC				; set carry
.b0ff  e9 85      sbc #$85         	SBC	#$85			; subtract $A5 (restore byte)
.b101  60         rts              	RTS				;
.b102                              lab_1d8b
.b102  68         pla              	PLA				; pop return address low byte
.b103  48         pha              	PHA				; push return address low byte
.b104  c9 09      cmp #$09         	CMP	#<LAB_1C18+2	; compare with expected calling routine return low byte
.b106  d0 05      bne $b10d        	BNE	LAB_1D98		; if not get (var) go create new var
.b108  a9 aa      lda #$aa         	LDA	#<LAB_1D96		; low byte point to $00,$00
.b10a  a0 c4      ldy #$c4         	LDY	#>LAB_1D96		; high byte point to $00,$00
.b10c  60         rts              	RTS				;
.b10d                              lab_1d98
.b10d  a5 7d      lda $7d          	LDA	Sarryl		; get var mem end low byte
.b10f  a4 7e      ldy $7e          	LDY	Sarryh		; get var mem end high byte
.b111  85 aa      sta $aa          	STA	Ostrtl		; save old block start low byte
.b113  84 ab      sty $ab          	STY	Ostrth		; save old block start high byte
.b115  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.b117  a4 80      ldy $80          	LDY	Earryh		; get array mem end high byte
.b119  85 a6      sta $a6          	STA	Obendl		; save old block end low byte
.b11b  84 a7      sty $a7          	STY	Obendh		; save old block end high byte
.b11d  18         clc              	CLC				; clear carry for add
.b11e  69 06      adc #$06         	ADC	#$06			; +6 (space for one var)
.b120  90 01      bcc $b123        	BCC	LAB_1DAE		; branch if no overflow to high byte
.b122  c8         iny              	INY				; else increment high byte
.b123                              lab_1dae
.b123  85 a4      sta $a4          	STA	Nbendl		; set new block end low byte
.b125  84 a5      sty $a5          	STY	Nbendh		; set new block end high byte
.b127  20 c4 a3   jsr $a3c4        	JSR	LAB_11CF		; open up space in memory
.b12a  a5 a4      lda $a4          	LDA	Nbendl		; get new start low byte
.b12c  a4 a5      ldy $a5          	LDY	Nbendh		; get new start high byte (-$100)
.b12e  c8         iny              	INY				; correct high byte
.b12f  85 7d      sta $7d          	STA	Sarryl		; save new var mem end low byte
.b131  84 7e      sty $7e          	STY	Sarryh		; save new var mem end high byte
.b133  a0 00      ldy #$00         	LDY	#$00			; clear index
.b135  a5 93      lda $93          	LDA	Varnm1		; get var name 1st character
.b137  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; save var name 1st character
.b139  c8         iny              	INY				; increment index
.b13a  a5 94      lda $94          	LDA	Varnm2		; get var name 2nd character
.b13c  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; save var name 2nd character
.b13e  a9 00      lda #$00         	LDA	#$00			; clear A
.b140  c8         iny              	INY				; increment index
.b141  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.b143  c8         iny              	INY				; increment index
.b144  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.b146  c8         iny              	INY				; increment index
.b147  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.b149  c8         iny              	INY				; increment index
.b14a  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.b14c                              lab_1dd7
.b14c  a5 aa      lda $aa          	LDA	Vrschl		; get var address low byte
.b14e  18         clc              	CLC				; clear carry for add
.b14f  69 02      adc #$02         	ADC	#$02			; +2 (offset past var name bytes)
.b151  a4 ab      ldy $ab          	LDY	Vrschh		; get var address high byte
.b153  90 01      bcc $b156        	BCC	LAB_1DE1		; branch if no overflow from add
.b155  c8         iny              	INY				; else increment high byte
.b156                              lab_1de1
.b156  85 95      sta $95          	STA	Cvaral		; save current var address low byte
.b158  84 96      sty $96          	STY	Cvarah		; save current var address high byte
.b15a  60         rts              	RTS				;
.b15b                              lab_1de6
.b15b  a5 5d      lda $5d          	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
.b15d  0a         asl              	ASL	A			; *2 (also clears the carry !)
.b15e  69 05      adc #$05         	ADC	#$05			; +5 (result is 7, 9 or 11 here)
.b160  65 aa      adc $aa          	ADC	Astrtl		; add array start pointer low byte
.b162  a4 ab      ldy $ab          	LDY	Astrth		; get array pointer high byte
.b164  90 01      bcc $b167        	BCC	LAB_1DF2		; branch if no overflow
.b166  c8         iny              	INY				; else increment high byte
.b167                              lab_1df2
.b167  85 a4      sta $a4          	STA	Adatal		; save array data pointer low byte
.b169  84 a5      sty $a5          	STY	Adatah		; save array data pointer high byte
.b16b  60         rts              	RTS				;
.b16c                              lab_evin
.b16c  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.b16f  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.b172                              lab_evpi
.b172  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.b174  30 0d      bmi $b183        	BMI	LAB_1E12		; do function call error if -ve
.b176                              lab_evir
.b176  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.b178  c9 90      cmp #$90         	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
.b17a  90 09      bcc $b185        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
.b17c  a9 b1      lda #$b1         	LDA	#<LAB_1DF7		; set pointer low byte to -32768
.b17e  a0 c4      ldy #$c4         	LDY	#>LAB_1DF7		; set pointer high byte to -32768
.b180  20 e1 bb   jsr $bbe1        	JSR	LAB_27F8		; compare FAC1 with (AY)
.b183                              lab_1e12
.b183  d0 74      bne $b1f9        	BNE	LAB_FCER		; if <> do function call error, then warm start
.b185                              lab_1e14
.b185  4c 1a bc   jmp $bc1a        	JMP	LAB_2831		; convert FAC1 floating-to-fixed & RET
.b188                              lab_1e17
.b188  a5 5e      lda $5e          	LDA	Defdim		; get DIM flag
.b18a  48         pha              	PHA				; push it
.b18b  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.b18d  48         pha              	PHA				; push it
.b18e  a0 00      ldy #$00         	LDY	#$00			; clear dimensions count
.b190                              lab_1e1f
.b190  98         tya              	TYA				; copy dimensions count
.b191  48         pha              	PHA				; save it
.b192  a5 94      lda $94          	LDA	Varnm2		; get array name 2nd byte
.b194  48         pha              	PHA				; save it
.b195  a5 93      lda $93          	LDA	Varnm1		; get array name 1st byte
.b197  48         pha              	PHA				; save it
.b198  20 6c b1   jsr $b16c        	JSR	LAB_EVIN		; evaluate integer expression
.b19b  68         pla              	PLA				; pull array name 1st byte
.b19c  85 93      sta $93          	STA	Varnm1		; restore array name 1st byte
.b19e  68         pla              	PLA				; pull array name 2nd byte
.b19f  85 94      sta $94          	STA	Varnm2		; restore array name 2nd byte
.b1a1  68         pla              	PLA				; pull dimensions count
.b1a2  a8         tay              	TAY				; restore it
.b1a3  ba         tsx              	TSX				; copy stack pointer
.b1a4  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get DIM flag
.b1a7  48         pha              	PHA				; push it
.b1a8  bd 01 01   lda $0101,x      	LDA	LAB_STAK+1,X	; get data type flag
.b1ab  48         pha              	PHA				; push it
.b1ac  a5 ae      lda $ae          	LDA	FAC1_2		; get this dimension size high byte
.b1ae  9d 02 01   sta $0102,x      	STA	LAB_STAK+2,X	; stack before flag bytes
.b1b1  a5 af      lda $af          	LDA	FAC1_3		; get this dimension size low byte
.b1b3  9d 01 01   sta $0101,x      	STA	LAB_STAK+1,X	; stack before flag bytes
.b1b6  c8         iny              	INY				; increment dimensions count
.b1b7  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.b1ba  c9 2c      cmp #$2c         	CMP	#$2C			; compare with ","
.b1bc  f0 d2      beq $b190        	BEQ	LAB_1E1F		; if found go do next dimension
.b1be  84 5d      sty $5d          	STY	Dimcnt		; store dimensions count
.b1c0  20 ea ae   jsr $aeea        	JSR	LAB_1BFB		; scan for ")" , else do syntax error, then warm start
.b1c3  68         pla              	PLA				; pull data type flag
.b1c4  85 5f      sta $5f          	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
.b1c6  68         pla              	PLA				; pull DIM flag
.b1c7  85 5e      sta $5e          	STA	Defdim		; restore DIM flag
.b1c9  a6 7d      ldx $7d          	LDX	Sarryl		; get array mem start low byte
.b1cb  a5 7e      lda $7e          	LDA	Sarryh		; get array mem start high byte
.b1cd                              lab_1e5c
.b1cd  86 aa      stx $aa          	STX	Astrtl		; save as array start pointer low byte
.b1cf  85 ab      sta $ab          	STA	Astrth		; save as array start pointer high byte
.b1d1  c5 80      cmp $80          	CMP	Earryh		; compare with array mem end high byte
.b1d3  d0 04      bne $b1d9        	BNE	LAB_1E68		; branch if not reached array mem end
.b1d5  e4 7f      cpx $7f          	CPX	Earryl		; else compare with array mem end low byte
.b1d7  f0 39      beq $b212        	BEQ	LAB_1EA1		; go build array if not found
.b1d9                              lab_1e68
.b1d9  a0 00      ldy #$00         	LDY	#$00			; clear index
.b1db  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array name first byte
.b1dd  c8         iny              	INY				; increment index to second name byte
.b1de  c5 93      cmp $93          	CMP	Varnm1		; compare with this array name first byte
.b1e0  d0 06      bne $b1e8        	BNE	LAB_1E77		; branch if no match
.b1e2  a5 94      lda $94          	LDA	Varnm2		; else get this array name second byte
.b1e4  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array name second byte
.b1e6  f0 16      beq $b1fe        	BEQ	LAB_1E8D		; array found so branch
.b1e8                              lab_1e77
.b1e8  c8         iny              	INY				; increment index
.b1e9  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array size low byte
.b1eb  18         clc              	CLC				; clear carry for add
.b1ec  65 aa      adc $aa          	ADC	Astrtl		; add array start pointer low byte
.b1ee  aa         tax              	TAX				; copy low byte to X
.b1ef  c8         iny              	INY				; increment index
.b1f0  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array size high byte
.b1f2  65 ab      adc $ab          	ADC	Astrth		; add array mem pointer high byte
.b1f4  90 d7      bcc $b1cd        	BCC	LAB_1E5C		; if no overflow go check next array
.b1f6                              lab_1e85
.b1f6  a2 10      ldx #$10         	LDX	#$10			; error code $10 ("Array bounds" error)

>b1f8  2c                          	.byte	$2C			; makes next bit BIT LAB_08A2
.b1f9                              lab_fcer

.b1f9  a2 08      ldx #$08         	LDX	#$08			; error code $08 ("Function call" error)
.b1fb                              lab_1e8a
.b1fb  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.b1fe                              lab_1e8d
.b1fe  a2 12      ldx #$12         	LDX	#$12			; set error $12 ("Double dimension" error)
.b200  a5 5e      lda $5e          	LDA	Defdim		; get DIM flag
.b202  d0 f7      bne $b1fb        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
.b204  20 5b b1   jsr $b15b        	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.b207  a5 5d      lda $5d          	LDA	Dimcnt		; get dimensions count
.b209  a0 04      ldy #$04         	LDY	#$04			; set index to array's # of dimensions
.b20b  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with no of dimensions
.b20d  d0 e7      bne $b1f6        	BNE	LAB_1E85		; if wrong do array bounds error (could do "Wrong dimensions"
.b20f  4c 95 b2   jmp $b295        	JMP	LAB_1F28		; found array so go get element
.b212                              lab_1ea1
.b212  20 5b b1   jsr $b15b        	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.b215  20 0f a4   jsr $a40f        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.b218  a0 00      ldy #$00         	LDY	#$00			; clear Y (don't need to clear A)
.b21a  84 bb      sty $bb          	STY	Aspth			; clear array data size high byte
.b21c  a5 93      lda $93          	LDA	Varnm1		; get variable name 1st byte
.b21e  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array name 1st byte
.b220  c8         iny              	INY				; increment index
.b221  a5 94      lda $94          	LDA	Varnm2		; get variable name 2nd byte
.b223  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array name 2nd byte
.b225  a5 5d      lda $5d          	LDA	Dimcnt		; get dimensions count
.b227  a0 04      ldy #$04         	LDY	#$04			; index to dimension count
.b229  84 ba      sty $ba          	STY	Asptl			; set array data size low byte (four bytes per element)
.b22b  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; set array's dimensions count
.b22d  18         clc              	CLC				; clear carry for add (clear on subsequent loops)
.b22e                              lab_1ec0
.b22e  a2 0b      ldx #$0b         	LDX	#$0B			; set default dimension value low byte
.b230  a9 00      lda #$00         	LDA	#$00			; set default dimension value high byte
.b232  24 5e      bit $5e          	BIT	Defdim		; test default DIM flag
.b234  50 07      bvc $b23d        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
.b236  68         pla              	PLA				; else pull dimension value low byte
.b237  69 01      adc #$01         	ADC	#$01			; +1 (allow for zeroeth element)
.b239  aa         tax              	TAX				; copy low byte to X
.b23a  68         pla              	PLA				; pull dimension value high byte
.b23b  69 00      adc #$00         	ADC	#$00			; add carry from low byte
.b23d                              lab_1ed0
.b23d  c8         iny              	INY				; index to dimension value high byte
.b23e  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save dimension value high byte
.b240  c8         iny              	INY				; index to dimension value high byte
.b241  8a         txa              	TXA				; get dimension value low byte
.b242  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save dimension value low byte
.b244  20 e4 b2   jsr $b2e4        	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.b247  86 ba      stx $ba          	STX	Asptl			; save array data size low byte
.b249  85 bb      sta $bb          	STA	Aspth			; save array data size high byte
.b24b  a4 71      ldy $71          	LDY	ut1_pl		; restore index (saved by subroutine)
.b24d  c6 5d      dec $5d          	DEC	Dimcnt		; decrement dimensions count
.b24f  d0 dd      bne $b22e        	BNE	LAB_1EC0		; loop while not = 0
.b251  65 a5      adc $a5          	ADC	Adatah		; add size high byte to first element high byte
.b253  b0 5d      bcs $b2b2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.b255  85 a5      sta $a5          	STA	Adatah		; save end of array high byte
.b257  a8         tay              	TAY				; copy end high byte to Y
.b258  8a         txa              	TXA				; get array size low byte
.b259  65 a4      adc $a4          	ADC	Adatal		; add array start low byte
.b25b  90 03      bcc $b260        	BCC	LAB_1EF3		; branch if no carry
.b25d  c8         iny              	INY				; else increment end of array high byte
.b25e  f0 52      beq $b2b2        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
.b260                              lab_1ef3
.b260  20 0f a4   jsr $a40f        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.b263  85 7f      sta $7f          	STA	Earryl		; save array mem end low byte
.b265  84 80      sty $80          	STY	Earryh		; save array mem end high byte
.b267  a9 00      lda #$00         	LDA	#$00			; clear byte for array clear
.b269  e6 bb      inc $bb          	INC	Aspth			; increment array size high byte (now block count)
.b26b  a4 ba      ldy $ba          	LDY	Asptl			; get array size low byte (now index to block)
.b26d  f0 05      beq $b274        	BEQ	LAB_1F07		; branch if low byte = $00
.b26f                              lab_1f02
.b26f  88         dey              	DEY				; decrement index (do 0 to n-1)
.b270  91 a4      sta ($a4),y      	STA	(Adatal),Y		; zero byte
.b272  d0 fb      bne $b26f        	BNE	LAB_1F02		; loop until this block done
.b274                              lab_1f07
.b274  c6 a5      dec $a5          	DEC	Adatah		; decrement array pointer high byte
.b276  c6 bb      dec $bb          	DEC	Aspth			; decrement block count high byte
.b278  d0 f5      bne $b26f        	BNE	LAB_1F02		; loop until all blocks done
.b27a  e6 a5      inc $a5          	INC	Adatah		; correct for last loop
.b27c  38         sec              	SEC				; set carry for subtract
.b27d  a0 02      ldy #$02         	LDY	#$02			; index to array size low byte
.b27f  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.b281  e5 aa      sbc $aa          	SBC	Astrtl		; subtract array start low byte
.b283  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array size low byte
.b285  c8         iny              	INY				; index to array size high byte
.b286  a5 80      lda $80          	LDA	Earryh		; get array mem end high byte
.b288  e5 ab      sbc $ab          	SBC	Astrth		; subtract array start high byte
.b28a  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array size high byte
.b28c  a5 5e      lda $5e          	LDA	Defdim		; get default DIM flag
.b28e  d0 53      bne $b2e3        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
.b290  c8         iny              	INY				; index to # of dimensions
.b291                              lab_1f24
.b291  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array's dimension count
.b293  85 5d      sta $5d          	STA	Dimcnt		; save it
.b295                              lab_1f28
.b295  a9 00      lda #$00         	LDA	#$00			; clear byte
.b297  85 ba      sta $ba          	STA	Asptl			; clear array data pointer low byte
.b299                              lab_1f2c
.b299  85 bb      sta $bb          	STA	Aspth			; save array data pointer high byte
.b29b  c8         iny              	INY				; increment index (point to array bound high byte)
.b29c  68         pla              	PLA				; pull array index low byte
.b29d  aa         tax              	TAX				; copy to X
.b29e  85 ae      sta $ae          	STA	FAC1_2		; save index low byte to FAC1 mantissa2
.b2a0  68         pla              	PLA				; pull array index high byte
.b2a1  85 af      sta $af          	STA	FAC1_3		; save index high byte to FAC1 mantissa3
.b2a3  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array bound high byte
.b2a5  90 0e      bcc $b2b5        	BCC	LAB_1F48		; branch if within bounds
.b2a7  d0 06      bne $b2af        	BNE	LAB_1F42		; if outside bounds do array bounds error
.b2a9  c8         iny              	INY				; index to array bound low byte
.b2aa  8a         txa              	TXA				; get array index low byte
.b2ab  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array bound low byte
.b2ad  90 07      bcc $b2b6        	BCC	LAB_1F49		; branch if within bounds
.b2af                              lab_1f42
.b2af  4c f6 b1   jmp $b1f6        	JMP	LAB_1E85		; else do array bounds error
.b2b2                              lab_1f45
.b2b2  4c 3c a4   jmp $a43c        	JMP	LAB_OMER		; do "Out of memory" error, then warm start
.b2b5                              lab_1f48
.b2b5  c8         iny              	INY				; index to array bound low byte
.b2b6                              lab_1f49
.b2b6  a5 bb      lda $bb          	LDA	Aspth			; get array data pointer high byte
.b2b8  05 ba      ora $ba          	ORA	Asptl			; OR with array data pointer low byte
.b2ba  f0 0a      beq $b2c6        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
.b2bc  20 e4 b2   jsr $b2e4        	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.b2bf  8a         txa              	TXA				; get result low byte
.b2c0  65 ae      adc $ae          	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
.b2c2  aa         tax              	TAX				; save result low byte
.b2c3  98         tya              	TYA				; get result high byte
.b2c4  a4 71      ldy $71          	LDY	ut1_pl		; restore index
.b2c6                              lab_1f5a
.b2c6  65 af      adc $af          	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
.b2c8  86 ba      stx $ba          	STX	Asptl			; save array data pointer low byte
.b2ca  c6 5d      dec $5d          	DEC	Dimcnt		; decrement dimensions count
.b2cc  d0 cb      bne $b299        	BNE	LAB_1F2C		; loop if dimensions still to do
.b2ce  06 ba      asl $ba          	ASL	Asptl			; array data pointer low byte * 2
.b2d0  2a         rol              	ROL	A			; array data pointer high byte * 2
.b2d1  06 ba      asl $ba          	ASL	Asptl			; array data pointer low byte * 4
.b2d3  2a         rol              	ROL	A			; array data pointer high byte * 4
.b2d4  a8         tay              	TAY				; copy high byte
.b2d5  a5 ba      lda $ba          	LDA	Asptl			; get low byte
.b2d7  65 a4      adc $a4          	ADC	Adatal		; add array data start pointer low byte
.b2d9  85 95      sta $95          	STA	Cvaral		; save as current var address low byte
.b2db  98         tya              	TYA				; get high byte back
.b2dc  65 a5      adc $a5          	ADC	Adatah		; add array data start pointer high byte
.b2de  85 96      sta $96          	STA	Cvarah		; save as current var address high byte
.b2e0  a8         tay              	TAY				; copy high byte to Y
.b2e1  a5 95      lda $95          	LDA	Cvaral		; get current var address low byte
.b2e3                              lab_1f7b
.b2e3  60         rts              	RTS				;
.b2e4                              lab_1f7c
.b2e4  84 71      sty $71          	STY	ut1_pl		; save index
.b2e6  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get dimension size low byte
.b2e8  85 76      sta $76          	STA	dims_l		; save dimension size low byte
.b2ea  88         dey              	DEY				; decrement index
.b2eb  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get dimension size high byte
.b2ed  85 77      sta $77          	STA	dims_h		; save dimension size high byte
.b2ef  a9 10      lda #$10         	LDA	#$10			; count = $10 (16 bit multiply)
.b2f1  85 a8      sta $a8          	STA	numbit		; save bit count
.b2f3  a2 00      ldx #$00         	LDX	#$00			; clear result low byte
.b2f5  a0 00      ldy #$00         	LDY	#$00			; clear result high byte
.b2f7                              lab_1f8f
.b2f7  8a         txa              	TXA				; get result low byte
.b2f8  0a         asl              	ASL	A			; *2
.b2f9  aa         tax              	TAX				; save result low byte
.b2fa  98         tya              	TYA				; get result high byte
.b2fb  2a         rol              	ROL	A			; *2
.b2fc  a8         tay              	TAY				; save result high byte
.b2fd  b0 b3      bcs $b2b2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.b2ff  06 ba      asl $ba          	ASL	Asptl			; shift multiplier low byte
.b301  26 bb      rol $bb          	ROL	Aspth			; shift multiplier high byte
.b303  90 0b      bcc $b310        	BCC	LAB_1FA8		; skip add if no carry
.b305  18         clc              	CLC				; else clear carry for add
.b306  8a         txa              	TXA				; get result low byte
.b307  65 76      adc $76          	ADC	dims_l		; add dimension size low byte
.b309  aa         tax              	TAX				; save result low byte
.b30a  98         tya              	TYA				; get result high byte
.b30b  65 77      adc $77          	ADC	dims_h		; add dimension size high byte
.b30d  a8         tay              	TAY				; save result high byte
.b30e  b0 a2      bcs $b2b2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.b310                              lab_1fa8
.b310  c6 a8      dec $a8          	DEC	numbit		; decrement bit count
.b312  d0 e3      bne $b2f7        	BNE	LAB_1F8F		; loop until all done
.b314  60         rts              	RTS				;
.b315                              lab_fre
.b315  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.b317  f0 03      beq $b31c        	BEQ	LAB_1FB4		; branch if numeric
.b319  20 13 b6   jsr $b613        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.b31c                              lab_1fb4
.b31c  20 b4 b4   jsr $b4b4        	JSR	LAB_GARB		; go do garbage collection
.b31f  38         sec              	SEC				; set carry for subtract
.b320  a5 81      lda $81          	LDA	Sstorl		; get bottom of string space low byte
.b322  e5 7f      sbc $7f          	SBC	Earryl		; subtract array mem end low byte
.b324  a8         tay              	TAY				; copy result to Y
.b325  a5 82      lda $82          	LDA	Sstorh		; get bottom of string space high byte
.b327  e5 80      sbc $80          	SBC	Earryh		; subtract array mem end high byte
.b329                              lab_ayfc
.b329  a2 00      ldx #$00         	LDX	#$00			; set type = numeric
.b32b  86 5f      stx $5f          	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
.b32d  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.b32f  84 ae      sty $ae          	STY	FAC1_2		; save FAC1 mantissa2
.b331  a2 90      ldx #$90         	LDX	#$90			; set exponent=2^16 (integer)
.b333  4c cc bb   jmp $bbcc        	JMP	LAB_27E3		; set exp=X, clearFAC1_3, normalise & RET
.b336                              lab_pos
.b336  a4 0e      ldy $0e          	LDY	TPos			; get terminal position
.b338                              lab_1fd0
.b338  a9 00      lda #$00         	LDA	#$00			; clear high byte
.b33a  f0 ed      beq $b329        	BEQ	LAB_AYFC		; always save & convert integer AY to FAC1 & RET
.b33c                              lab_ckrn
.b33c  a6 88      ldx $88          	LDX	Clineh		; get current line high byte
.b33e  e8         inx              	INX				; increment it
.b33f  d0 a2      bne $b2e3        	BNE	LAB_1F7B		; return if can continue not direct mode
.b341                              lab_1fd9
.b341  a2 16      ldx #$16         	LDX	#$16			; error code $16 ("Illegal direct" error)
.b343                              lab_1fdb
.b343  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; go do error #X, then warm start
.b346                              lab_def
.b346  20 73 b3   jsr $b373        	JSR	LAB_200B		; check FNx syntax
.b349  20 3c b3   jsr $b33c        	JSR	LAB_CKRN		; check not Direct (back here if ok)
.b34c  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.b34f  a9 80      lda #$80         	LDA	#$80			; set flag for FNx
.b351  85 61      sta $61          	STA	Sufnxf		; save subscript/FNx flag
.b353  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get (var) address
.b356  20 9c ad   jsr $ad9c        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.b359  20 ea ae   jsr $aeea        	JSR	LAB_1BFB		; scan for ")" , else do syntax error, then warm start
.b35c  a9 c0      lda #$c0         	LDA	#TK_EQUAL		; get = token
.b35e  20 f2 ae   jsr $aef2        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error, then warm start
.b361  a5 96      lda $96          	LDA	Cvarah		; get current var address high byte
.b363  48         pha              	PHA				; push it
.b364  a5 95      lda $95          	LDA	Cvaral		; get current var address low byte
.b366  48         pha              	PHA				; push it
.b367  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.b369  48         pha              	PHA				; push it
.b36a  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.b36c  48         pha              	PHA				; push it
.b36d  20 98 a9   jsr $a998        	JSR	LAB_DATA		; go perform DATA
.b370  4c e5 b3   jmp $b3e5        	JMP	LAB_207A		; put execute pointer and variable pointer into function
.b373                              lab_200b
.b373  a9 ad      lda #$ad         	LDA	#TK_FN		; get FN" token
.b375  20 f2 ae   jsr $aef2        	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error, then warm start
.b378  09 80      ora #$80         	ORA	#$80			; set FN flag bit
.b37a  85 61      sta $61          	STA	Sufnxf		; save FN name
.b37c  29 7f      and #$7f         	AND	#$7F			; clear FN flag bit
.b37e  20 83 b0   jsr $b083        	JSR	LAB_1D12		; search for FN variable
.b381  85 9c      sta $9c          	STA	func_l		; save function pointer low byte
.b383  84 9d      sty $9d          	STY	func_h		; save function pointer high byte
.b385  4c 9c ad   jmp $ad9c        	JMP	LAB_CTNM		; check if source is numeric & return, else do type mismatch
.b388                              lab_201e
.b388  20 73 b3   jsr $b373        	JSR	LAB_200B		; check FNx syntax
.b38b  a5 9d      lda $9d          	LDA	func_h		; get function pointer high byte
.b38d  48         pha              	PHA				; push it
.b38e  a5 9c      lda $9c          	LDA	func_l		; get function pointer low byte
.b390  48         pha              	PHA				; push it
.b391  20 e4 ae   jsr $aee4        	JSR	LAB_1BF5		; evaluate expression within parentheses
.b394  20 9c ad   jsr $ad9c        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.b397  68         pla              	PLA				; pop function pointer low byte
.b398  85 9c      sta $9c          	STA	func_l		; restore it
.b39a  68         pla              	PLA				; pop function pointer high byte
.b39b  85 9d      sta $9d          	STA	func_h		; restore it
.b39d  a2 20      ldx #$20         	LDX	#$20			; error code $20 ("Undefined function" error)
.b39f  a0 03      ldy #$03         	LDY	#$03			; index to variable pointer high byte
.b3a1  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get variable pointer high byte
.b3a3  f0 9e      beq $b343        	BEQ	LAB_1FDB		; if zero go do undefined function error
.b3a5  85 96      sta $96          	STA	Cvarah		; save variable address high byte
.b3a7  88         dey              	DEY				; index to variable address low byte
.b3a8  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get variable address low byte
.b3aa  85 95      sta $95          	STA	Cvaral		; save variable address low byte
.b3ac  aa         tax              	TAX				; copy address low byte
.b3ad  c8         iny              	INY				; index to mantissa_3
.b3ae                              lab_2043
.b3ae  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get byte from variable
.b3b0  48         pha              	PHA				; stack it
.b3b1  88         dey              	DEY				; decrement index
.b3b2  10 fa      bpl $b3ae        	BPL	LAB_2043		; loop until variable stacked
.b3b4  a4 96      ldy $96          	LDY	Cvarah		; get variable address high byte
.b3b6  20 71 bb   jsr $bb71        	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
.b3b9  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.b3bb  48         pha              	PHA				; push it
.b3bc  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.b3be  48         pha              	PHA				; push it
.b3bf  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get function execute pointer low byte
.b3c1  85 c3      sta $c3          	STA	Bpntrl		; save as BASIC execute pointer low byte
.b3c3  c8         iny              	INY				; index to high byte
.b3c4  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get function execute pointer high byte
.b3c6  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.b3c8  a5 96      lda $96          	LDA	Cvarah		; get variable address high byte
.b3ca  48         pha              	PHA				; push it
.b3cb  a5 95      lda $95          	LDA	Cvaral		; get variable address low byte
.b3cd  48         pha              	PHA				; push it
.b3ce  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.b3d1  68         pla              	PLA				; pull variable address low byte
.b3d2  85 9c      sta $9c          	STA	func_l		; save variable address low byte
.b3d4  68         pla              	PLA				; pull variable address high byte
.b3d5  85 9d      sta $9d          	STA	func_h		; save variable address high byte
.b3d7  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.b3da  f0 03      beq $b3df        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
.b3dc  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; else syntax error, then warm start
.b3df                              lab_2074
.b3df  68         pla              	PLA				; pull BASIC execute pointer low byte
.b3e0  85 c3      sta $c3          	STA	Bpntrl		; restore BASIC execute pointer low byte
.b3e2  68         pla              	PLA				; pull BASIC execute pointer high byte
.b3e3  85 c4      sta $c4          	STA	Bpntrh		; restore BASIC execute pointer high byte
.b3e5                              lab_207a
.b3e5  a0 00      ldy #$00         	LDY	#$00			; clear index
.b3e7  68         pla              	PLA				; pull BASIC execute pointer low byte
.b3e8  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.b3ea  c8         iny              	INY				; increment index
.b3eb  68         pla              	PLA				; pull BASIC execute pointer high byte
.b3ec  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.b3ee  c8         iny              	INY				; increment index
.b3ef  68         pla              	PLA				; pull current var address low byte
.b3f0  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.b3f2  c8         iny              	INY				; increment index
.b3f3  68         pla              	PLA				; pull current var address high byte
.b3f4  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.b3f6  60         rts              	RTS				;
.b3f7                              lab_strs
.b3f7  20 9c ad   jsr $ad9c        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.b3fa  a0 00      ldy #$00         	LDY	#$00			; set string index
.b3fc  20 5d bd   jsr $bd5d        	JSR	LAB_2970		; convert FAC1 to string
.b3ff  68         pla              	PLA				; dump return address (skip type check)
.b400  68         pla              	PLA				; dump return address (skip type check)
.b401  a9 f0      lda #$f0         	LDA	#<(Decss+1)		; set result string low pointer
.b403  a0 00      ldy #$00         	LDY	#>(Decss+1)		; set result string high pointer
.b405  f0 12      beq $b419        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
.b407                              lab_209c
.b407  a6 ae      ldx $ae          	LDX	des_pl		; get descriptor pointer low byte
.b409  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.b40b  86 9e      stx $9e          	STX	des_2l		; save descriptor pointer low byte
.b40d  84 9f      sty $9f          	STY	des_2h		; save descriptor pointer high byte
.b40f                              lab_mssp
.b40f  20 82 b4   jsr $b482        	JSR	LAB_2115		; make space in string memory for string A long
.b412  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.b414  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.b416  85 ac      sta $ac          	STA	str_ln		; save length
.b418  60         rts              	RTS				;
.b419                              lab_20ae
.b419  a2 22      ldx #$22         	LDX	#$22			; set terminator to "
.b41b  86 5b      stx $5b          	STX	Srchc			; set search character (terminator 1)
.b41d  86 5c      stx $5c          	STX	Asrch			; set terminator 2
.b41f                              lab_20b4
.b41f  85 b8      sta $b8          	STA	ssptr_l		; store string start low byte
.b421  84 b9      sty $b9          	STY	ssptr_h		; store string start high byte
.b423  85 ad      sta $ad          	STA	str_pl		; save string pointer low byte
.b425  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.b427  a0 ff      ldy #$ff         	LDY	#$FF			; set length to -1
.b429                              lab_20be
.b429  c8         iny              	INY				; increment length
.b42a  b1 b8      lda ($b8),y      	LDA	(ssptr_l),Y		; get byte from string
.b42c  f0 0c      beq $b43a        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
.b42e  c5 5b      cmp $5b          	CMP	Srchc			; compare with search character (terminator 1)
.b430  f0 04      beq $b436        	BEQ	LAB_20CB		; branch if terminator
.b432  c5 5c      cmp $5c          	CMP	Asrch			; compare with terminator 2
.b434  d0 f3      bne $b429        	BNE	LAB_20BE		; loop if not terminator 2
.b436                              lab_20cb
.b436  c9 22      cmp #$22         	CMP	#$22			; compare with "
.b438  f0 01      beq $b43b        	BEQ	LAB_20D0		; branch if " (carry set if = !)
.b43a                              lab_20cf
.b43a  18         clc              	CLC				; clear carry for add (only if [EOL] terminated string)
.b43b                              lab_20d0
.b43b  84 ac      sty $ac          	STY	str_ln		; save length in FAC1 exponent
.b43d  98         tya              	TYA				; copy length to A
.b43e  65 b8      adc $b8          	ADC	ssptr_l		; add string start low byte
.b440  85 ba      sta $ba          	STA	Sendl			; save string end low byte
.b442  a6 b9      ldx $b9          	LDX	ssptr_h		; get string start high byte
.b444  90 01      bcc $b447        	BCC	LAB_20DC		; branch if no low byte overflow
.b446  e8         inx              	INX				; else increment high byte
.b447                              lab_20dc
.b447  86 bb      stx $bb          	STX	Sendh			; save string end high byte
.b449  a5 b9      lda $b9          	LDA	ssptr_h		; get string start high byte
.b44b  c9 04      cmp #$04         	CMP	#>Ram_base		; compare with start of program memory
.b44d  b0 0b      bcs $b45a        	BCS	LAB_RTST		; branch if not in utility area
.b44f  98         tya              	TYA				; copy length to A
.b450  20 07 b4   jsr $b407        	JSR	LAB_209C		; copy des_pl/h to des_2l/h & make string space A bytes long
.b453  a6 b8      ldx $b8          	LDX	ssptr_l		; get string start low byte
.b455  a4 b9      ldy $b9          	LDY	ssptr_h		; get string start high byte
.b457  20 f4 b5   jsr $b5f4        	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
.b45a                              lab_rtst
.b45a  a6 65      ldx $65          	LDX	next_s		; get string stack pointer
.b45c  e0 71      cpx #$71         	CPX	#des_sk+$09		; compare with max+1
.b45e  d0 05      bne $b465        	BNE	LAB_20F8		; branch if space on string stack
.b460  a2 1c      ldx #$1c         	LDX	#$1C			; error code $1C ("String too complex" error)
.b462                              lab_20f5
.b462  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.b465                              lab_20f8
.b465  a5 ac      lda $ac          	LDA	str_ln		; get string length
.b467  95 00      sta $00,x        	STA	PLUS_0,X		; put on string stack
.b469  a5 ad      lda $ad          	LDA	str_pl		; get string pointer low byte
.b46b  95 01      sta $01,x        	STA	PLUS_1,X		; put on string stack
.b46d  a5 ae      lda $ae          	LDA	str_ph		; get string pointer high byte
.b46f  95 02      sta $02,x        	STA	PLUS_2,X		; put on string stack
.b471  a0 00      ldy #$00         	LDY	#$00			; clear Y
.b473  86 ae      stx $ae          	STX	des_pl		; save string descriptor pointer low byte
.b475  84 af      sty $af          	STY	des_ph		; save string descriptor pointer high byte (always $00)
.b477  88         dey              	DEY				; Y = $FF
.b478  84 5f      sty $5f          	STY	Dtypef		; save data type flag, $FF=string
.b47a  86 66      stx $66          	STX	last_sl		; save old stack pointer (current top item)
.b47c  e8         inx              	INX				; update stack pointer
.b47d  e8         inx              	INX				; update stack pointer
.b47e  e8         inx              	INX				; update stack pointer
.b47f  86 65      stx $65          	STX	next_s		; save new top item value
.b481  60         rts              	RTS				;
.b482                              lab_2115
.b482  46 60      lsr $60          	LSR	Gclctd		; clear garbage collected flag (b7)
.b484                              lab_2117
.b484  48         pha              	PHA				; save string length
.b485  49 ff      eor #$ff         	EOR	#$FF			; complement it
.b487  38         sec              	SEC				; set carry for subtract (twos comp add)
.b488  65 81      adc $81          	ADC	Sstorl		; add bottom of string space low byte (subtract length)
.b48a  a4 82      ldy $82          	LDY	Sstorh		; get bottom of string space high byte
.b48c  b0 01      bcs $b48f        	BCS	LAB_2122		; skip decrement if no underflow
.b48e  88         dey              	DEY				; decrement bottom of string space high byte
.b48f                              lab_2122
.b48f  c4 80      cpy $80          	CPY	Earryh		; compare with array mem end high byte
.b491  90 11      bcc $b4a4        	BCC	LAB_2137		; do out of memory error if less
.b493  d0 04      bne $b499        	BNE	LAB_212C		; if not = skip next test
.b495  c5 7f      cmp $7f          	CMP	Earryl		; compare with array mem end low byte
.b497  90 0b      bcc $b4a4        	BCC	LAB_2137		; do out of memory error if less
.b499                              lab_212c
.b499  85 81      sta $81          	STA	Sstorl		; save bottom of string space low byte
.b49b  84 82      sty $82          	STY	Sstorh		; save bottom of string space high byte
.b49d  85 83      sta $83          	STA	Sutill		; save string utility ptr low byte
.b49f  84 84      sty $84          	STY	Sutilh		; save string utility ptr high byte
.b4a1  aa         tax              	TAX				; copy low byte to X
.b4a2  68         pla              	PLA				; get string length back
.b4a3  60         rts              	RTS				;
.b4a4                              lab_2137
.b4a4  a2 0c      ldx #$0c         	LDX	#$0C			; error code $0C ("Out of memory" error)
.b4a6  a5 60      lda $60          	LDA	Gclctd		; get garbage collected flag
.b4a8  30 b8      bmi $b462        	BMI	LAB_20F5		; if set then do error code X
.b4aa  20 b4 b4   jsr $b4b4        	JSR	LAB_GARB		; else go do garbage collection
.b4ad  a9 80      lda #$80         	LDA	#$80			; flag for garbage collected
.b4af  85 60      sta $60          	STA	Gclctd		; set garbage collected flag
.b4b1  68         pla              	PLA				; pull length
.b4b2  d0 d0      bne $b484        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
.b4b4                              lab_garb
.b4b4  a6 85      ldx $85          	LDX	Ememl			; get end of mem low byte
.b4b6  a5 86      lda $86          	LDA	Ememh			; get end of mem high byte
.b4b8                              lab_214b
.b4b8  86 81      stx $81          	STX	Sstorl		; set string storage low byte
.b4ba  85 82      sta $82          	STA	Sstorh		; set string storage high byte
.b4bc  a0 00      ldy #$00         	LDY	#$00			; clear index
.b4be  84 9d      sty $9d          	STY	garb_h		; clear working pointer high byte (flag no strings to move)
.b4c0  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.b4c2  a6 80      ldx $80          	LDX	Earryh		; get array mem end high byte
.b4c4  85 aa      sta $aa          	STA	Histrl		; save as highest string low byte
.b4c6  86 ab      stx $ab          	STX	Histrh		; save as highest string high byte
.b4c8  a9 68      lda #$68         	LDA	#des_sk		; set descriptor stack pointer
.b4ca  85 71      sta $71          	STA	ut1_pl		; save descriptor stack pointer low byte
.b4cc  84 72      sty $72          	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
.b4ce                              lab_2161
.b4ce  c5 65      cmp $65          	CMP	next_s		; compare with descriptor stack pointer
.b4d0  f0 05      beq $b4d7        	BEQ	LAB_216A		; branch if =
.b4d2  20 38 b5   jsr $b538        	JSR	LAB_21D7		; go garbage collect descriptor stack
.b4d5  f0 f7      beq $b4ce        	BEQ	LAB_2161		; loop always
.b4d7                              lab_216a
.b4d7  06 a0      asl $a0          	ASL	g_step		; set step size = $06
.b4d9  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.b4db  a6 7c      ldx $7c          	LDX	Svarh			; get start of vars high byte
.b4dd  85 71      sta $71          	STA	ut1_pl		; save as pointer low byte
.b4df  86 72      stx $72          	STX	ut1_ph		; save as pointer high byte
.b4e1                              lab_2176
.b4e1  e4 7e      cpx $7e          	CPX	Sarryh		; compare start of arrays high byte
.b4e3  d0 04      bne $b4e9        	BNE	LAB_217E		; branch if no high byte match
.b4e5  c5 7d      cmp $7d          	CMP	Sarryl		; else compare start of arrays low byte
.b4e7  f0 05      beq $b4ee        	BEQ	LAB_2183		; branch if = var mem end
.b4e9                              lab_217e
.b4e9  20 32 b5   jsr $b532        	JSR	LAB_21D1		; go garbage collect strings
.b4ec  f0 f3      beq $b4e1        	BEQ	LAB_2176		; loop always
.b4ee                              lab_2183
.b4ee  85 a4      sta $a4          	STA	Nbendl		; save start of arrays low byte as working pointer
.b4f0  86 a5      stx $a5          	STX	Nbendh		; save start of arrays high byte as working pointer
.b4f2  a9 04      lda #$04         	LDA	#$04			; set step size
.b4f4  85 a0      sta $a0          	STA	g_step		; save step size
.b4f6                              lab_218b
.b4f6  a5 a4      lda $a4          	LDA	Nbendl		; get pointer low byte
.b4f8  a6 a5      ldx $a5          	LDX	Nbendh		; get pointer high byte
.b4fa                              lab_218f
.b4fa  e4 80      cpx $80          	CPX	Earryh		; compare with array mem end high byte
.b4fc  d0 04      bne $b502        	BNE	LAB_219A		; branch if not at end
.b4fe  c5 7f      cmp $7f          	CMP	Earryl		; else compare with array mem end low byte
.b500  f0 75      beq $b577        	BEQ	LAB_2216		; tidy up and exit if at end
.b502                              lab_219a
.b502  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.b504  86 72      stx $72          	STX	ut1_ph		; save pointer high byte
.b506  a0 02      ldy #$02         	LDY	#$02			; set index
.b508  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get array size low byte
.b50a  65 a4      adc $a4          	ADC	Nbendl		; add start of this array low byte
.b50c  85 a4      sta $a4          	STA	Nbendl		; save start of next array low byte
.b50e  c8         iny              	INY				; increment index
.b50f  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get array size high byte
.b511  65 a5      adc $a5          	ADC	Nbendh		; add start of this array high byte
.b513  85 a5      sta $a5          	STA	Nbendh		; save start of next array high byte
.b515  a0 01      ldy #$01         	LDY	#$01			; set index
.b517  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get name second byte
.b519  10 db      bpl $b4f6        	BPL	LAB_218B		; skip if not string array
.b51b  a0 04      ldy #$04         	LDY	#$04			; set index
.b51d  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get # of dimensions
.b51f  0a         asl              	ASL				; *2
.b520  69 05      adc #$05         	ADC	#$05			; +5 (array header size)
.b522  20 6a b5   jsr $b56a        	JSR	LAB_2208		; go set up for first element
.b525                              lab_21c4
.b525  e4 a5      cpx $a5          	CPX	Nbendh		; compare with start of next array high byte
.b527  d0 04      bne $b52d        	BNE	LAB_21CC		; branch if <> (go do this array)
.b529  c5 a4      cmp $a4          	CMP	Nbendl		; else compare element pointer low byte with next array
.b52b  f0 cd      beq $b4fa        	BEQ	LAB_218F		; if equal then go do next array
.b52d                              lab_21cc
.b52d  20 38 b5   jsr $b538        	JSR	LAB_21D7		; go defrag array strings
.b530  f0 f3      beq $b525        	BEQ	LAB_21C4		; go do next array string (loop always)
.b532                              lab_21d1
.b532  c8         iny              	INY				; increment index (Y was $00)
.b533  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get var name byte 2
.b535  10 30      bpl $b567        	BPL	LAB_2206		; if not string, step pointer to next var & RET
.b537  c8         iny              	INY				; else increment index
.b538                              lab_21d7
.b538  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string length
.b53a  f0 2b      beq $b567        	BEQ	LAB_2206		; if null, step pointer to next string & RET
.b53c  c8         iny              	INY				; else increment index
.b53d  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer low byte
.b53f  aa         tax              	TAX				; copy to X
.b540  c8         iny              	INY				; increment index
.b541  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer high byte
.b543  c5 82      cmp $82          	CMP	Sstorh		; compare bottom of string space high byte
.b545  90 06      bcc $b54d        	BCC	LAB_21EC		; branch if less
.b547  d0 1e      bne $b567        	BNE	LAB_2206		; if greater, step pointer to next string & RET
.b549  e4 81      cpx $81          	CPX	Sstorl		; compare bottom of string space low byte
.b54b  b0 1a      bcs $b567        	BCS	LAB_2206		; if >=, step pointer to next string & RET
.b54d                              lab_21ec
.b54d  c5 ab      cmp $ab          	CMP	Histrh		; compare to highest string high byte
.b54f  90 17      bcc $b568        	BCC	LAB_2207		; if <, step pointer to next string & RET
.b551  d0 04      bne $b557        	BNE	LAB_21F6		; if > update pointers, step to next & return
.b553  e4 aa      cpx $aa          	CPX	Histrl		; compare to highest string low byte
.b555  90 11      bcc $b568        	BCC	LAB_2207		; if <, step pointer to next string & RET
.b557                              lab_21f6
.b557  86 aa      stx $aa          	STX	Histrl		; save as new highest string low byte
.b559  85 ab      sta $ab          	STA	Histrh		; save as new highest string high byte
.b55b  a5 71      lda $71          	LDA	ut1_pl		; get start of vars(descriptors) low byte
.b55d  a6 72      ldx $72          	LDX	ut1_ph		; get start of vars(descriptors) high byte
.b55f  85 9c      sta $9c          	STA	garb_l		; save as working pointer low byte
.b561  86 9d      stx $9d          	STX	garb_h		; save as working pointer high byte
.b563  88         dey              	DEY				; decrement index DIFFERS
.b564  88         dey              	DEY				; decrement index (should point to descriptor start)
.b565  84 a2      sty $a2          	STY	g_indx		; save index pointer
.b567                              lab_2206
.b567  18         clc              	CLC				; clear carry for add
.b568                              lab_2207
.b568  a5 a0      lda $a0          	LDA	g_step		; get step size
.b56a                              lab_2208
.b56a  65 71      adc $71          	ADC	ut1_pl		; add pointer low byte
.b56c  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.b56e  90 02      bcc $b572        	BCC	LAB_2211		; branch if no overflow
.b570  e6 72      inc $72          	INC	ut1_ph		; else increment high byte
.b572                              lab_2211
.b572  a6 72      ldx $72          	LDX	ut1_ph		; get pointer high byte
.b574  a0 00      ldy #$00         	LDY	#$00			; clear Y
.b576  60         rts              	RTS				;
.b577                              lab_2216
.b577  c6 a0      dec $a0          	DEC	g_step		; decrement step size (now $03 for descriptor stack)
.b579  a6 9d      ldx $9d          	LDX	garb_h		; get string to move high byte
.b57b  f0 f5      beq $b572        	BEQ	LAB_2211		; exit if nothing to move
.b57d  a4 a2      ldy $a2          	LDY	g_indx		; get index byte back (points to descriptor)
.b57f  18         clc              	CLC				; clear carry for add
.b580  b1 9c      lda ($9c),y      	LDA	(garb_l),Y		; get string length
.b582  65 aa      adc $aa          	ADC	Histrl		; add highest string low byte
.b584  85 a6      sta $a6          	STA	Obendl		; save old block end low pointer
.b586  a5 ab      lda $ab          	LDA	Histrh		; get highest string high byte
.b588  69 00      adc #$00         	ADC	#$00			; add any carry
.b58a  85 a7      sta $a7          	STA	Obendh		; save old block end high byte
.b58c  a5 81      lda $81          	LDA	Sstorl		; get bottom of string space low byte
.b58e  a6 82      ldx $82          	LDX	Sstorh		; get bottom of string space high byte
.b590  85 a4      sta $a4          	STA	Nbendl		; save new block end low byte
.b592  86 a5      stx $a5          	STX	Nbendh		; save new block end high byte
.b594  20 cb a3   jsr $a3cb        	JSR	LAB_11D6		; open up space in memory, don't set array end
.b597  a4 a2      ldy $a2          	LDY	g_indx		; get index byte
.b599  c8         iny              	INY				; point to descriptor low byte
.b59a  a5 a4      lda $a4          	LDA	Nbendl		; get string pointer low byte
.b59c  91 9c      sta ($9c),y      	STA	(garb_l),Y		; save new string pointer low byte
.b59e  aa         tax              	TAX				; copy string pointer low byte
.b59f  e6 a5      inc $a5          	INC	Nbendh		; correct high byte (move sets high byte -1)
.b5a1  a5 a5      lda $a5          	LDA	Nbendh		; get new string pointer high byte
.b5a3  c8         iny              	INY				; point to descriptor high byte
.b5a4  91 9c      sta ($9c),y      	STA	(garb_l),Y		; save new string pointer high byte
.b5a6  4c b8 b4   jmp $b4b8        	JMP	LAB_214B		; re-run routine from last ending
.b5a9                              lab_224d
.b5a9  a5 af      lda $af          	LDA	des_ph		; get descriptor pointer high byte
.b5ab  48         pha              	PHA				; put on stack
.b5ac  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.b5ae  48         pha              	PHA				; put on stack
.b5af  20 88 ae   jsr $ae88        	JSR	LAB_GVAL		; get value from line
.b5b2  20 9e ad   jsr $ad9e        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.b5b5  68         pla              	PLA				; get descriptor pointer low byte back
.b5b6  85 b8      sta $b8          	STA	ssptr_l		; set pointer low byte
.b5b8  68         pla              	PLA				; get descriptor pointer high byte back
.b5b9  85 b9      sta $b9          	STA	ssptr_h		; set pointer high byte
.b5bb  a0 00      ldy #$00         	LDY	#$00			; clear index
.b5bd  b1 b8      lda ($b8),y      	LDA	(ssptr_l),Y		; get length_1 from descriptor
.b5bf  18         clc              	CLC				; clear carry for add
.b5c0  71 ae      adc ($ae),y      	ADC	(des_pl),Y		; add length_2
.b5c2  90 05      bcc $b5c9        	BCC	LAB_226D		; branch if no overflow
.b5c4  a2 1a      ldx #$1a         	LDX	#$1A			; else set error code $1A ("String too long" error)
.b5c6  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.b5c9                              lab_226d
.b5c9  20 07 b4   jsr $b407        	JSR	LAB_209C		; copy des_pl/h to des_2l/h & make string space A bytes long
.b5cc  20 e6 b5   jsr $b5e6        	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.b5cf  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.b5d1  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.b5d3  20 17 b6   jsr $b617        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.b5d6  20 f8 b5   jsr $b5f8        	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.b5d9  a5 b8      lda $b8          	LDA	ssptr_l		;.set descriptor pointer low byte
.b5db  a4 b9      ldy $b9          	LDY	ssptr_h		;.set descriptor pointer high byte
.b5dd  20 17 b6   jsr $b617        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.b5e0  20 5a b4   jsr $b45a        	JSR	LAB_RTST		; check for space on descriptor stack then put string address
.b5e3  4c c4 ad   jmp $adc4        	JMP	LAB_1ADB		;.continue evaluation
.b5e6                              lab_228a
.b5e6  a0 00      ldy #$00         	LDY	#$00			; clear index
.b5e8  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get string length
.b5ea  48         pha              	PHA				; save on stack
.b5eb  c8         iny              	INY				; increment index
.b5ec  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get source string pointer low byte
.b5ee  aa         tax              	TAX				; copy to X
.b5ef  c8         iny              	INY				; increment index
.b5f0  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get source string pointer high byte
.b5f2  a8         tay              	TAY				; copy to Y
.b5f3  68         pla              	PLA				; get length back
.b5f4                              lab_2298
.b5f4  86 71      stx $71          	STX	ut1_pl		; save source string pointer low byte
.b5f6  84 72      sty $72          	STY	ut1_ph		; save source string pointer high byte
.b5f8                              lab_229c
.b5f8  aa         tax              	TAX				; copy length to index (don't count with Y)
.b5f9  f0 14      beq $b60f        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
.b5fb  a0 00      ldy #$00         	LDY	#$00			; zero pointer (copy forward)
.b5fd                              lab_22a0
.b5fd  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get source byte
.b5ff  91 83      sta ($83),y      	STA	(Sutill),Y		; save destination byte
.b601  c8         iny              	INY				; increment index
.b602  ca         dex              	DEX				; decrement counter
.b603  d0 f8      bne $b5fd        	BNE	LAB_22A0		; loop while <> 0
.b605  98         tya              	TYA				; restore length from Y
.b606                              lab_22a9
.b606  18         clc              	CLC				; clear carry for add
.b607  65 83      adc $83          	ADC	Sutill		; add string utility ptr low byte
.b609  85 83      sta $83          	STA	Sutill		; save string utility ptr low byte
.b60b  90 02      bcc $b60f        	BCC	LAB_22B2		; branch if no carry
.b60d  e6 84      inc $84          	INC	Sutilh		; else increment string utility ptr high byte
.b60f                              lab_22b2
.b60f  60         rts              	RTS				;
.b610                              lab_evst
.b610  20 9e ad   jsr $ad9e        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.b613                              lab_22b6
.b613  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.b615  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.b617                              lab_22ba
.b617  85 71      sta $71          	STA	ut1_pl		; save string pointer low byte
.b619  84 72      sty $72          	STY	ut1_ph		; save string pointer high byte
.b61b  20 48 b6   jsr $b648        	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.b61e  08         php              	PHP				; save status flags
.b61f  a0 00      ldy #$00         	LDY	#$00			; clear index
.b621  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get length from string descriptor
.b623  48         pha              	PHA				; put on stack
.b624  c8         iny              	INY				; increment index
.b625  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
.b627  aa         tax              	TAX				; copy to X
.b628  c8         iny              	INY				; increment index
.b629  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
.b62b  a8         tay              	TAY				; copy to Y
.b62c  68         pla              	PLA				; get string length back
.b62d  28         plp              	PLP				; restore status
.b62e  d0 13      bne $b643        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
.b630  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string space high byte
.b632  d0 0f      bne $b643        	BNE	LAB_22E6		; branch if <>
.b634  e4 81      cpx $81          	CPX	Sstorl		; else compare bottom of string space low byte
.b636  d0 0b      bne $b643        	BNE	LAB_22E6		; branch if <>
.b638  48         pha              	PHA				; save string length
.b639  18         clc              	CLC				; clear carry for add
.b63a  65 81      adc $81          	ADC	Sstorl		; add bottom of string space low byte
.b63c  85 81      sta $81          	STA	Sstorl		; save bottom of string space low byte
.b63e  90 02      bcc $b642        	BCC	LAB_22E5		; skip increment if no overflow
.b640  e6 82      inc $82          	INC	Sstorh		; increment bottom of string space high byte
.b642                              lab_22e5
.b642  68         pla              	PLA				; restore string length
.b643                              lab_22e6
.b643  86 71      stx $71          	STX	ut1_pl		; save string pointer low byte
.b645  84 72      sty $72          	STY	ut1_ph		; save string pointer high byte
.b647  60         rts              	RTS				;
.b648                              lab_22eb
.b648  c4 67      cpy $67          	CPY	last_sh		; compare pointer high byte
.b64a  d0 0c      bne $b658        	BNE	LAB_22FB		; exit if <>
.b64c  c5 66      cmp $66          	CMP	last_sl		; compare pointer low byte
.b64e  d0 08      bne $b658        	BNE	LAB_22FB		; exit if <>
.b650  85 65      sta $65          	STA	next_s		; save descriptor stack pointer
.b652  e9 03      sbc #$03         	SBC	#$03			; -3
.b654  85 66      sta $66          	STA	last_sl		; save low byte -3
.b656  a0 00      ldy #$00         	LDY	#$00			; clear high byte
.b658                              lab_22fb
.b658  60         rts              	RTS				;
.b659                              lab_chrs
.b659  20 53 b7   jsr $b753        	JSR	LAB_EVBY		; evaluate byte expression, result in X
.b65c  8a         txa              	TXA				; copy to A
.b65d  48         pha              	PHA				; save character
.b65e  a9 01      lda #$01         	LDA	#$01			; string is single byte
.b660  20 0f b4   jsr $b40f        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.b663  68         pla              	PLA				; get character back
.b664  a0 00      ldy #$00         	LDY	#$00			; clear index
.b666  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save byte in string (byte IS string!)
.b668  68         pla              	PLA				; dump return address (skip type check)
.b669  68         pla              	PLA				; dump return address (skip type check)
.b66a  4c 5a b4   jmp $b45a        	JMP	LAB_RTST		; check for space on descriptor stack then put string address
.b66d                              lab_left
.b66d  20 cb b6   jsr $b6cb        	JSR	LAB_236F		; pull string data & byte parameter from stack
.b670  d1 9e      cmp ($9e),y      	CMP	(des_2l),Y		; compare byte parameter with string length
.b672  98         tya              	TYA				; clear A
.b673  f0 08      beq $b67d        	BEQ	LAB_2316		; go do string copy (branch always)
.b675                              lab_right
.b675  20 cb b6   jsr $b6cb        	JSR	LAB_236F		; pull string data & byte parameter from stack
.b678  18         clc              	CLC				; clear carry for add-1
.b679  f1 9e      sbc ($9e),y      	SBC	(des_2l),Y		; subtract string length
.b67b  49 ff      eor #$ff         	EOR	#$FF			; invert it (A=LEN(expression$)-l)
.b67d                              lab_2316
.b67d  90 04      bcc $b683        	BCC	LAB_231C		; branch if string length > byte parameter
.b67f  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; else make parameter = length
.b681  aa         tax              	TAX				; copy to byte parameter copy
.b682  98         tya              	TYA				; clear string start offset
.b683                              lab_231c
.b683  48         pha              	PHA				; save string start offset
.b684                              lab_231d
.b684  8a         txa              	TXA				; copy byte parameter (or string length if <)
.b685                              lab_231e
.b685  48         pha              	PHA				; save string length
.b686  20 0f b4   jsr $b40f        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.b689  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.b68b  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.b68d  20 17 b6   jsr $b617        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.b690  68         pla              	PLA				; get string length back
.b691  a8         tay              	TAY				; copy length to Y
.b692  68         pla              	PLA				; get string start offset back
.b693  18         clc              	CLC				; clear carry for add
.b694  65 71      adc $71          	ADC	ut1_pl		; add start offset to string start pointer low byte
.b696  85 71      sta $71          	STA	ut1_pl		; save string start pointer low byte
.b698  90 02      bcc $b69c        	BCC	LAB_2335		; branch if no overflow
.b69a  e6 72      inc $72          	INC	ut1_ph		; else increment string start pointer high byte
.b69c                              lab_2335
.b69c  98         tya              	TYA				; copy length to A
.b69d  20 f8 b5   jsr $b5f8        	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.b6a0  4c 5a b4   jmp $b45a        	JMP	LAB_RTST		; check for space on descriptor stack then put string address
.b6a3                              lab_mids
.b6a3  a9 ff      lda #$ff         	LDA	#$FF			; set default length = 255
.b6a5  85 af      sta $af          	STA	mids_l		; save default length
.b6a7  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.b6aa  c9 29      cmp #$29         	CMP	#$29			; compare with ")"
.b6ac  f0 06      beq $b6b4        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
.b6ae  20 f0 ae   jsr $aef0        	JSR	LAB_1C01		; scan for "," , else do syntax error, then warm start
.b6b1  20 50 b7   jsr $b750        	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
.b6b4                              lab_2358
.b6b4  20 cb b6   jsr $b6cb        	JSR	LAB_236F		; pull string data & byte parameter from stack
.b6b7  ca         dex              	DEX				; decrement start index
.b6b8  8a         txa              	TXA				; copy to A
.b6b9  48         pha              	PHA				; save string start offset
.b6ba  18         clc              	CLC				; clear carry for sub-1
.b6bb  a2 00      ldx #$00         	LDX	#$00			; clear output string length
.b6bd  f1 9e      sbc ($9e),y      	SBC	(des_2l),Y		; subtract string length
.b6bf  b0 c3      bcs $b684        	BCS	LAB_231D		; if start>string length go do null string
.b6c1  49 ff      eor #$ff         	EOR	#$FF			; complement -length
.b6c3  c5 af      cmp $af          	CMP	mids_l		; compare byte parameter
.b6c5  90 be      bcc $b685        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
.b6c7  a5 af      lda $af          	LDA	mids_l		; get length byte
.b6c9  b0 ba      bcs $b685        	BCS	LAB_231E		; go do string copy (branch always)
.b6cb                              lab_236f
.b6cb  20 ea ae   jsr $aeea        	JSR	LAB_1BFB		; scan for ")" , else do syntax error, then warm start
.b6ce  68         pla              	PLA				; pull return address low byte (return address)
.b6cf  85 a2      sta $a2          	STA	Fnxjpl		; save functions jump vector low byte
.b6d1  68         pla              	PLA				; pull return address high byte (return address)
.b6d2  85 a3      sta $a3          	STA	Fnxjph		; save functions jump vector high byte
.b6d4  68         pla              	PLA				; dump call to function vector low byte
.b6d5  68         pla              	PLA				; dump call to function vector high byte
.b6d6  68         pla              	PLA				; pull byte parameter
.b6d7  aa         tax              	TAX				; copy byte parameter to X
.b6d8  68         pla              	PLA				; pull string pointer low byte
.b6d9  85 9e      sta $9e          	STA	des_2l		; save it
.b6db  68         pla              	PLA				; pull string pointer high byte
.b6dc  85 9f      sta $9f          	STA	des_2h		; save it
.b6de  a0 00      ldy #$00         	LDY	#$00			; clear index
.b6e0  8a         txa              	TXA				; copy byte parameter
.b6e1  f0 67      beq $b74a        	BEQ	LAB_23A8		; if null do function call error, then warm start
.b6e3  e6 a2      inc $a2          	INC	Fnxjpl		; increment function jump vector low byte
.b6e5  6c a2 00   jmp ($00a2)      	JMP	(Fnxjpl)		; in effect, RTS
.b6e8                              lab_lcase
.b6e8  20 10 b6   jsr $b610        	JSR	LAB_EVST		; evaluate string
.b6eb  85 ac      sta $ac          	STA	str_ln		; set string length
.b6ed  86 ad      stx $ad          	STX	str_pl		; set string pointer low byte
.b6ef  84 ae      sty $ae          	STY	str_ph		; set string pointer high byte
.b6f1  a8         tay              	TAY				; copy length to Y
.b6f2  f0 2c      beq $b720        	BEQ	NoString		; branch if null string
.b6f4                              lc_loop
.b6f4  88         dey              	DEY				; decrement index
.b6f5  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from string
.b6f7  20 f2 b0   jsr $b0f2        	JSR	LAB_1D82		; is character "A" to "Z"
.b6fa  90 04      bcc $b700        	BCC	NoUcase		; branch if not upper case alpha
.b6fc  09 20      ora #$20         	ORA	#$20			; convert upper to lower case
.b6fe  91 71      sta ($71),y      	STA	(ut1_pl),Y		; save byte back to string
.b700                              noucase
.b700  98         tya              	TYA				; test index
.b701  d0 f1      bne $b6f4        	BNE	LC_loop		; loop if not all done
.b703  f0 1b      beq $b720        	BEQ	NoString		; tidy up & exit (branch always)
.b705                              lab_ucase
.b705  20 10 b6   jsr $b610        	JSR	LAB_EVST		; evaluate string
.b708  85 ac      sta $ac          	STA	str_ln		; set string length
.b70a  86 ad      stx $ad          	STX	str_pl		; set string pointer low byte
.b70c  84 ae      sty $ae          	STY	str_ph		; set string pointer high byte
.b70e  a8         tay              	TAY				; copy length to Y
.b70f  f0 0f      beq $b720        	BEQ	NoString		; branch if null string
.b711                              uc_loop
.b711  88         dey              	DEY				; decrement index
.b712  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from string
.b714  20 ee b0   jsr $b0ee        	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
.b717  90 04      bcc $b71d        	BCC	NoLcase		; branch if not alpha
.b719  29 df      and #$df         	AND	#$DF			; convert lower to upper case
.b71b  91 71      sta ($71),y      	STA	(ut1_pl),Y		; save byte back to string
.b71d                              nolcase
.b71d  98         tya              	TYA				; test index
.b71e  d0 f1      bne $b711        	BNE	UC_loop		; loop if not all done
.b720                              nostring
.b720  68         pla              	PLA				; dump return address (skip type check)
.b721  68         pla              	PLA				; dump return address (skip type check)
.b722  4c 5a b4   jmp $b45a        	JMP	LAB_RTST		; check for space on descriptor stack then put string address
.b725                              lab_sadd
.b725  20 10 b6   jsr $b610        	JSR	LAB_EVST		; evaluate string
.b728  98         tya              	TYA				; string address high byte to A
.b729  a4 71      ldy $71          	LDY	ut1_pl		; string address low byte to Y
.b72b  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & return
.b72e                              lab_lens
.b72e  20 34 b7   jsr $b734        	JSR	LAB_ESGL		; evaluate string, get length in A (& Y)
.b731  4c 38 b3   jmp $b338        	JMP	LAB_1FD0		; convert Y to byte in FAC1 & return
.b734                              lab_esgl
.b734  20 10 b6   jsr $b610        	JSR	LAB_EVST		; evaluate string
.b737  a2 00      ldx #$00         	LDX	#$00			; set data type = numeric
.b739  86 5f      stx $5f          	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
.b73b  a8         tay              	TAY				; copy length to Y
.b73c  60         rts              	RTS				;
.b73d                              lab_asc
.b73d  20 34 b7   jsr $b734        	JSR	LAB_ESGL		; evaluate string, get length in A (& Y)
.b740  f0 08      beq $b74a        	BEQ	LAB_23A8		; if null do function call error, then warm start
.b742  a0 00      ldy #$00         	LDY	#$00			; set index to first character
.b744  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte
.b746  a8         tay              	TAY				; copy to Y
.b747  4c 38 b3   jmp $b338        	JMP	LAB_1FD0		; convert Y to byte in FAC1 & return
.b74a                              lab_23a8
.b74a  4c f9 b1   jmp $b1f9        	JMP	LAB_FCER		; do function call error, then warm start
.b74d                              lab_sgby
.b74d  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.b750                              lab_gtby
.b750  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.b753                              lab_evby
.b753  20 72 b1   jsr $b172        	JSR	LAB_EVPI		; evaluate integer expression (no check)
.b756  a4 ae      ldy $ae          	LDY	FAC1_2		; get FAC1 mantissa2
.b758  d0 f0      bne $b74a        	BNE	LAB_23A8		; if top byte <> 0 do function call error, then warm start
.b75a  a6 af      ldx $af          	LDX	FAC1_3		; get FAC1 mantissa3
.b75c  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory & return
.b75f                              lab_val
.b75f  20 34 b7   jsr $b734        	JSR	LAB_ESGL		; evaluate string, get length in A (& Y)
.b762  d0 03      bne $b767        	BNE	LAB_23C5		; branch if not null string
.b764  4c 14 b9   jmp $b914        	JMP	LAB_24F1		; clear FAC1 exponent & sign & return
.b767                              lab_23c5
.b767  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.b769  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.b76b  86 ba      stx $ba          	STX	Btmpl			; save BASIC execute pointer low byte
.b76d  84 bb      sty $bb          	STY	Btmph			; save BASIC execute pointer high byte
.b76f  a6 71      ldx $71          	LDX	ut1_pl		; get string pointer low byte
.b771  86 c3      stx $c3          	STX	Bpntrl		; save as BASIC execute pointer low byte
.b773  18         clc              	CLC				; clear carry
.b774  65 71      adc $71          	ADC	ut1_pl		; add string length
.b776  85 73      sta $73          	STA	ut2_pl		; save string end low byte
.b778  a5 72      lda $72          	LDA	ut1_ph		; get string pointer high byte
.b77a  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.b77c  69 00      adc #$00         	ADC	#$00			; add carry to high byte
.b77e  85 74      sta $74          	STA	ut2_ph		; save string end high byte
.b780  a0 00      ldy #$00         	LDY	#$00			; set index to $00
.b782  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get string end +1 byte
.b784  48         pha              	PHA				; push it
.b785  98         tya              	TYA				; clear A
.b786  91 73      sta ($73),y      	STA	(ut2_pl),Y		; terminate string with $00
.b788  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.b78b  20 70 bc   jsr $bc70        	JSR	LAB_2887		; get FAC1 from string
.b78e  68         pla              	PLA				; restore string end +1 byte
.b78f  a0 00      ldy #$00         	LDY	#$00			; set index to zero
.b791  91 73      sta ($73),y      	STA	(ut2_pl),Y		; put string end byte back
.b793                              lab_23f3
.b793  a6 ba      ldx $ba          	LDX	Btmpl			; get BASIC execute pointer low byte back
.b795  a4 bb      ldy $bb          	LDY	Btmph			; get BASIC execute pointer high byte back
.b797  86 c3      stx $c3          	STX	Bpntrl		; save BASIC execute pointer low byte
.b799  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.b79b  60         rts              	RTS				;
.b79c                              lab_gadb
.b79c  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.b79f  20 b5 b7   jsr $b7b5        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.b7a2                              lab_scgb
.b7a2  20 f0 ae   jsr $aef0        	JSR	LAB_1C01		; scan for "," , else do syntax error, then warm start
.b7a5  a5 12      lda $12          	LDA	Itemph		; save temporary integer high byte
.b7a7  48         pha              	PHA				; on stack
.b7a8  a5 11      lda $11          	LDA	Itempl		; save temporary integer low byte
.b7aa  48         pha              	PHA				; on stack
.b7ab  20 50 b7   jsr $b750        	JSR	LAB_GTBY		; get byte parameter
.b7ae  68         pla              	PLA				; pull low byte
.b7af  85 11      sta $11          	STA	Itempl		; restore temporary integer low byte
.b7b1  68         pla              	PLA				; pull high byte
.b7b2  85 12      sta $12          	STA	Itemph		; restore temporary integer high byte
.b7b4  60         rts              	RTS				;
.b7b5                              lab_f2fx
.b7b5  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.b7b7  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.b7b9  b0 8f      bcs $b74a        	BCS	LAB_23A8		; if >= do function call error, then warm start
.b7bb                              lab_f2fu
.b7bb  20 1a bc   jsr $bc1a        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.b7be  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.b7c0  a4 af      ldy $af          	LDY	FAC1_3		; get FAC1 mantissa3
.b7c2  84 11      sty $11          	STY	Itempl		; save temporary integer low byte
.b7c4  85 12      sta $12          	STA	Itemph		; save temporary integer high byte
.b7c6  60         rts              	RTS				;
.b7c7                              lab_peek
.b7c7  20 b5 b7   jsr $b7b5        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.b7ca  a2 00      ldx #$00         	LDX	#$00			; clear index
.b7cc  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; get byte via temporary integer (addr)
.b7ce  a8         tay              	TAY				; copy byte to Y
.b7cf  4c 38 b3   jmp $b338        	JMP	LAB_1FD0		; convert Y to byte in FAC1 & return
.b7d2                              lab_poke
.b7d2  20 9c b7   jsr $b79c        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.b7d5  8a         txa              	TXA				; copy byte argument to A
.b7d6  a2 00      ldx #$00         	LDX	#$00			; clear index
.b7d8  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.b7da  60         rts              	RTS				;
.b7db                              lab_deek
.b7db  20 b5 b7   jsr $b7b5        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.b7de  a2 00      ldx #$00         	LDX	#$00			; clear index
.b7e0  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; PEEK low byte
.b7e2  a8         tay              	TAY				; copy to Y
.b7e3  e6 11      inc $11          	INC	Itempl		; increment pointer low byte
.b7e5  d0 02      bne $b7e9        	BNE	Deekh			; skip high increment if no rollover
.b7e7  e6 12      inc $12          	INC	Itemph		; increment pointer high byte
.b7e9                              deekh
.b7e9  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; PEEK high byte
.b7eb  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & return
.b7ee                              lab_doke
.b7ee  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.b7f1  20 b5 b7   jsr $b7b5        	JSR	LAB_F2FX		; convert floating-to-fixed
.b7f4  84 97      sty $97          	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
.b7f6  85 98      sta $98          	STA	Frnxth		; save pointer high byte
.b7f8  20 f0 ae   jsr $aef0        	JSR	LAB_1C01		; scan for "," , else do syntax error, then warm start
.b7fb  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.b7fe  20 b5 b7   jsr $b7b5        	JSR	LAB_F2FX		; convert floating-to-fixed
.b801  98         tya              	TYA				; copy value low byte (float to fixed returns word in AY)
.b802  a2 00      ldx #$00         	LDX	#$00			; clear index
.b804  81 97      sta ($97,x)      	STA	(Frnxtl,X)		; POKE low byte
.b806  e6 97      inc $97          	INC	Frnxtl		; increment pointer low byte
.b808  d0 02      bne $b80c        	BNE	Dokeh			; skip high increment if no rollover
.b80a  e6 98      inc $98          	INC	Frnxth		; increment pointer high byte
.b80c                              dokeh
.b80c  a5 12      lda $12          	LDA	Itemph		; get value high byte
.b80e  81 97      sta ($97,x)      	STA	(Frnxtl,X)		; POKE high byte
.b810  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory & return
.b813                              lab_swap
.b813  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get var1 address
.b816  85 97      sta $97          	STA	Lvarpl		; save var1 address low byte
.b818  84 98      sty $98          	STY	Lvarph		; save var1 address high byte
.b81a  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.b81c  48         pha              	PHA				; save data type flag
.b81d  20 f0 ae   jsr $aef0        	JSR	LAB_1C01		; scan for "," , else do syntax error, then warm start
.b820  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
.b823  68         pla              	PLA				; pull var1 data type flag
.b824  c5 5f      cmp $5f          	CMP	Dtypef		; compare with var2 data type
.b826  d0 10      bne $b838        	BNE	SwapErr		; exit if not both the same type
.b828  a0 03      ldy #$03         	LDY	#$03			; four bytes to swap (either value or descriptor+1)
.b82a                              swaplp
.b82a  b1 97      lda ($97),y      	LDA	(Lvarpl),Y		; get byte from var1
.b82c  48         pha              	PHA				; save var1 byte
.b82d  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get byte from var2
.b82f  91 97      sta ($97),y      	STA	(Lvarpl),Y		; save byte to var1
.b831  68         pla              	PLA				; restore var1 byte
.b832  91 95      sta ($95),y      	STA	(Cvaral),Y		; save byte to var2
.b834  88         dey              	DEY				; decrement index
.b835  10 f3      bpl $b82a        	BPL	SwapLp		; loop until done
.b837  60         rts              	RTS
.b838                              swaperr
.b838  4c a8 ad   jmp $ada8        	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.b83b                              lab_call
.b83b  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.b83e  20 b5 b7   jsr $b7b5        	JSR	LAB_F2FX		; convert floating-to-fixed
.b841  a9 b8      lda #$b8         	LDA	#>CallExit		; set return address high byte
.b843  48         pha              	PHA				; put on stack
.b844  a9 49      lda #$49         	LDA	#<CallExit-1	; set return address low byte
.b846  48         pha              	PHA				; put on stack
.b847  6c 11 00   jmp ($0011)      	JMP	(Itempl)		; do indirect jump to user routine
.b84a                              callexit
.b84a  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory & return
.b84d                              lab_wait
.b84d  20 9c b7   jsr $b79c        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.b850  86 97      stx $97          	STX	Frnxtl		; save byte
.b852  a2 00      ldx #$00         	LDX	#$00			; clear mask
.b854  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.b857  f0 03      beq $b85c        	BEQ	LAB_2441		; skip if no third argument
.b859  20 a2 b7   jsr $b7a2        	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
.b85c                              lab_2441
.b85c  86 98      stx $98          	STX	Frnxth		; save EOR argument
.b85e                              lab_2445
.b85e  b1 11      lda ($11),y      	LDA	(Itempl),Y		; get byte via temporary integer (addr)
.b860  45 98      eor $98          	EOR	Frnxth		; EOR with second argument (mask)
.b862  25 97      and $97          	AND	Frnxtl		; AND with first argument (byte)
.b864  f0 f8      beq $b85e        	BEQ	LAB_2445		; loop if result is zero
.b866                              lab_244d
.b866  60         rts              	RTS				;
.b867                              lab_2455
.b867  20 4f ba   jsr $ba4f        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.b86a                              lab_subtract
.b86a  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.b86c  49 ff      eor #$ff         	EOR	#$FF			; complement it
.b86e  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.b870  45 b7      eor $b7          	EOR	FAC2_s		; EOR with FAC2 sign (b7)
.b872  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.b874  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.b876  4c 85 b8   jmp $b885        	JMP	LAB_ADD		; go add FAC2 to FAC1
.b879                              lab_2467
.b879  20 9e b9   jsr $b99e        	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
.b87c  90 4d      bcc $b8cb        	BCC	LAB_24A8		;.go subtract mantissas
.b87e                              lab_244e
.b87e  a9 b2      lda #$b2         	LDA	#<LAB_2A96		; set 0.5 pointer low byte
.b880  a0 c4      ldy #$c4         	LDY	#>LAB_2A96		; set 0.5 pointer high byte
.b882                              lab_246c
.b882  20 4f ba   jsr $ba4f        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.b885                              lab_add
.b885  d0 10      bne $b897        	BNE	LAB_2474		; branch if FAC1 was not zero
.b887                              lab_279b
.b887  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.b889                              lab_279d
.b889  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.b88b  a2 04      ldx #$04         	LDX	#$04			; 4 bytes to copy
.b88d                              lab_27a1
.b88d  b5 b2      lda $b2,x        	LDA	FAC1_o,X		; get byte from FAC2,X
.b88f  95 ab      sta $ab,x        	STA	FAC1_e-1,X		; save byte at FAC1,X
.b891  ca         dex              	DEX				; decrement count
.b892  d0 f9      bne $b88d        	BNE	LAB_27A1		; loop if not all done
.b894  86 b9      stx $b9          	STX	FAC1_r		; clear FAC1 rounding byte
.b896  60         rts              	RTS
.b897                              lab_2474
.b897  a6 b9      ldx $b9          	LDX	FAC1_r		; get FAC1 rounding byte
.b899  86 a3      stx $a3          	STX	FAC2_r		; save as FAC2 rounding byte
.b89b  a2 b3      ldx #$b3         	LDX	#FAC2_e		; set index to FAC2 exponent addr
.b89d  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.b89f                              lab_247c
.b89f  a8         tay              	TAY				; copy exponent
.b8a0  f0 c4      beq $b866        	BEQ	LAB_244D		; exit if zero
.b8a2  38         sec              	SEC				; set carry for subtract
.b8a3  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent
.b8a5  f0 24      beq $b8cb        	BEQ	LAB_24A8		; branch if = (go add mantissa)
.b8a7  90 12      bcc $b8bb        	BCC	LAB_2498		; branch if <
.b8a9  84 ac      sty $ac          	STY	FAC1_e		; save FAC1 exponent
.b8ab  a4 b7      ldy $b7          	LDY	FAC2_s		; get FAC2 sign (b7)
.b8ad  84 b0      sty $b0          	STY	FAC1_s		; save FAC1 sign (b7)
.b8af  49 ff      eor #$ff         	EOR	#$FF			; complement A
.b8b1  69 00      adc #$00         	ADC	#$00			; +1 (twos complement, carry is set)
.b8b3  a0 00      ldy #$00         	LDY	#$00			; clear Y
.b8b5  84 a3      sty $a3          	STY	FAC2_r		; clear FAC2 rounding byte
.b8b7  a2 ac      ldx #$ac         	LDX	#FAC1_e		; set index to FAC1 exponent addr
.b8b9  d0 04      bne $b8bf        	BNE	LAB_249C		; branch always
.b8bb                              lab_2498
.b8bb  a0 00      ldy #$00         	LDY	#$00			; clear Y
.b8bd  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.b8bf                              lab_249c
.b8bf  c9 f9      cmp #$f9         	CMP	#$F9			; compare exponent diff with $F9
.b8c1  30 b6      bmi $b879        	BMI	LAB_2467		; branch if range $79-$F8
.b8c3  a8         tay              	TAY				; copy exponent difference to Y
.b8c4  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.b8c6  56 01      lsr $01,x        	LSR	PLUS_1,X		; shift FAC? mantissa1
.b8c8  20 b5 b9   jsr $b9b5        	JSR	LAB_2592		; shift FACX Y times right
.b8cb                              lab_24a8
.b8cb  24 b8      bit $b8          	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
.b8cd  10 4c      bpl $b91b        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa & ret'n
.b8cf  a0 ac      ldy #$ac         	LDY	#FAC1_e		; set index to FAC1 exponent addr
.b8d1  e0 b3      cpx #$b3         	CPX	#FAC2_e		; compare X to FAC2 exponent addr
.b8d3  f0 02      beq $b8d7        	BEQ	LAB_24B4		; branch if =
.b8d5  a0 b3      ldy #$b3         	LDY	#FAC2_e		; else set index to FAC2 exponent addr
.b8d7                              lab_24b4
.b8d7  38         sec              	SEC				; set carry for subtract
.b8d8  49 ff      eor #$ff         	EOR	#$FF			; ones complement A
.b8da  65 a3      adc $a3          	ADC	FAC2_r		; add FAC2 rounding byte
.b8dc  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.b8de  b9 03 00   lda $0003,y      	LDA	PLUS_3,Y		; get FACY mantissa3
.b8e1  f5 03      sbc $03,x        	SBC	PLUS_3,X		; subtract FACX mantissa3
.b8e3  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.b8e5  b9 02 00   lda $0002,y      	LDA	PLUS_2,Y		; get FACY mantissa2
.b8e8  f5 02      sbc $02,x        	SBC	PLUS_2,X		; subtract FACX mantissa2
.b8ea  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.b8ec  b9 01 00   lda $0001,y      	LDA	PLUS_1,Y		; get FACY mantissa1
.b8ef  f5 01      sbc $01,x        	SBC	PLUS_1,X		; subtract FACX mantissa1
.b8f1  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.b8f3                              lab_24d0
.b8f3  b0 03      bcs $b8f8        	BCS	LAB_24D5		; branch if number is +ve
.b8f5  20 5a b9   jsr $b95a        	JSR	LAB_2537		; negate FAC1
.b8f8                              lab_24d5
.b8f8  a0 00      ldy #$00         	LDY	#$00			; clear Y
.b8fa  98         tya              	TYA				; clear A
.b8fb  18         clc              	CLC				; clear carry for add
.b8fc                              lab_24d9
.b8fc  a6 ad      ldx $ad          	LDX	FAC1_1		; get FAC1 mantissa1
.b8fe  d0 3e      bne $b93e        	BNE	LAB_251B		; if not zero normalise FAC1
.b900  a6 ae      ldx $ae          	LDX	FAC1_2		; get FAC1 mantissa2
.b902  86 ad      stx $ad          	STX	FAC1_1		; save FAC1 mantissa1
.b904  a6 af      ldx $af          	LDX	FAC1_3		; get FAC1 mantissa3
.b906  86 ae      stx $ae          	STX	FAC1_2		; save FAC1 mantissa2
.b908  a6 b9      ldx $b9          	LDX	FAC1_r		; get FAC1 rounding byte
.b90a  86 af      stx $af          	STX	FAC1_3		; save FAC1 mantissa3
.b90c  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.b90e  69 08      adc #$08         	ADC	#$08			; add x to exponent offset
.b910  c9 18      cmp #$18         	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
.b912  d0 e8      bne $b8fc        	BNE	LAB_24D9		; loop if not max
.b914                              lab_24f1
.b914  a9 00      lda #$00         	LDA	#$00			; clear A
.b916                              lab_24f3
.b916  85 ac      sta $ac          	STA	FAC1_e		; set FAC1 exponent
.b918                              lab_24f5
.b918  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.b91a  60         rts              	RTS				;
.b91b                              lab_24f8
.b91b  65 a3      adc $a3          	ADC	FAC2_r		; add FAC2 rounding byte
.b91d  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.b91f  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.b921  65 b6      adc $b6          	ADC	FAC2_3		; add FAC2 mantissa3
.b923  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.b925  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.b927  65 b5      adc $b5          	ADC	FAC2_2		; add FAC2 mantissa2
.b929  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.b92b  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.b92d  65 b4      adc $b4          	ADC	FAC2_1		; add FAC2 mantissa1
.b92f  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.b931  b0 1a      bcs $b94d        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
.b933  60         rts              	RTS				; else just exit
.b934                              lab_2511
.b934  69 01      adc #$01         	ADC	#$01			; add 1 to exponent offset
.b936  06 b9      asl $b9          	ASL	FAC1_r		; shift FAC1 rounding byte
.b938  26 af      rol $af          	ROL	FAC1_3		; shift FAC1 mantissa3
.b93a  26 ae      rol $ae          	ROL	FAC1_2		; shift FAC1 mantissa2
.b93c  26 ad      rol $ad          	ROL	FAC1_1		; shift FAC1 mantissa1
.b93e                              lab_251b
.b93e  10 f4      bpl $b934        	BPL	LAB_2511		; loop if not normalised
.b940  38         sec              	SEC				; set carry for subtract
.b941  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent
.b943  b0 cf      bcs $b914        	BCS	LAB_24F1		; branch if underflow (set result = $0)
.b945  49 ff      eor #$ff         	EOR	#$FF			; complement exponent
.b947  69 01      adc #$01         	ADC	#$01			; +1 (twos complement)
.b949  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.b94b                              lab_2528
.b94b  90 0c      bcc $b959        	BCC	LAB_2536		; exit if no overflow
.b94d                              lab_252a
.b94d  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent
.b94f  f0 36      beq $b987        	BEQ	LAB_2564		; if zero do overflow error & warm start
.b951  66 ad      ror $ad          	ROR	FAC1_1		; shift FAC1 mantissa1
.b953  66 ae      ror $ae          	ROR	FAC1_2		; shift FAC1 mantissa2
.b955  66 af      ror $af          	ROR	FAC1_3		; shift FAC1 mantissa3
.b957  66 b9      ror $b9          	ROR	FAC1_r		; shift FAC1 rounding byte
.b959                              lab_2536
.b959  60         rts              	RTS				;
.b95a                              lab_2537
.b95a  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.b95c  49 ff      eor #$ff         	EOR	#$FF			; complement it
.b95e  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.b960                              lab_253d
.b960  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.b962  49 ff      eor #$ff         	EOR	#$FF			; complement it
.b964  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.b966  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.b968  49 ff      eor #$ff         	EOR	#$FF			; complement it
.b96a  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.b96c  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.b96e  49 ff      eor #$ff         	EOR	#$FF			; complement it
.b970  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.b972  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.b974  49 ff      eor #$ff         	EOR	#$FF			; complement it
.b976  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.b978  e6 b9      inc $b9          	INC	FAC1_r		; increment FAC1 rounding byte
.b97a  d0 0a      bne $b986        	BNE	LAB_2563		; exit if no overflow
.b97c                              lab_2559
.b97c  e6 af      inc $af          	INC	FAC1_3		; increment FAC1 mantissa3
.b97e  d0 06      bne $b986        	BNE	LAB_2563		; finished if no rollover
.b980  e6 ae      inc $ae          	INC	FAC1_2		; increment FAC1 mantissa2
.b982  d0 02      bne $b986        	BNE	LAB_2563		; finished if no rollover
.b984  e6 ad      inc $ad          	INC	FAC1_1		; increment FAC1 mantissa1
.b986                              lab_2563
.b986  60         rts              	RTS				;
.b987                              lab_2564
.b987  a2 0a      ldx #$0a         	LDX	#$0A			; error code $0A ("Overflow" error)
.b989  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.b98c                              lab_2569
.b98c  a2 74      ldx #$74         	LDX	#$74			; set offset to FACtemp
.b98e                              lab_256b
.b98e  b4 03      ldy $03,x        	LDY	PLUS_3,X		; get FACX mantissa3
.b990  84 b9      sty $b9          	STY	FAC1_r		; save as FAC1 rounding byte
.b992  b4 02      ldy $02,x        	LDY	PLUS_2,X		; get FACX mantissa2
.b994  94 03      sty $03,x        	STY	PLUS_3,X		; save FACX mantissa3
.b996  b4 01      ldy $01,x        	LDY	PLUS_1,X		; get FACX mantissa1
.b998  94 02      sty $02,x        	STY	PLUS_2,X		; save FACX mantissa2
.b99a  a4 b2      ldy $b2          	LDY	FAC1_o		; get FAC1 overflow byte
.b99c  94 01      sty $01,x        	STY	PLUS_1,X		; save FACX mantissa1
.b99e                              lab_257b
.b99e  69 08      adc #$08         	ADC	#$08			; add 8 to shift count
.b9a0  30 ec      bmi $b98e        	BMI	LAB_256B		; go do 8 shift if still -ve
.b9a2  f0 ea      beq $b98e        	BEQ	LAB_256B		; go do 8 shift if zero
.b9a4  e9 08      sbc #$08         	SBC	#$08			; else subtract 8 again
.b9a6  a8         tay              	TAY				; save count to Y
.b9a7  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.b9a9  b0 12      bcs $b9bd        	BCS	LAB_259A		;.
.b9ab                              lab_2588
.b9ab  16 01      asl $01,x        	ASL	PLUS_1,X		; shift FACX mantissa1
.b9ad  90 02      bcc $b9b1        	BCC	LAB_258E		; branch if +ve
.b9af  f6 01      inc $01,x        	INC	PLUS_1,X		; this sets b7 eventually
.b9b1                              lab_258e
.b9b1  76 01      ror $01,x        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
.b9b3  76 01      ror $01,x        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
.b9b5                              lab_2592
.b9b5  76 02      ror $02,x        	ROR	PLUS_2,X		; shift FACX mantissa2
.b9b7  76 03      ror $03,x        	ROR	PLUS_3,X		; shift FACX mantissa3
.b9b9  6a         ror              	ROR	A			; shift FACX rounding byte
.b9ba  c8         iny              	INY				; increment exponent diff
.b9bb  d0 ee      bne $b9ab        	BNE	LAB_2588		; branch if range adjust not complete
.b9bd                              lab_259a
.b9bd  18         clc              	CLC				; just clear it
.b9be  60         rts              	RTS				;
.b9bf                              lab_log
.b9bf  20 b3 bb   jsr $bbb3        	JSR	LAB_27CA		; test sign and zero
.b9c2  f0 02      beq $b9c6        	BEQ	LAB_25C4		; if zero do function call error, then warm start
.b9c4  10 03      bpl $b9c9        	BPL	LAB_25C7		; skip error if +ve
.b9c6                              lab_25c4
.b9c6  4c f9 b1   jmp $b1f9        	JMP	LAB_FCER		; do function call error, then warm start (-ve)
.b9c9                              lab_25c7
.b9c9  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.b9cb  e9 7f      sbc #$7f         	SBC	#$7F			; normalise it
.b9cd  48         pha              	PHA				; save it
.b9ce  a9 80      lda #$80         	LDA	#$80			; set exponent to zero
.b9d0  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.b9d2  a9 32      lda #$32         	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
.b9d4  a0 c4      ldy #$c4         	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
.b9d6  20 82 b8   jsr $b882        	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
.b9d9  a9 36      lda #$36         	LDA	#<LAB_25B1		; set root2 pointer low byte
.b9db  a0 c4      ldy #$c4         	LDY	#>LAB_25B1		; set root2 pointer high byte
.b9dd  20 c5 ba   jsr $bac5        	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
.b9e0  a9 a9      lda #$a9         	LDA	#<LAB_259C		; set 1 pointer low byte
.b9e2  a0 c4      ldy #$c4         	LDY	#>LAB_259C		; set 1 pointer high byte
.b9e4  20 67 b8   jsr $b867        	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
.b9e7  a9 25      lda #$25         	LDA	#<LAB_25A0		; set pointer low byte to counter
.b9e9  a0 c4      ldy #$c4         	LDY	#>LAB_25A0		; set pointer high byte to counter
.b9eb  20 17 bf   jsr $bf17        	JSR	LAB_2B6E		; ^2 then series evaluation
.b9ee  a9 3a      lda #$3a         	LDA	#<LAB_25B5		; set -0.5 pointer low byte
.b9f0  a0 c4      ldy #$c4         	LDY	#>LAB_25B5		; set -0.5 pointer high byte
.b9f2  20 82 b8   jsr $b882        	JSR	LAB_246C		; add (AY) to FAC1
.b9f5  68         pla              	PLA				; restore FAC1 exponent
.b9f6  20 0e bd   jsr $bd0e        	JSR	LAB_2912		; evaluate new ASCII digit
.b9f9  a9 3e      lda #$3e         	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
.b9fb  a0 c4      ldy #$c4         	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
.b9fd                              lab_25fb
.b9fd  20 4f ba   jsr $ba4f        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.ba00                              lab_multiply
.ba00  f0 4c      beq $ba4e        	BEQ	LAB_264C		; exit if zero
.ba02                              lab_2600
.ba02  20 75 ba   jsr $ba75        	JSR	LAB_2673		; test & adjust accumulators
.ba05  a9 00      lda #$00         	LDA	#$00			; clear A
.ba07  85 75      sta $75          	STA	FACt_1		; clear temp mantissa1
.ba09  85 76      sta $76          	STA	FACt_2		; clear temp mantissa2
.ba0b  85 77      sta $77          	STA	FACt_3		; clear temp mantissa3
.ba0d  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.ba0f  20 24 ba   jsr $ba24        	JSR	LAB_2622		; go do shift/add FAC2
.ba12  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.ba14  20 24 ba   jsr $ba24        	JSR	LAB_2622		; go do shift/add FAC2
.ba17  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.ba19  20 24 ba   jsr $ba24        	JSR	LAB_2622		; go do shift/add FAC2
.ba1c  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.ba1e  20 29 ba   jsr $ba29        	JSR	LAB_2627		; go do shift/add FAC2
.ba21  4c 35 bb   jmp $bb35        	JMP	LAB_273C		; copy temp to FAC1, normalise & return
.ba24                              lab_2622
.ba24  d0 03      bne $ba29        	BNE	LAB_2627		; branch if byte <> zero
.ba26  4c 8c b9   jmp $b98c        	JMP	LAB_2569		; shift FCAtemp << A+8 times
.ba29                              lab_2627
.ba29  4a         lsr              	LSR	A			; shift byte
.ba2a  09 80      ora #$80         	ORA	#$80			; set top bit (mark for 8 times)
.ba2c                              lab_262a
.ba2c  a8         tay              	TAY				; copy result
.ba2d  90 13      bcc $ba42        	BCC	LAB_2640		; skip next if bit was zero
.ba2f  18         clc              	CLC				; clear carry for add
.ba30  a5 77      lda $77          	LDA	FACt_3		; get temp mantissa3
.ba32  65 b6      adc $b6          	ADC	FAC2_3		; add FAC2 mantissa3
.ba34  85 77      sta $77          	STA	FACt_3		; save temp mantissa3
.ba36  a5 76      lda $76          	LDA	FACt_2		; get temp mantissa2
.ba38  65 b5      adc $b5          	ADC	FAC2_2		; add FAC2 mantissa2
.ba3a  85 76      sta $76          	STA	FACt_2		; save temp mantissa2
.ba3c  a5 75      lda $75          	LDA	FACt_1		; get temp mantissa1
.ba3e  65 b4      adc $b4          	ADC	FAC2_1		; add FAC2 mantissa1
.ba40  85 75      sta $75          	STA	FACt_1		; save temp mantissa1
.ba42                              lab_2640
.ba42  66 75      ror $75          	ROR	FACt_1		; shift temp mantissa1
.ba44  66 76      ror $76          	ROR	FACt_2		; shift temp mantissa2
.ba46  66 77      ror $77          	ROR	FACt_3		; shift temp mantissa3
.ba48  66 b9      ror $b9          	ROR	FAC1_r		; shift temp rounding byte
.ba4a  98         tya              	TYA				; get byte back
.ba4b  4a         lsr              	LSR	A			; shift byte
.ba4c  d0 de      bne $ba2c        	BNE	LAB_262A		; loop if all bits not done
.ba4e                              lab_264c
.ba4e  60         rts              	RTS				;
.ba4f                              lab_264d
.ba4f  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.ba51  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.ba53  a0 03      ldy #$03         	LDY	#$03			; 4 bytes to get (0-3)
.ba55  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa3
.ba57  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.ba59  88         dey              	DEY				; decrement index
.ba5a  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa2
.ba5c  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.ba5e  88         dey              	DEY				; decrement index
.ba5f  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa1+sign
.ba61  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign (b7)
.ba63  45 b0      eor $b0          	EOR	FAC1_s		; EOR with FAC1 sign (b7)
.ba65  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.ba67  a5 b7      lda $b7          	LDA	FAC2_s		; recover FAC2 sign (b7)
.ba69  09 80      ora #$80         	ORA	#$80			; set 1xxx xxx (set normal bit)
.ba6b  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.ba6d  88         dey              	DEY				; decrement index
.ba6e  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get exponent byte
.ba70  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.ba72  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.ba74  60         rts              	RTS				;
.ba75                              lab_2673
.ba75  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.ba77                              lab_2675
.ba77  f0 1d      beq $ba96        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
.ba79  18         clc              	CLC				; clear carry for add
.ba7a  65 ac      adc $ac          	ADC	FAC1_e		; add FAC1 exponent
.ba7c  90 04      bcc $ba82        	BCC	LAB_2680		; branch if sum of exponents <$0100
.ba7e  30 31      bmi $bab1        	BMI	LAB_269B		; do overflow error
.ba80  18         clc              	CLC				; clear carry for the add

>ba81  2c                          	.byte	$2C			; makes next line BIT $1410
.ba82                              lab_2680

.ba82  10 12      bpl $ba96        	BPL	LAB_2696		; if +ve go handle underflow
.ba84  69 80      adc #$80         	ADC	#$80			; adjust exponent
.ba86  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.ba88  d0 03      bne $ba8d        	BNE	LAB_268B		; branch if not zero
.ba8a  4c 18 b9   jmp $b918        	JMP	LAB_24F5		; save FAC1 sign & return
.ba8d                              lab_268b
.ba8d  a5 b8      lda $b8          	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
.ba8f  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.ba91                              lab_268f
.ba91  60         rts              	RTS				;
.ba92                              lab_2690
.ba92  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.ba94  10 1b      bpl $bab1        	BPL	LAB_269B		; do overflow error
.ba96                              lab_2696
.ba96  68         pla              	PLA				; pop return address low byte
.ba97  68         pla              	PLA				; pop return address high byte
.ba98  4c 14 b9   jmp $b914        	JMP	LAB_24F1		; clear FAC1 exponent & sign & return
.ba9b                              lab_269e
.ba9b  20 94 bb   jsr $bb94        	JSR	LAB_27AB		; round & copy FAC1 to FAC2
.ba9e  aa         tax              	TAX				; copy exponent (set the flags)
.ba9f  f0 f0      beq $ba91        	BEQ	LAB_268F		; exit if zero
.baa1  18         clc              	CLC				; clear carry for add
.baa2  69 02      adc #$02         	ADC	#$02			; add two to exponent (*4)
.baa4  b0 0b      bcs $bab1        	BCS	LAB_269B		; do overflow error if > $FF
.baa6  a2 00      ldx #$00         	LDX	#$00			; clear byte
.baa8  86 b8      stx $b8          	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.baaa  20 9f b8   jsr $b89f        	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
.baad  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent (*10)
.baaf  d0 e0      bne $ba91        	BNE	LAB_268F		; if non zero just do RTS
.bab1                              lab_269b
.bab1  4c 87 b9   jmp $b987        	JMP	LAB_2564		; do overflow error & warm start
.bab4                              lab_26b9
.bab4  20 94 bb   jsr $bb94        	JSR	LAB_27AB		; round & copy FAC1 to FAC2
.bab7  a9 ba      lda #$ba         	LDA	#<LAB_26B5		; set pointer to 10d low addr
.bab9  a0 c4      ldy #$c4         	LDY	#>LAB_26B5		; set pointer to 10d high addr
.babb  a2 00      ldx #$00         	LDX	#$00			; clear sign
.babd                              lab_26c2
.babd  86 b8      stx $b8          	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.babf  20 44 bb   jsr $bb44        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.bac2  4c c8 ba   jmp $bac8        	JMP	LAB_DIVIDE		; do FAC2/FAC1
.bac5                              lab_26ca
.bac5  20 4f ba   jsr $ba4f        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.bac8                              lab_divide
.bac8  f0 66      beq $bb30        	BEQ	LAB_2737		; if zero go do /0 error
.baca  20 a3 bb   jsr $bba3        	JSR	LAB_27BA		; round FAC1
.bacd  a9 00      lda #$00         	LDA	#$00			; clear A
.bacf  38         sec              	SEC				; set carry for subtract
.bad0  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
.bad2  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.bad4  20 75 ba   jsr $ba75        	JSR	LAB_2673		; test & adjust accumulators
.bad7  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent
.bad9  f0 d6      beq $bab1        	BEQ	LAB_269B		; if zero do overflow error
.badb  a2 fd      ldx #$fd         	LDX	#$FD			; set index to FACt
.badd  a9 01      lda #$01         	LDA	#$01			;.set byte
.badf                              lab_26e4
.badf  a4 b4      ldy $b4          	LDY	FAC2_1		; get FAC2 mantissa1
.bae1  c4 ad      cpy $ad          	CPY	FAC1_1		; compare FAC1 mantissa1
.bae3  d0 0a      bne $baef        	BNE	LAB_26F4		; branch if <>
.bae5  a4 b5      ldy $b5          	LDY	FAC2_2		; get FAC2 mantissa2
.bae7  c4 ae      cpy $ae          	CPY	FAC1_2		; compare FAC1 mantissa2
.bae9  d0 04      bne $baef        	BNE	LAB_26F4		; branch if <>
.baeb  a4 b6      ldy $b6          	LDY	FAC2_3		; get FAC2 mantissa3
.baed  c4 af      cpy $af          	CPY	FAC1_3		; compare FAC1 mantissa3
.baef                              lab_26f4
.baef  08         php              	PHP				; save FAC2-FAC1 compare status
.baf0  2a         rol              	ROL	A			;.shift byte
.baf1  90 0a      bcc $bafd        	BCC	LAB_2702		; skip next if no carry
.baf3  e8         inx              	INX				; increment index to FACt
.baf4  f0 2a      beq $bb20        	BEQ	LAB_2727		;.
.baf6  10 2c      bpl $bb24        	BPL	LAB_272B		;.
.baf8  a0 01      ldy #$01         	LDY	#$01			;.
.bafa                              lab_2701
.bafa  95 77      sta $77,x        	STA	FACt_3,X		; write result byte to FACt_3+X (-2, -1, 0)
.bafc  98         tya              	TYA
.bafd                              lab_2702
.bafd  28         plp              	PLP				; restore FAC2-FAC1 compare status
.bafe  90 14      bcc $bb14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip subtract
.bb00  a8         tay              	TAY				; save FAC2-FAC1 compare status
.bb01  a5 b6      lda $b6          	LDA	FAC2_3		; get FAC2 mantissa3
.bb03  e5 af      sbc $af          	SBC	FAC1_3		; subtract FAC1 mantissa3
.bb05  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.bb07  a5 b5      lda $b5          	LDA	FAC2_2		; get FAC2 mantissa2
.bb09  e5 ae      sbc $ae          	SBC	FAC1_2		; subtract FAC1 mantissa2
.bb0b  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.bb0d  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.bb0f  e5 ad      sbc $ad          	SBC	FAC1_1		; subtract FAC1 mantissa1
.bb11  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.bb13  98         tya              	TYA				; restore FAC2-FAC1 compare status
.bb14                              lab_2704
.bb14  06 b6      asl $b6          	ASL	FAC2_3		; shift FAC2 mantissa3
.bb16  26 b5      rol $b5          	ROL	FAC2_2		; shift FAC2 mantissa2
.bb18  26 b4      rol $b4          	ROL	FAC2_1		; shift FAC2 mantissa1
.bb1a  b0 d3      bcs $baef        	BCS	LAB_26F4		; loop with no compare
.bb1c  30 c1      bmi $badf        	BMI	LAB_26E4		; loop with compare
.bb1e  10 cf      bpl $baef        	BPL	LAB_26F4		; loop always with no compare
.bb20                              lab_2727
.bb20  a0 40      ldy #$40         	LDY	#$40			; 
.bb22  d0 d6      bne $bafa        	BNE	LAB_2701		; branch always
.bb24                              lab_272b
.bb24  0a         asl              	ASL	A			; 
.bb25  0a         asl              	ASL	A			; 
.bb26  0a         asl              	ASL	A			; 
.bb27  0a         asl              	ASL	A			; 
.bb28  0a         asl              	ASL	A			; 
.bb29  0a         asl              	ASL	A			; 
.bb2a  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.bb2c  28         plp              	PLP				; dump FAC2-FAC1 compare status
.bb2d  4c 35 bb   jmp $bb35        	JMP	LAB_273C		; copy temp to FAC1, normalise & return
.bb30                              lab_2737
.bb30  a2 14      ldx #$14         	LDX	#$14			; error code $14 ("Divide by zero" error)
.bb32  4c 3e a4   jmp $a43e        	JMP	LAB_XERR		; do error #X, then warm start
.bb35                              lab_273c
.bb35  a5 75      lda $75          	LDA	FACt_1		; get temp mantissa1
.bb37  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.bb39  a5 76      lda $76          	LDA	FACt_2		; get temp mantissa2
.bb3b  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.bb3d  a5 77      lda $77          	LDA	FACt_3		; get temp mantissa3
.bb3f  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.bb41  4c f8 b8   jmp $b8f8        	JMP	LAB_24D5		; normalise FAC1 & return
.bb44                              lab_ufac
.bb44  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.bb46  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.bb48  a0 03      ldy #$03         	LDY	#$03			; 4 bytes to do
.bb4a  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get last byte
.bb4c  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.bb4e  88         dey              	DEY				; decrement index
.bb4f  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get last-1 byte
.bb51  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.bb53  88         dey              	DEY				; decrement index
.bb54  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get second byte
.bb56  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.bb58  09 80      ora #$80         	ORA	#$80			; set 1xxx xxxx (add normal bit)
.bb5a  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.bb5c  88         dey              	DEY				; decrement index
.bb5d  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get first byte (exponent)
.bb5f  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.bb61  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.bb63  60         rts              	RTS				;
.bb64                              lab_276b
.bb64  a2 a8      ldx #$a8         	LDX	#<numexp		; set pointer low byte

>bb66  2c                          	.byte	$2C			; makes next line BIT LAB_14A2
.bb67                              lab_276e

.bb67  a2 a4      ldx #$a4         	LDX	#<Adatal		; set pointer low byte
.bb69  a0 00      ldy #$00         	LDY	#>Adatal		; set pointer high byte
.bb6b  f0 04      beq $bb71        	BEQ	LAB_2778		; pack FAC1 into (XY) & RET
.bb6d                              lab_pfac
.bb6d  a6 97      ldx $97          	LDX	Lvarpl		; get destination pointer low byte
.bb6f  a4 98      ldy $98          	LDY	Lvarph		; get destination pointer high byte
.bb71                              lab_2778
.bb71  20 a3 bb   jsr $bba3        	JSR	LAB_27BA		; round FAC1
.bb74  86 71      stx $71          	STX	ut1_pl		; save pointer low byte
.bb76  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.bb78  a0 03      ldy #$03         	LDY	#$03			; set index
.bb7a  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.bb7c  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.bb7e  88         dey              	DEY				; decrement index
.bb7f  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.bb81  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.bb83  88         dey              	DEY				; decrement index
.bb84  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.bb86  09 7f      ora #$7f         	ORA	#$7F			; set bits x111 1111
.bb88  25 ad      and $ad          	AND	FAC1_1		; AND in FAC1 mantissa1
.bb8a  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.bb8c  88         dey              	DEY				; decrement index
.bb8d  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bb8f  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.bb91  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.bb93  60         rts              	RTS				;
.bb94                              lab_27ab
.bb94  20 a3 bb   jsr $bba3        	JSR	LAB_27BA		; round FAC1
.bb97                              lab_27ae
.bb97  a2 05      ldx #$05         	LDX	#$05			; 5 bytes to copy
.bb99                              lab_27b0
.bb99  b5 ab      lda $ab,x        	LDA	FAC1_e-1,X		; get byte from FAC1,X
.bb9b  95 b2      sta $b2,x        	STA	FAC1_o,X		; save byte at FAC2,X
.bb9d  ca         dex              	DEX				; decrement count
.bb9e  d0 f9      bne $bb99        	BNE	LAB_27B0		; loop if not all done
.bba0  86 b9      stx $b9          	STX	FAC1_r		; clear FAC1 rounding byte
.bba2                              lab_27b9
.bba2  60         rts              	RTS				;
.bba3                              lab_27ba
.bba3  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bba5  f0 fb      beq $bba2        	BEQ	LAB_27B9		; exit if zero
.bba7  06 b9      asl $b9          	ASL	FAC1_r		; shift FAC1 rounding byte
.bba9  90 f7      bcc $bba2        	BCC	LAB_27B9		; exit if no overflow
.bbab                              lab_27c2
.bbab  20 7c b9   jsr $b97c        	JSR	LAB_2559		; increment FAC1 mantissa
.bbae  d0 f2      bne $bba2        	BNE	LAB_27B9		; branch if no overflow
.bbb0  4c 4d b9   jmp $b94d        	JMP	LAB_252A		; normalise FAC1 for C=1 & return
.bbb3                              lab_27ca
.bbb3  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bbb5  f0 09      beq $bbc0        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
.bbb7                              lab_27ce
.bbb7  a5 b0      lda $b0          	LDA	FAC1_s		; else get FAC1 sign (b7)
.bbb9                              lab_27d0
.bbb9  2a         rol              	ROL	A			; move sign bit to carry
.bbba  a9 ff      lda #$ff         	LDA	#$FF			; set byte for -ve result
.bbbc  b0 02      bcs $bbc0        	BCS	LAB_27D7		; return if sign was set (-ve)
.bbbe  a9 01      lda #$01         	LDA	#$01			; else set byte for +ve result
.bbc0                              lab_27d7
.bbc0  60         rts              	RTS				;
.bbc1                              lab_sgn
.bbc1  20 b3 bb   jsr $bbb3        	JSR	LAB_27CA		; get FAC1 sign
.bbc4                              lab_27db
.bbc4  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.bbc6  a9 00      lda #$00         	LDA	#$00			; clear A
.bbc8  85 ae      sta $ae          	STA	FAC1_2		; clear FAC1 mantissa2
.bbca  a2 88      ldx #$88         	LDX	#$88			; set exponent
.bbcc                              lab_27e3
.bbcc  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.bbce  49 ff      eor #$ff         	EOR	#$FF			; complement it
.bbd0  2a         rol              	ROL	A			; sign bit into carry
.bbd1                              lab_stfa
.bbd1  a9 00      lda #$00         	LDA	#$00			; clear A
.bbd3  85 af      sta $af          	STA	FAC1_3		; clear FAC1 mantissa3
.bbd5  86 ac      stx $ac          	STX	FAC1_e		; set FAC1 exponent
.bbd7  85 b9      sta $b9          	STA	FAC1_r		; clear FAC1 rounding byte
.bbd9  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.bbdb  4c f3 b8   jmp $b8f3        	JMP	LAB_24D0		; do ABS & normalise FAC1
.bbde                              lab_abs
.bbde  46 b0      lsr $b0          	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
.bbe0  60         rts              	RTS				;
.bbe1                              lab_27f8
.bbe1  85 73      sta $73          	STA	ut2_pl		; save pointer low byte
.bbe3                              lab_27fa
.bbe3  84 74      sty $74          	STY	ut2_ph		; save pointer high byte
.bbe5  a0 00      ldy #$00         	LDY	#$00			; clear index
.bbe7  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get exponent
.bbe9  c8         iny              	INY				; increment index
.bbea  aa         tax              	TAX				; copy (AY) exponent to X
.bbeb  f0 c6      beq $bbb3        	BEQ	LAB_27CA		; branch if (AY) exponent=0 & get FAC1 sign
.bbed  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.bbef  45 b0      eor $b0          	EOR	FAC1_s		; EOR FAC1 sign (b7)
.bbf1  30 c4      bmi $bbb7        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
.bbf3  e4 ac      cpx $ac          	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
.bbf5  d0 1a      bne $bc11        	BNE	LAB_2828		; branch if different
.bbf7  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.bbf9  09 80      ora #$80         	ORA	#$80			; normalise top bit
.bbfb  c5 ad      cmp $ad          	CMP	FAC1_1		; compare with FAC1 mantissa1
.bbfd  d0 12      bne $bc11        	BNE	LAB_2828		; branch if different
.bbff  c8         iny              	INY				; increment index
.bc00  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get mantissa2
.bc02  c5 ae      cmp $ae          	CMP	FAC1_2		; compare with FAC1 mantissa2
.bc04  d0 0b      bne $bc11        	BNE	LAB_2828		; branch if different
.bc06  c8         iny              	INY				; increment index
.bc07  a9 7f      lda #$7f         	LDA	#$7F			; set for 1/2 value rounding byte
.bc09  c5 b9      cmp $b9          	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
.bc0b  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get mantissa3
.bc0d  e5 af      sbc $af          	SBC	FAC1_3		; subtract FAC1 mantissa3
.bc0f  f0 28      beq $bc39        	BEQ	LAB_2850		; exit if mantissa3 equal
.bc11                              lab_2828
.bc11  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.bc13  90 02      bcc $bc17        	BCC	LAB_282E		; branch if FAC1 > (AY)
.bc15  49 ff      eor #$ff         	EOR	#$FF			; else toggle FAC1 sign
.bc17                              lab_282e
.bc17  4c b9 bb   jmp $bbb9        	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
.bc1a                              lab_2831
.bc1a  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bc1c  f0 4a      beq $bc68        	BEQ	LAB_287F		; if zero go clear FAC1 & return
.bc1e  38         sec              	SEC				; set carry for subtract
.bc1f  e9 98      sbc #$98         	SBC	#$98			; subtract maximum integer range exponent
.bc21  24 b0      bit $b0          	BIT	FAC1_s		; test FAC1 sign (b7)
.bc23  10 09      bpl $bc2e        	BPL	LAB_2845		; branch if FAC1 +ve
.bc25  aa         tax              	TAX				; copy subtracted exponent
.bc26  a9 ff      lda #$ff         	LDA	#$FF			; overflow for -ve number
.bc28  85 b2      sta $b2          	STA	FAC1_o		; set FAC1 overflow byte
.bc2a  20 60 b9   jsr $b960        	JSR	LAB_253D		; twos complement FAC1 mantissa
.bc2d  8a         txa              	TXA				; restore subtracted exponent
.bc2e                              lab_2845
.bc2e  a2 ac      ldx #$ac         	LDX	#FAC1_e		; set index to FAC1
.bc30  c9 f9      cmp #$f9         	CMP	#$F9			; compare exponent result
.bc32  10 06      bpl $bc3a        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right & ret
.bc34  20 9e b9   jsr $b99e        	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
.bc37  84 b2      sty $b2          	STY	FAC1_o		; clear FAC1 overflow byte
.bc39                              lab_2850
.bc39  60         rts              	RTS				;
.bc3a                              lab_2851
.bc3a  a8         tay              	TAY				; copy shift count
.bc3b  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.bc3d  29 80      and #$80         	AND	#$80			; mask sign bit only (x000 0000)
.bc3f  46 ad      lsr $ad          	LSR	FAC1_1		; shift FAC1 mantissa1
.bc41  05 ad      ora $ad          	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
.bc43  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.bc45  20 b5 b9   jsr $b9b5        	JSR	LAB_2592		; shift FAC1 Y times right
.bc48  84 b2      sty $b2          	STY	FAC1_o		; clear FAC1 overflow byte
.bc4a  60         rts              	RTS				;
.bc4b                              lab_int
.bc4b  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bc4d  c9 98      cmp #$98         	CMP	#$98			; compare with max int
.bc4f  b0 1e      bcs $bc6f        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
.bc51  20 1a bc   jsr $bc1a        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.bc54  84 b9      sty $b9          	STY	FAC1_r		; save FAC1 rounding byte
.bc56  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.bc58  84 b0      sty $b0          	STY	FAC1_s		; save FAC1 sign (b7)
.bc5a  49 80      eor #$80         	EOR	#$80			; toggle FAC1 sign
.bc5c  2a         rol              	ROL	A			; shift into carry
.bc5d  a9 98      lda #$98         	LDA	#$98			; set new exponent
.bc5f  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.bc61  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.bc63  85 5b      sta $5b          	STA	Temp3			; 
.bc65  4c f3 b8   jmp $b8f3        	JMP	LAB_24D0		; do ABS & normalise FAC1
.bc68                              lab_287f
.bc68  85 ad      sta $ad          	STA	FAC1_1		; clear FAC1 mantissa1
.bc6a  85 ae      sta $ae          	STA	FAC1_2		; clear FAC1 mantissa2
.bc6c  85 af      sta $af          	STA	FAC1_3		; clear FAC1 mantissa3
.bc6e  a8         tay              	TAY				; clear Y
.bc6f                              lab_2886
.bc6f  60         rts              	RTS				;
.bc70                              lab_2887
.bc70  a0 00      ldy #$00         	LDY	#$00			; clear Y
.bc72  a2 09      ldx #$09         	LDX	#$09			; set index
.bc74                              lab_288b
.bc74  94 a8      sty $a8,x        	STY	numexp,X		; clear byte
.bc76  ca         dex              	DEX				; decrement index
.bc77  10 fb      bpl $bc74        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
.bc79  90 7f      bcc $bcfa        	BCC	LAB_28FE		; branch if 1st character numeric
.bc7b  c9 2d      cmp #$2d         	CMP	#"-"			; else compare with "-"
.bc7d  d0 04      bne $bc83        	BNE	LAB_289A		; branch if not "-"
.bc7f  86 b1      stx $b1          	STX	negnum		; set flag for -ve number (X = $FF)
.bc81  f0 04      beq $bc87        	BEQ	LAB_289C		; branch always (go scan & check for hex/bin)
.bc83                              lab_289a
.bc83  c9 2b      cmp #$2b         	CMP	#"+"			; else compare with "+"
.bc85  d0 05      bne $bc8c        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
.bc87                              lab_289c
.bc87  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.bc8a  90 6e      bcc $bcfa        	BCC	LAB_28FE		; branch if numeric character
.bc8c                              lab_289d
.bc8c  c9 24      cmp #$24         	CMP	#"$"			; else compare with "$"
.bc8e  d0 03      bne $bc93        	BNE	LAB_NHEX		; branch if not "$"
.bc90  4c 30 c1   jmp $c130        	JMP	LAB_CHEX		; branch if "$"
.bc93                              lab_nhex
.bc93  c9 25      cmp #$25         	CMP	#"%"			; else compare with "%"
.bc95  d0 08      bne $bc9f        	BNE	LAB_28A3		; branch if not "%" (continue original code)
.bc97  4c 5e c1   jmp $c15e        	JMP	LAB_CBIN		; branch if "%"
.bc9a                              lab_289e
.bc9a  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory (ignore + or get next number)
.bc9d                              lab_28a1
.bc9d  90 5b      bcc $bcfa        	BCC	LAB_28FE		; branch if numeric character
.bc9f                              lab_28a3
.bc9f  c9 2e      cmp #$2e         	CMP	#"."			; else compare with "."
.bca1  f0 2e      beq $bcd1        	BEQ	LAB_28D5		; branch if "."
.bca3  c9 45      cmp #$45         	CMP	#"E"			; else compare with "E"
.bca5  d0 30      bne $bcd7        	BNE	LAB_28DB		; branch if not "E"
.bca7  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.bcaa  90 17      bcc $bcc3        	BCC	LAB_28C7		; branch if numeric character
.bcac  c9 b6      cmp #$b6         	CMP	#TK_MINUS		; else compare with token for -
.bcae  f0 0e      beq $bcbe        	BEQ	LAB_28C2		; branch if token for -
.bcb0  c9 2d      cmp #$2d         	CMP	#"-"			; else compare with "-"
.bcb2  f0 0a      beq $bcbe        	BEQ	LAB_28C2		; branch if "-"
.bcb4  c9 b5      cmp #$b5         	CMP	#TK_PLUS		; else compare with token for +
.bcb6  f0 08      beq $bcc0        	BEQ	LAB_28C4		; branch if token for +
.bcb8  c9 2b      cmp #$2b         	CMP	#"+"			; else compare with "+"
.bcba  f0 04      beq $bcc0        	BEQ	LAB_28C4		; branch if "+"
.bcbc  d0 07      bne $bcc5        	BNE	LAB_28C9		; branch always
.bcbe                              lab_28c2
.bcbe  66 ab      ror $ab          	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
.bcc0                              lab_28c4
.bcc0  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.bcc3                              lab_28c7
.bcc3  90 5c      bcc $bd21        	BCC	LAB_2925		; branch if numeric character
.bcc5                              lab_28c9
.bcc5  24 ab      bit $ab          	BIT	expneg		; test exponent -ve flag
.bcc7  10 0e      bpl $bcd7        	BPL	LAB_28DB		; if +ve go evaluate exponent
.bcc9  a9 00      lda #$00         	LDA	#$00			; clear result
.bccb  38         sec              	SEC				; set carry for subtract
.bccc  e5 a9      sbc $a9          	SBC	expcnt		; subtract exponent byte
.bcce  4c d9 bc   jmp $bcd9        	JMP	LAB_28DD		; go evaluate exponent
.bcd1                              lab_28d5
.bcd1  66 aa      ror $aa          	ROR	numdpf		; set decimal point flag
.bcd3  24 aa      bit $aa          	BIT	numdpf		; test decimal point flag
.bcd5  50 c3      bvc $bc9a        	BVC	LAB_289E		; branch if only one decimal point so far
.bcd7                              lab_28db
.bcd7  a5 a9      lda $a9          	LDA	expcnt		; get exponent count byte
.bcd9                              lab_28dd
.bcd9  38         sec              	SEC				; set carry for subtract
.bcda  e5 a8      sbc $a8          	SBC	numexp		; subtract numerator exponent
.bcdc  85 a9      sta $a9          	STA	expcnt		; save exponent count byte
.bcde  f0 12      beq $bcf2        	BEQ	LAB_28F6		; branch if no adjustment
.bce0  10 09      bpl $bceb        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
.bce2                              lab_28e6
.bce2  20 b4 ba   jsr $bab4        	JSR	LAB_26B9		; divide by 10
.bce5  e6 a9      inc $a9          	INC	expcnt		; increment exponent count byte
.bce7  d0 f9      bne $bce2        	BNE	LAB_28E6		; loop until all done
.bce9  f0 07      beq $bcf2        	BEQ	LAB_28F6		; branch always
.bceb                              lab_28ef
.bceb  20 9b ba   jsr $ba9b        	JSR	LAB_269E		; multiply by 10
.bcee  c6 a9      dec $a9          	DEC	expcnt		; decrement exponent count byte
.bcf0  d0 f9      bne $bceb        	BNE	LAB_28EF		; loop until all done
.bcf2                              lab_28f6
.bcf2  a5 b1      lda $b1          	LDA	negnum		; get -ve flag
.bcf4  30 01      bmi $bcf7        	BMI	LAB_28FB		; if -ve do - FAC1 & return
.bcf6  60         rts              	RTS				;
.bcf7                              lab_28fb
.bcf7  4c ba be   jmp $beba        	JMP	LAB_GTHAN		; do - FAC1 & return
.bcfa                              lab_28fe
.bcfa  48         pha              	PHA				; save character
.bcfb  24 aa      bit $aa          	BIT	numdpf		; test decimal point flag
.bcfd  10 02      bpl $bd01        	BPL	LAB_2905		; skip exponent increment if not set
.bcff  e6 a8      inc $a8          	INC	numexp		; else increment number exponent
.bd01                              lab_2905
.bd01  20 9b ba   jsr $ba9b        	JSR	LAB_269E		; multiply FAC1 by 10
.bd04  68         pla              	PLA				; restore character
.bd05  38         sec              	SEC				; set carry for subtract
.bd06  e9 30      sbc #$30         	SBC	#$30			; convert to binary
.bd08  20 0e bd   jsr $bd0e        	JSR	LAB_2912		; evaluate new ASCII digit
.bd0b  4c 9a bc   jmp $bc9a        	JMP	LAB_289E		; go do next character
.bd0e                              lab_2912
.bd0e  48         pha              	PHA				; save digit
.bd0f  20 94 bb   jsr $bb94        	JSR	LAB_27AB		; round & copy FAC1 to FAC2
.bd12  68         pla              	PLA				; restore digit
.bd13  20 c4 bb   jsr $bbc4        	JSR	LAB_27DB		; save A as integer byte
.bd16  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.bd18  45 b0      eor $b0          	EOR	FAC1_s		; toggle with FAC1 sign (b7)
.bd1a  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.bd1c  a6 ac      ldx $ac          	LDX	FAC1_e		; get FAC1 exponent
.bd1e  4c 85 b8   jmp $b885        	JMP	LAB_ADD		; add FAC2 to FAC1 & return
.bd21                              lab_2925
.bd21  a5 a9      lda $a9          	LDA	expcnt		; get exponent count byte
.bd23  c9 0a      cmp #$0a         	CMP	#$0A			; compare with 10 decimal
.bd25  90 09      bcc $bd30        	BCC	LAB_2934		; branch if less
.bd27  a9 64      lda #$64         	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
.bd29  24 ab      bit $ab          	BIT	expneg		; test exponent -ve flag
.bd2b  30 0e      bmi $bd3b        	BMI	LAB_2942		; branch if -ve
.bd2d  4c 87 b9   jmp $b987        	JMP	LAB_2564		; else do overflow error
.bd30                              lab_2934
.bd30  0a         asl              	ASL	A			; *2
.bd31  0a         asl              	ASL	A			; *4
.bd32  65 a9      adc $a9          	ADC	expcnt		; *5
.bd34  0a         asl              	ASL	A			; *10
.bd35  a0 00      ldy #$00         	LDY	#$00			; set index
.bd37  71 c3      adc ($c3),y      	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
.bd39  e9 2f      sbc #$2f         	SBC	#$2F			; convert character to binary
.bd3b                              lab_2942
.bd3b  85 a9      sta $a9          	STA	expcnt		; save exponent count byte
.bd3d  4c c0 bc   jmp $bcc0        	JMP	LAB_28C4		; go get next character
.bd40                              lab_2953
.bd40  a9 47      lda #$47         	LDA	#<LAB_LMSG		; point to " in line" message low byte
.bd42  a0 ca      ldy #$ca         	LDY	#>LAB_LMSG		; point to " in line" message high byte
.bd44  20 58 bd   jsr $bd58        	JSR	LAB_296B		; print null terminated string
.bd47  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.bd49  a6 87      ldx $87          	LDX	Clinel		; get current line low byte
.bd4b                              lab_295e
.bd4b  85 ad      sta $ad          	STA	FAC1_1		; save low byte as FAC1 mantissa1
.bd4d  86 ae      stx $ae          	STX	FAC1_2		; save high byte as FAC1 mantissa2
.bd4f  a2 90      ldx #$90         	LDX	#$90			; set exponent to 16d bits
.bd51  38         sec              	SEC				; set integer is +ve flag
.bd52  20 d1 bb   jsr $bbd1        	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 & normalise
.bd55  20 5b bd   jsr $bd5b        	JSR	LAB_296E		; convert FAC1 to string
.bd58                              lab_296b
.bd58  4c a4 ab   jmp $aba4        	JMP	LAB_18C3		; print null terminated string from memory & RET
.bd5b                              lab_296e
.bd5b  a0 01      ldy #$01         	LDY	#$01			; set index = 1
.bd5d                              lab_2970
.bd5d  a9 20      lda #$20         	LDA	#$20			; character = " " (assume +ve)
.bd5f  24 b0      bit $b0          	BIT	FAC1_s		; test FAC1 sign (b7)
.bd61  10 02      bpl $bd65        	BPL	LAB_2978		; branch if +ve
.bd63  a9 2d      lda #$2d         	LDA	#$2D			; else character = "-"
.bd65                              lab_2978
.bd65  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save leading character (" " or "-")
.bd68  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.bd6a  84 ba      sty $ba          	STY	Sendl			; save index
.bd6c  c8         iny              	INY				; increment index
.bd6d  a6 ac      ldx $ac          	LDX	FAC1_e		; get FAC1 exponent
.bd6f  d0 05      bne $bd76        	BNE	LAB_2989		; branch if FAC1<>0
.bd71  a9 30      lda #$30         	LDA	#$30			; set character = "0"
.bd73  4c 74 be   jmp $be74        	JMP	LAB_2A89		; save last character, [EOT] & exit
.bd76                              lab_2989
.bd76  a9 00      lda #$00         	LDA	#$00			; clear (number exponent count)
.bd78  e0 81      cpx #$81         	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
.bd7a  b0 09      bcs $bd85        	BCS	LAB_299A		; branch if FAC1=>1
.bd7c  a9 4a      lda #$4a         	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
.bd7e  a0 c4      ldy #$c4         	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
.bd80  20 fd b9   jsr $b9fd        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.bd83  a9 fa      lda #$fa         	LDA	#$FA			; set number exponent count (-6)
.bd85                              lab_299a
.bd85  85 a8      sta $a8          	STA	numexp		; save number exponent count
.bd87                              lab_299c
.bd87  a9 46      lda #$46         	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
.bd89  a0 c4      ldy #$c4         	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
.bd8b  20 e1 bb   jsr $bbe1        	JSR	LAB_27F8		; compare FAC1 with (AY)
.bd8e  f0 1e      beq $bdae        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
.bd90  10 12      bpl $bda4        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
.bd92                              lab_29a7
.bd92  a9 42      lda #$42         	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
.bd94  a0 c4      ldy #$c4         	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
.bd96  20 e1 bb   jsr $bbe1        	JSR	LAB_27F8		; compare FAC1 with (AY)
.bd99  f0 02      beq $bd9d        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
.bd9b  10 0e      bpl $bdab        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
.bd9d                              lab_29b2
.bd9d  20 9b ba   jsr $ba9b        	JSR	LAB_269E		; multiply by 10
.bda0  c6 a8      dec $a8          	DEC	numexp		; decrement number exponent count
.bda2  d0 ee      bne $bd92        	BNE	LAB_29A7		; go test again (branch always)
.bda4                              lab_29b9
.bda4  20 b4 ba   jsr $bab4        	JSR	LAB_26B9		; divide by 10
.bda7  e6 a8      inc $a8          	INC	numexp		; increment number exponent count
.bda9  d0 dc      bne $bd87        	BNE	LAB_299C		; go test again (branch always)
.bdab                              lab_29c0
.bdab  20 7e b8   jsr $b87e        	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
.bdae                              lab_29c3
.bdae  20 1a bc   jsr $bc1a        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.bdb1  a2 01      ldx #$01         	LDX	#$01			; set default digits before dp = 1
.bdb3  a5 a8      lda $a8          	LDA	numexp		; get number exponent count
.bdb5  18         clc              	CLC				; clear carry for add
.bdb6  69 07      adc #$07         	ADC	#$07			; up to 6 digits before point
.bdb8  30 09      bmi $bdc3        	BMI	LAB_29D8		; if -ve then 1 digit before dp
.bdba  c9 08      cmp #$08         	CMP	#$08			; A>=8 if n>=1E6
.bdbc  b0 06      bcs $bdc4        	BCS	LAB_29D9		; branch if >= $08
.bdbe  69 ff      adc #$ff         	ADC	#$FF			; take 1 from digit count
.bdc0  aa         tax              	TAX				; copy to A
.bdc1  a9 02      lda #$02         	LDA	#$02			;.set exponent adjust
.bdc3                              lab_29d8
.bdc3  38         sec              	SEC				; set carry for subtract
.bdc4                              lab_29d9
.bdc4  e9 02      sbc #$02         	SBC	#$02			; -2
.bdc6  85 a9      sta $a9          	STA	expcnt		;.save exponent adjust
.bdc8  86 a8      stx $a8          	STX	numexp		; save digits before dp count
.bdca  8a         txa              	TXA				; copy to A
.bdcb  f0 02      beq $bdcf        	BEQ	LAB_29E4		; branch if no digits before dp
.bdcd  10 13      bpl $bde2        	BPL	LAB_29F7		; branch if digits before dp
.bdcf                              lab_29e4
.bdcf  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.bdd1  a9 2e      lda #$2e         	LDA	#$2E			; character "."
.bdd3  c8         iny              	INY				; increment index
.bdd4  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.bdd7  8a         txa              	TXA				; 
.bdd8  f0 06      beq $bde0        	BEQ	LAB_29F5		; 
.bdda  a9 30      lda #$30         	LDA	#$30			; character "0"
.bddc  c8         iny              	INY				; increment index
.bddd  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.bde0                              lab_29f5
.bde0  84 ba      sty $ba          	STY	Sendl			; save output string index
.bde2                              lab_29f7
.bde2  a0 00      ldy #$00         	LDY	#$00			; clear index (point to 100,000)
.bde4  a2 80      ldx #$80         	LDX	#$80			; 
.bde6                              lab_29fb
.bde6  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.bde8  18         clc              	CLC				; clear carry for add
.bde9  79 c0 c4   adc $c4c0,y      	ADC	LAB_2A9C,Y		; add -ve LSB
.bdec  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.bdee  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.bdf0  79 bf c4   adc $c4bf,y      	ADC	LAB_2A9B,Y		; add -ve NMSB
.bdf3  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.bdf5  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.bdf7  79 be c4   adc $c4be,y      	ADC	LAB_2A9A,Y		; add -ve MSB
.bdfa  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.bdfc  e8         inx              	INX				; 
.bdfd  b0 04      bcs $be03        	BCS	LAB_2A18		; 
.bdff  10 e5      bpl $bde6        	BPL	LAB_29FB		; not -ve so try again
.be01  30 02      bmi $be05        	BMI	LAB_2A1A		; 
.be03                              lab_2a18
.be03  30 e1      bmi $bde6        	BMI	LAB_29FB		; 
.be05                              lab_2a1a
.be05  8a         txa              	TXA				; 
.be06  90 04      bcc $be0c        	BCC	LAB_2A21		; 
.be08  49 ff      eor #$ff         	EOR	#$FF			; 
.be0a  69 0a      adc #$0a         	ADC	#$0A			; 
.be0c                              lab_2a21
.be0c  69 2f      adc #$2f         	ADC	#$2F			; add "0"-1 to result
.be0e  c8         iny              	INY				; increment index ..
.be0f  c8         iny              	INY				; .. to next less ..
.be10  c8         iny              	INY				; .. power of ten
.be11  84 95      sty $95          	STY	Cvaral		; save as current var address low byte
.be13  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.be15  c8         iny              	INY				; increment output string index
.be16  aa         tax              	TAX				; copy character to X
.be17  29 7f      and #$7f         	AND	#$7F			; mask out top bit
.be19  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.be1c  c6 a8      dec $a8          	DEC	numexp		; decrement # of characters before the dp
.be1e  d0 06      bne $be26        	BNE	LAB_2A3B		; branch if still characters to do
.be20  a9 2e      lda #$2e         	LDA	#$2E			; character "."
.be22  c8         iny              	INY				; increment output string index
.be23  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.be26                              lab_2a3b
.be26  84 ba      sty $ba          	STY	Sendl			; save output string index
.be28  a4 95      ldy $95          	LDY	Cvaral		; get current var address low byte
.be2a  8a         txa              	TXA				; get character back
.be2b  49 ff      eor #$ff         	EOR	#$FF			; 
.be2d  29 80      and #$80         	AND	#$80			; 
.be2f  aa         tax              	TAX				; 
.be30  c0 12      cpy #$12         	CPY	#$12			; compare index with max
.be32  d0 b2      bne $bde6        	BNE	LAB_29FB		; loop if not max
.be34  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.be36                              lab_2a4b
.be36  b9 ef 00   lda $00ef,y      	LDA	Decss,Y		; get character from output string
.be39  88         dey              	DEY				; decrement output string index
.be3a  c9 30      cmp #$30         	CMP	#$30			; compare with "0"
.be3c  f0 f8      beq $be36        	BEQ	LAB_2A4B		; loop until non "0" character found
.be3e  c9 2e      cmp #$2e         	CMP	#$2E			; compare with "."
.be40  f0 01      beq $be43        	BEQ	LAB_2A58		; branch if was dp
.be42  c8         iny              	INY				; increment output string index
.be43                              lab_2a58
.be43  a9 2b      lda #$2b         	LDA	#$2B			; character "+"
.be45  a6 a9      ldx $a9          	LDX	expcnt		; get exponent count
.be47  f0 2e      beq $be77        	BEQ	LAB_2A8C		; if zero go set null terminator & exit
.be49  10 08      bpl $be53        	BPL	LAB_2A68		; branch if exponent count +ve
.be4b  a9 00      lda #$00         	LDA	#$00			; clear A
.be4d  38         sec              	SEC				; set carry for subtract
.be4e  e5 a9      sbc $a9          	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
.be50  aa         tax              	TAX				; copy exponent count to X
.be51  a9 2d      lda #$2d         	LDA	#$2D			; character "-"
.be53                              lab_2a68
.be53  99 f1 00   sta $00f1,y      	STA	Decss+2,Y		; save to output string
.be56  a9 45      lda #$45         	LDA	#$45			; character "E"
.be58  99 f0 00   sta $00f0,y      	STA	Decss+1,Y		; save exponent sign to output string
.be5b  8a         txa              	TXA				; get exponent count back
.be5c  a2 2f      ldx #$2f         	LDX	#$2F			; one less than "0" character
.be5e  38         sec              	SEC				; set carry for subtract
.be5f                              lab_2a74
.be5f  e8         inx              	INX				; increment 10's character
.be60  e9 0a      sbc #$0a         	SBC	#$0A			;.subtract 10 from exponent count
.be62  b0 fb      bcs $be5f        	BCS	LAB_2A74		; loop while still >= 0
.be64  69 3a      adc #$3a         	ADC	#$3A			; add character ":" ($30+$0A, result is 10 less that value)
.be66  99 f3 00   sta $00f3,y      	STA	Decss+4,Y		; save to output string
.be69  8a         txa              	TXA				; copy 10's character
.be6a  99 f2 00   sta $00f2,y      	STA	Decss+3,Y		; save to output string
.be6d  a9 00      lda #$00         	LDA	#$00			; set null terminator
.be6f  99 f4 00   sta $00f4,y      	STA	Decss+5,Y		; save to output string
.be72  f0 08      beq $be7c        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
.be74                              lab_2a89
.be74  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save last character to output string
.be77                              lab_2a8c
.be77  a9 00      lda #$00         	LDA	#$00			; set null terminator
.be79  99 f0 00   sta $00f0,y      	STA	Decss+1,Y		; save after last character
.be7c                              lab_2a91
.be7c  a9 f0      lda #$f0         	LDA	#<(Decss+1)		; set result string low pointer
.be7e  a0 00      ldy #$00         	LDY	#>(Decss+1)		; set result string high pointer
.be80  60         rts              	RTS				;
.be81                              lab_power
.be81  f0 42      beq $bec5        	BEQ	LAB_EXP		; go do  EXP()
.be83  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.be85  d0 03      bne $be8a        	BNE	LAB_2ABF		; branch if FAC2<>0
.be87  4c 16 b9   jmp $b916        	JMP	LAB_24F3		; clear FAC1 exponent & sign & return
.be8a                              lab_2abf
.be8a  a2 9c      ldx #$9c         	LDX	#<func_l		; set destination pointer low byte
.be8c  a0 00      ldy #$00         	LDY	#>func_l		; set destination pointer high byte
.be8e  20 71 bb   jsr $bb71        	JSR	LAB_2778		; pack FAC1 into (XY)
.be91  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.be93  10 0f      bpl $bea4        	BPL	LAB_2AD9		; branch if FAC2>0
.be95  20 4b bc   jsr $bc4b        	JSR	LAB_INT		; perform INT
.be98  a9 9c      lda #$9c         	LDA	#<func_l		; set source pointer low byte
.be9a  a0 00      ldy #$00         	LDY	#>func_l		; set source pointer high byte
.be9c  20 e1 bb   jsr $bbe1        	JSR	LAB_27F8		; compare FAC1 with (AY)
.be9f  d0 03      bne $bea4        	BNE	LAB_2AD9		; branch if FAC1 <> (AY)
.bea1  98         tya              	TYA				; copy sign to A
.bea2  a4 5b      ldy $5b          	LDY	Temp3			;
.bea4                              lab_2ad9
.bea4  20 89 b8   jsr $b889        	JSR	LAB_279D		; save FAC1 sign & copy ABS(FAC2) to FAC1
.bea7  98         tya              	TYA				; 
.bea8  48         pha              	PHA				; 
.bea9  20 bf b9   jsr $b9bf        	JSR	LAB_LOG		; do LOG(n)
.beac  a9 9c      lda #$9c         	LDA	#<garb_l		; set pointer low byte
.beae  a0 00      ldy #$00         	LDY	#>garb_l		; set pointer high byte
.beb0  20 fd b9   jsr $b9fd        	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
.beb3  20 c5 be   jsr $bec5        	JSR	LAB_EXP		; go do EXP(n)
.beb6  68         pla              	PLA				; 
.beb7  4a         lsr              	LSR	A			; 
.beb8  90 0a      bcc $bec4        	BCC	LAB_2AF9		; if no bit then exit
.beba                              lab_gthan
.beba  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bebc  f0 06      beq $bec4        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
.bebe  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.bec0  49 ff      eor #$ff         	EOR	#$FF			; complement it
.bec2  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.bec4                              lab_2af9
.bec4  60         rts              	RTS				;
.bec5                              lab_exp
.bec5  a9 4e      lda #$4e         	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
.bec7  a0 c4      ldy #$c4         	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
.bec9  20 fd b9   jsr $b9fd        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.becc  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.bece  69 50      adc #$50         	ADC	#$50			; +$50/$100
.bed0  90 03      bcc $bed5        	BCC	LAB_2B2B		; skip rounding if no carry
.bed2  20 ab bb   jsr $bbab        	JSR	LAB_27C2		; round FAC1 (no check)
.bed5                              lab_2b2b
.bed5  85 a3      sta $a3          	STA	FAC2_r		; save FAC2 rounding byte
.bed7  20 97 bb   jsr $bb97        	JSR	LAB_27AE		; copy FAC1 to FAC2
.beda  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bedc  c9 88      cmp #$88         	CMP	#$88			; compare with EXP limit (256d)
.bede  90 03      bcc $bee3        	BCC	LAB_2B39		; branch if less
.bee0                              lab_2b36
.bee0  20 92 ba   jsr $ba92        	JSR	LAB_2690		; handle overflow and underflow
.bee3                              lab_2b39
.bee3  20 4b bc   jsr $bc4b        	JSR	LAB_INT		; perform INT
.bee6  a5 5b      lda $5b          	LDA	Temp3			;.
.bee8  18         clc              	CLC				; clear carry for add
.bee9  69 81      adc #$81         	ADC	#$81			;.
.beeb  f0 f3      beq $bee0        	BEQ	LAB_2B36		;.
.beed  38         sec              	SEC				;.
.beee  e9 01      sbc #$01         	SBC	#$01			;.
.bef0  48         pha              	PHA				;.save FAC2 exponent
.bef1  a2 04      ldx #$04         	LDX	#$04			; 4 bytes to do
.bef3                              lab_2b49
.bef3  b5 b3      lda $b3,x        	LDA	FAC2_e,X		; get FAC2,X
.bef5  b4 ac      ldy $ac,x        	LDY	FAC1_e,X		; get FAC1,X
.bef7  95 ac      sta $ac,x        	STA	FAC1_e,X		; save FAC1,X
.bef9  94 b3      sty $b3,x        	STY	FAC2_e,X		; save FAC2,X
.befb  ca         dex              	DEX				; decrement count/index
.befc  10 f5      bpl $bef3        	BPL	LAB_2B49		; loop if not all done
.befe  a5 a3      lda $a3          	LDA	FAC2_r		; get FAC2 rounding byte
.bf00  85 b9      sta $b9          	STA	FAC1_r		; save as FAC1 rounding byte
.bf02  20 6a b8   jsr $b86a        	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.bf05  20 ba be   jsr $beba        	JSR	LAB_GTHAN		; do - FAC1
.bf08  a9 52      lda #$52         	LDA	#<LAB_2AFE		; set counter pointer low byte
.bf0a  a0 c4      ldy #$c4         	LDY	#>LAB_2AFE		; set counter pointer high byte
.bf0c  20 2d bf   jsr $bf2d        	JSR	LAB_2B84		; go do series evaluation
.bf0f  a9 00      lda #$00         	LDA	#$00			; clear A
.bf11  85 b8      sta $b8          	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.bf13  68         pla              	PLA				;.get saved FAC2 exponent
.bf14  4c 77 ba   jmp $ba77        	JMP	LAB_2675		; test & adjust accumulators & return
.bf17                              lab_2b6e
.bf17  85 ba      sta $ba          	STA	Cptrl			; save count pointer low byte
.bf19  84 bb      sty $bb          	STY	Cptrh			; save count pointer high byte
.bf1b  20 67 bb   jsr $bb67        	JSR	LAB_276E		; pack FAC1 into Adatal
.bf1e  a9 a4      lda #$a4         	LDA	#<Adatal		; set pointer low byte (Y already $00)
.bf20  20 fd b9   jsr $b9fd        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.bf23  20 31 bf   jsr $bf31        	JSR	LAB_2B88		; go do series evaluation
.bf26  a9 a4      lda #$a4         	LDA	#<Adatal		; pointer to original # low byte
.bf28  a0 00      ldy #$00         	LDY	#>Adatal		; pointer to original # high byte
.bf2a  4c fd b9   jmp $b9fd        	JMP	LAB_25FB		; do convert AY, FCA1*(AY) & return
.bf2d                              lab_2b84
.bf2d  85 ba      sta $ba          	STA	Cptrl			; save count pointer low byte
.bf2f  84 bb      sty $bb          	STY	Cptrh			; save count pointer high byte
.bf31                              lab_2b88
.bf31  20 64 bb   jsr $bb64        	JSR	LAB_276B		; pack FAC1 into numexp
.bf34  b1 ba      lda ($ba),y      	LDA	(Cptrl),Y		; get constants count
.bf36  85 b1      sta $b1          	STA	numcon		; save constants count
.bf38  a4 ba      ldy $ba          	LDY	Cptrl			; get count pointer low byte
.bf3a  c8         iny              	INY				; increment it (now constants pointer)
.bf3b  98         tya              	TYA				; copy it
.bf3c  d0 02      bne $bf40        	BNE	LAB_2B97		; skip next if no overflow
.bf3e  e6 bb      inc $bb          	INC	Cptrh			; else increment high byte
.bf40                              lab_2b97
.bf40  85 ba      sta $ba          	STA	Cptrl			; save low byte
.bf42  a4 bb      ldy $bb          	LDY	Cptrh			; get high byte
.bf44                              lab_2b9b
.bf44  20 fd b9   jsr $b9fd        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.bf47  a5 ba      lda $ba          	LDA	Cptrl			; get constants pointer low byte
.bf49  a4 bb      ldy $bb          	LDY	Cptrh			; get constants pointer high byte
.bf4b  18         clc              	CLC				; clear carry for add
.bf4c  69 04      adc #$04         	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
.bf4e  90 01      bcc $bf51        	BCC	LAB_2BA8		; skip next if no overflow
.bf50  c8         iny              	INY				; increment high byte
.bf51                              lab_2ba8
.bf51  85 ba      sta $ba          	STA	Cptrl			; save pointer low byte
.bf53  84 bb      sty $bb          	STY	Cptrh			; save pointer high byte
.bf55  20 82 b8   jsr $b882        	JSR	LAB_246C		; add (AY) to FAC1
.bf58  a9 a8      lda #$a8         	LDA	#<numexp		; set pointer low byte to partial @ numexp
.bf5a  a0 00      ldy #$00         	LDY	#>numexp		; set pointer high byte to partial @ numexp
.bf5c  c6 b1      dec $b1          	DEC	numcon		; decrement constants count
.bf5e  d0 e4      bne $bf44        	BNE	LAB_2B9B		; loop until all done
.bf60  60         rts              	RTS				;
.bf61                              lab_rnd
.bf61  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bf63  f0 07      beq $bf6c        	BEQ	NextPRN		; do next random # if zero
.bf65  a2 d4      ldx #$d4         	LDX	#Rbyte4		; set PRNG pointer low byte
.bf67  a0 00      ldy #$00         	LDY	#$00			; set PRNG pointer high byte
.bf69  20 71 bb   jsr $bb71        	JSR	LAB_2778		; pack FAC1 into (XY)
.bf6c                              nextprn
.bf6c  a2 00      ldx #$00         	LDX	#$00			; clear bit count
.bf6e  a5 d4      lda $d4          	LDA	Rbyte4		; get PRNG extra byte
.bf70  6a         ror              	ROR	A			; bit 32 -> carry
.bf71  6a         ror              	ROR	A			; bit 31 -> carry
.bf72  90 01      bcc $bf75        	BCC	Ninc1			; skip increment if =0
.bf74  e8         inx              	INX				; else increment bit count
.bf75                              ninc1
.bf75  29 08      and #$08         	AND	#$08			; mask bit 30 (bit 28 before shifts)
.bf77  f0 01      beq $bf7a        	BEQ	Ninc2			; skip increment if =0
.bf79  e8         inx              	INX				; else increment bit count
.bf7a                              ninc2
.bf7a  8a         txa              	TXA				; copy bit count to A
.bf7b  4a         lsr              	LSR	A			; shift b0 to carry
.bf7c  66 d5      ror $d5          	ROR	Rbyte1		; shift PRNG most significant byte
.bf7e  66 d7      ror $d7          	ROR	Rbyte3		; shift PRNG middle byte
.bf80  66 d6      ror $d6          	ROR	Rbyte2		; shift PRNG least significant byte
.bf82  66 d4      ror $d4          	ROR	Rbyte4		; shift PRNG extra byte
.bf84  a2 02      ldx #$02         	LDX	#$02			; three bytes to copy
.bf86                              copyprng
.bf86  b5 d5      lda $d5,x        	LDA	Rbyte1,X		; get PRNG byte
.bf88  95 ad      sta $ad,x        	STA	FAC1_1,X		; save FAC1 byte
.bf8a  ca         dex              	DEX
.bf8b  10 f9      bpl $bf86        	BPL	CopyPRNG		; loop if not complete
.bf8d  a9 80      lda #$80         	LDA	#$80			; set the exponent
.bf8f  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.bf91  0a         asl              	ASL				; clear A
.bf92  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign
.bf94  4c f8 b8   jmp $b8f8        	JMP	LAB_24D5		; normalise FAC1 & return
.bf97                              lab_cos
.bf97  a9 6f      lda #$6f         	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.bf99  a0 c4      ldy #$c4         	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.bf9b  20 82 b8   jsr $b882        	JSR	LAB_246C		; add (AY) to FAC1
.bf9e                              lab_sin
.bf9e  20 94 bb   jsr $bb94        	JSR	LAB_27AB		; round & copy FAC1 to FAC2
.bfa1  a9 84      lda #$84         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.bfa3  a0 c4      ldy #$c4         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.bfa5  a6 b7      ldx $b7          	LDX	FAC2_s		; get FAC2 sign (b7)
.bfa7  20 bd ba   jsr $babd        	JSR	LAB_26C2		; divide by (AY) (X=sign)
.bfaa  20 94 bb   jsr $bb94        	JSR	LAB_27AB		; round & copy FAC1 to FAC2
.bfad  20 4b bc   jsr $bc4b        	JSR	LAB_INT		; perform INT
.bfb0  a9 00      lda #$00         	LDA	#$00			; clear byte
.bfb2  85 b8      sta $b8          	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.bfb4  20 6a b8   jsr $b86a        	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.bfb7  a9 b6      lda #$b6         	LDA	#<LAB_2C80		; set 0.25 pointer low byte
.bfb9  a0 c4      ldy #$c4         	LDY	#>LAB_2C80		; set 0.25 pointer high byte
.bfbb  20 67 b8   jsr $b867        	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.bfbe  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.bfc0  48         pha              	PHA				; save FAC1 sign
.bfc1  10 0d      bpl $bfd0        	BPL	LAB_2C35		; branch if +ve
.bfc3  20 7e b8   jsr $b87e        	JSR	LAB_244E		; add 0.5 to FAC1
.bfc6  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.bfc8  30 09      bmi $bfd3        	BMI	LAB_2C38		; branch if -ve
.bfca  a5 63      lda $63          	LDA	Cflag			; get comparison evaluation flag
.bfcc  49 ff      eor #$ff         	EOR	#$FF			; toggle flag
.bfce  85 63      sta $63          	STA	Cflag			; save comparison evaluation flag
.bfd0                              lab_2c35
.bfd0  20 ba be   jsr $beba        	JSR	LAB_GTHAN		; do - FAC1
.bfd3                              lab_2c38
.bfd3  a9 b6      lda #$b6         	LDA	#<LAB_2C80		; set 0.25 pointer low byte
.bfd5  a0 c4      ldy #$c4         	LDY	#>LAB_2C80		; set 0.25 pointer high byte
.bfd7  20 82 b8   jsr $b882        	JSR	LAB_246C		; add (AY) to FAC1
.bfda  68         pla              	PLA				; restore FAC1 sign
.bfdb  10 03      bpl $bfe0        	BPL	LAB_2C45		; branch if was +ve
.bfdd  20 ba be   jsr $beba        	JSR	LAB_GTHAN		; do - FAC1
.bfe0                              lab_2c45
.bfe0  a9 73      lda #$73         	LDA	#<LAB_2C84		; set pointer low byte to counter
.bfe2  a0 c4      ldy #$c4         	LDY	#>LAB_2C84		; set pointer high byte to counter
.bfe4  4c 17 bf   jmp $bf17        	JMP	LAB_2B6E		; ^2 then series evaluation & RET
.bfe7                              lab_tan
.bfe7  20 67 bb   jsr $bb67        	JSR	LAB_276E		; pack FAC1 into Adatal
.bfea  a9 00      lda #$00         	LDA	#$00			; clear byte
.bfec  85 63      sta $63          	STA	Cflag			; clear comparison evaluation flag
.bfee  20 9e bf   jsr $bf9e        	JSR	LAB_SIN		; go do SIN(n)
.bff1  a2 9c      ldx #$9c         	LDX	#<func_l		; set sin(n) pointer low byte
.bff3  a0 00      ldy #$00         	LDY	#>func_l		; set sin(n) pointer high byte
.bff5  20 71 bb   jsr $bb71        	JSR	LAB_2778		; pack FAC1 into (XY)
.bff8  a9 a4      lda #$a4         	LDA	#<Adatal		; set n pointer low addr
.bffa  a0 00      ldy #$00         	LDY	#>Adatal		; set n pointer high addr
.bffc  20 44 bb   jsr $bb44        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.bfff  a9 00      lda #$00         	LDA	#$00			; clear byte
.c001  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.c003  a5 63      lda $63          	LDA	Cflag			; get comparison evaluation flag
.c005  20 0f c0   jsr $c00f        	JSR	LAB_2C74		; save flag and go do series evaluation
.c008  a9 9c      lda #$9c         	LDA	#<func_l		; set sin(n) pointer low byte
.c00a  a0 00      ldy #$00         	LDY	#>func_l		; set sin(n) pointer high byte
.c00c  4c c5 ba   jmp $bac5        	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
.c00f                              lab_2c74
.c00f  48         pha              	PHA				; save comparison evaluation flag
.c010  4c d0 bf   jmp $bfd0        	JMP	LAB_2C35		; go do series evaluation
.c013                              lab_atn
.c013  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.c015  48         pha              	PHA				; save sign
.c016  10 03      bpl $c01b        	BPL	LAB_2CA1		; branch if +ve
.c018  20 ba be   jsr $beba        	JSR	LAB_GTHAN		; else do - FAC1
.c01b                              lab_2ca1
.c01b  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c01d  48         pha              	PHA				; push exponent
.c01e  c9 81      cmp #$81         	CMP	#$81			; compare with 1
.c020  90 07      bcc $c029        	BCC	LAB_2CAF		; branch if FAC1<1
.c022  a9 a9      lda #$a9         	LDA	#<LAB_259C		; set 1 pointer low byte
.c024  a0 c4      ldy #$c4         	LDY	#>LAB_259C		; set 1 pointer high byte
.c026  20 c5 ba   jsr $bac5        	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
.c029                              lab_2caf
.c029  a9 88      lda #$88         	LDA	#<LAB_2CC9		; set pointer low byte to counter
.c02b  a0 c4      ldy #$c4         	LDY	#>LAB_2CC9		; set pointer high byte to counter
.c02d  20 17 bf   jsr $bf17        	JSR	LAB_2B6E		; ^2 then series evaluation
.c030  68         pla              	PLA				; restore old FAC1 exponent
.c031  c9 81      cmp #$81         	CMP	#$81			; compare with 1
.c033  90 07      bcc $c03c        	BCC	LAB_2CC2		; branch if FAC1<1
.c035  a9 6f      lda #$6f         	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.c037  a0 c4      ldy #$c4         	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.c039  20 67 b8   jsr $b867        	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.c03c                              lab_2cc2
.c03c  68         pla              	PLA				; restore FAC1 sign
.c03d  10 16      bpl $c055        	BPL	LAB_2D04		; exit if was +ve
.c03f  4c ba be   jmp $beba        	JMP	LAB_GTHAN		; else do - FAC1 & return
.c042                              lab_bitset
.c042  20 9c b7   jsr $b79c        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.c045  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.c047  b0 20      bcs $c069        	BCS	FCError		; branch if > 7
.c049  a9 00      lda #$00         	LDA	#$00			; clear A
.c04b  38         sec              	SEC				; set the carry
.c04c                              s_bits
.c04c  2a         rol              	ROL	A			; shift bit
.c04d  ca         dex              	DEX				; decrement bit number
.c04e  10 fc      bpl $c04c        	BPL	S_Bits		; loop if still +ve
.c050  e8         inx              	INX				; make X = $00
.c051  01 11      ora ($11,x)      	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
.c053  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.c055                              lab_2d04
.c055  60         rts              	RTS				;
.c056                              lab_bitclr
.c056  20 9c b7   jsr $b79c        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.c059  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.c05b  b0 0c      bcs $c069        	BCS	FCError		; branch if > 7
.c05d  a9 ff      lda #$ff         	LDA	#$FF			; set A
.c05f                              s_bitc
.c05f  2a         rol              	ROL	A			; shift bit
.c060  ca         dex              	DEX				; decrement bit number
.c061  10 fc      bpl $c05f        	BPL	S_Bitc		; loop if still +ve
.c063  e8         inx              	INX				; make X = $00
.c064  21 11      and ($11,x)      	AND	(Itempl,X)		; and with byte via temporary integer (addr)
.c066  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.c068  60         rts              	RTS				;
.c069                              fcerror
.c069  4c f9 b1   jmp $b1f9        	JMP	LAB_FCER		; do function call error, then warm start
.c06c                              lab_btst
.c06c  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.c06f  20 9c b7   jsr $b79c        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.c072  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.c074  b0 f3      bcs $c069        	BCS	FCError		; branch if > 7
.c076  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.c079  c9 29      cmp #$29         	CMP	#")"			; is next character ")"
.c07b  f0 03      beq $c080        	BEQ	TST_OK		; if ")" go do rest of function
.c07d  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; do syntax error, then warm start
.c080                              tst_ok
.c080  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.c083  a9 00      lda #$00         	LDA	#$00			; clear A
.c085  38         sec              	SEC				; set the carry
.c086                              t_bits
.c086  2a         rol              	ROL	A			; shift bit
.c087  ca         dex              	DEX				; decrement bit number
.c088  10 fc      bpl $c086        	BPL	T_Bits		; loop if still +ve
.c08a  e8         inx              	INX				; make X = $00
.c08b  21 11      and ($11,x)      	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
.c08d  f0 02      beq $c091        	BEQ	LAB_NOTT		; branch if zero (already correct)
.c08f  a9 ff      lda #$ff         	LDA	#$FF			; set for -1 result
.c091                              lab_nott
.c091  4c c4 bb   jmp $bbc4        	JMP	LAB_27DB		; go do SGN tail
.c094                              lab_bins
.c094  e0 19      cpx #$19         	CPX	#$19			; max + 1
.c096  b0 4a      bcs $c0e2        	BCS	BinFErr		; exit if too big ( > or = )
.c098  86 78      stx $78          	STX	TempB			; save # of characters ($00 = leading zero remove)
.c09a  a9 18      lda #$18         	LDA	#$18			; need A byte long space
.c09c  20 0f b4   jsr $b40f        	JSR	LAB_MSSP		; make string space A bytes long
.c09f  a0 17      ldy #$17         	LDY	#$17			; set index
.c0a1  a2 18      ldx #$18         	LDX	#$18			; character count
.c0a3                              nextb1
.c0a3  46 11      lsr $11          	LSR	nums_1		; shift highest byte
.c0a5  66 12      ror $12          	ROR	nums_2		; shift middle byte
.c0a7  66 13      ror $13          	ROR	nums_3		; shift lowest byte bit 0 to carry
.c0a9  8a         txa              	TXA				; load with "0"/2
.c0aa  2a         rol              	ROL	A			; shift in carry
.c0ab  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save to temp string + index
.c0ad  88         dey              	DEY				; decrement index
.c0ae  10 f3      bpl $c0a3        	BPL	NextB1		; loop if not done
.c0b0  a5 78      lda $78          	LDA	TempB			; get # of characters
.c0b2  f0 0a      beq $c0be        	BEQ	EndBHS		; branch if truncate
.c0b4  aa         tax              	TAX				; copy length to X
.c0b5  38         sec              	SEC				; set carry for add !
.c0b6  49 ff      eor #$ff         	EOR	#$FF			; 1's complement
.c0b8  69 18      adc #$18         	ADC	#$18			; add 24d
.c0ba  f0 1c      beq $c0d8        	BEQ	GoPr2			; if zero print whole string
.c0bc  d0 0f      bne $c0cd        	BNE	GoPr1			; else go make output string
.c0be                              endbhs
.c0be  a8         tay              	TAY				; clear index (A=0, X=length here)
.c0bf                              nextb2
.c0bf  b1 ad      lda ($ad),y      	LDA	(str_pl),Y		; get character from string
.c0c1  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.c0c3  d0 07      bne $c0cc        	BNE	GoPr			; if not "0" then go print string from here
.c0c5  ca         dex              	DEX				; decrement character count
.c0c6  f0 03      beq $c0cb        	BEQ	GoPr3			; if zero then end of string so go print it
.c0c8  c8         iny              	INY				; else increment index
.c0c9  10 f4      bpl $c0bf        	BPL	NextB2		; loop always
.c0cb                              gopr3
.c0cb  e8         inx              	INX				; need at least 1 character
.c0cc                              gopr
.c0cc  98         tya              	TYA				; copy result
.c0cd                              gopr1
.c0cd  18         clc              	CLC				; clear carry for add
.c0ce  65 ad      adc $ad          	ADC	str_pl		; add low address
.c0d0  85 ad      sta $ad          	STA	str_pl		; save low address
.c0d2  a9 00      lda #$00         	LDA	#$00			; do high byte
.c0d4  65 ae      adc $ae          	ADC	str_ph		; add high address
.c0d6  85 ae      sta $ae          	STA	str_ph		; save high address
.c0d8                              gopr2
.c0d8  68         pla              	PLA				; dump return address (skip type check)
.c0d9  68         pla              	PLA				; dump return address (skip type check)
.c0da  86 ac      stx $ac          	STX	str_ln		; X holds string length
.c0dc  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.c0df  4c 5a b4   jmp $b45a        	JMP	LAB_RTST		; check for space on descriptor stack then put address
.c0e2                              binferr
.c0e2  4c f9 b1   jmp $b1f9        	JMP	LAB_FCER		; do function call error, then warm start
.c0e5                              lab_hexs
.c0e5  e0 07      cpx #$07         	CPX	#$07			; max + 1
.c0e7  b0 f9      bcs $c0e2        	BCS	BinFErr		; exit if too big ( > or = )
.c0e9  86 78      stx $78          	STX	TempB			; save # of characters
.c0eb  a9 06      lda #$06         	LDA	#$06			; need 6 bytes for string
.c0ed  20 0f b4   jsr $b40f        	JSR	LAB_MSSP		; make string space A bytes long
.c0f0  a0 05      ldy #$05         	LDY	#$05			; set string index
.c0f2  f8         sed              	SED				; need decimal mode for nibble convert
.c0f3  a5 13      lda $13          	LDA	nums_3		; get lowest byte
.c0f5  20 13 c1   jsr $c113        	JSR	LAB_A2HX		; convert A to ASCII hex byte & output
.c0f8  a5 12      lda $12          	LDA	nums_2		; get middle byte
.c0fa  20 13 c1   jsr $c113        	JSR	LAB_A2HX		; convert A to ASCII hex byte & output
.c0fd  a5 11      lda $11          	LDA	nums_1		; get highest byte
.c0ff  20 13 c1   jsr $c113        	JSR	LAB_A2HX		; convert A to ASCII hex byte & output
.c102  d8         cld              	CLD				; back to binary
.c103  a2 06      ldx #$06         	LDX	#$06			; character count
.c105  a5 78      lda $78          	LDA	TempB			; get # of characters
.c107  f0 b5      beq $c0be        	BEQ	EndBHS		; branch if truncate
.c109  aa         tax              	TAX				; copy length to X
.c10a  38         sec              	SEC				; set carry for add !
.c10b  49 ff      eor #$ff         	EOR	#$FF			; 1's complement
.c10d  69 06      adc #$06         	ADC	#$06			; add 6d
.c10f  f0 c7      beq $c0d8        	BEQ	GoPr2			; if zero print whole string
.c111  d0 ba      bne $c0cd        	BNE	GoPr1			; else go make output string (branch always)
.c113                              lab_a2hx
.c113  aa         tax              	TAX				; save byte
.c114  29 0f      and #$0f         	AND	#$0F			; mask off top bits
.c116  20 1e c1   jsr $c11e        	JSR	LAB_AL2X		; convert low nibble to ASCII & output
.c119  8a         txa              	TXA				; get byte back
.c11a  4a         lsr              	LSR	A			; /2	shift high nibble to low nibble
.c11b  4a         lsr              	LSR	A			; /4
.c11c  4a         lsr              	LSR	A			; /8
.c11d  4a         lsr              	LSR	A			; /16
.c11e                              lab_al2x
.c11e  c9 0a      cmp #$0a         	CMP	#$0A			; set carry for +1 if >9
.c120  69 30      adc #$30         	ADC	#"0"			; add ASCII "0"
.c122  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save to temp string
.c124  88         dey              	DEY				; decrement counter
.c125  60         rts              	RTS
.c126                              lab_nlto
.c126  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.c128  a9 00      lda #$00         	LDA	#$00			; clear sign compare
.c12a                              lab_mlte
.c12a  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.c12c  8a         txa              	TXA				; restore character
.c12d  20 0e bd   jsr $bd0e        	JSR	LAB_2912		; evaluate new ASCII digit
.c130                              lab_chex
.c130  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.c133  90 0a      bcc $c13f        	BCC	LAB_ISHN		; branch if numeric character
.c135  09 20      ora #$20         	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
.c137  e9 61      sbc #$61         	SBC	#"a"			; subtract "a" (carry set here)
.c139  c9 06      cmp #$06         	CMP	#$06			; compare normalised with $06 (max+1)
.c13b  b0 2a      bcs $c167        	BCS	LAB_EXCH		; exit if >"f" or <"0"
.c13d  69 0a      adc #$0a         	ADC	#$0A			; convert to nibble
.c13f                              lab_ishn
.c13f  29 0f      and #$0f         	AND	#$0F			; convert to binary
.c141  aa         tax              	TAX				; save nibble
.c142  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c144  f0 e4      beq $c12a        	BEQ	LAB_MLTE		; skip multiply if zero
.c146  69 04      adc #$04         	ADC	#$04			; add four to exponent (*16 - carry clear here)
.c148  90 dc      bcc $c126        	BCC	LAB_NLTO		; if no overflow do evaluate digit
.c14a                              lab_mlto
.c14a  4c 87 b9   jmp $b987        	JMP	LAB_2564		; do overflow error & warm start
.c14d                              lab_nxch
.c14d  aa         tax              	TAX				; save bit
.c14e  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c150  f0 06      beq $c158        	BEQ	LAB_MLBT		; skip multiply if zero
.c152  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent (*2)
.c154  f0 f4      beq $c14a        	BEQ	LAB_MLTO		; do overflow error if = $00
.c156  a9 00      lda #$00         	LDA	#$00			; clear sign compare
.c158                              lab_mlbt
.c158  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.c15a  8a         txa              	TXA				; restore bit
.c15b  20 0e bd   jsr $bd0e        	JSR	LAB_2912		; evaluate new ASCII digit
.c15e                              lab_cbin
.c15e  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory
.c161  49 30      eor #$30         	EOR	#"0"			; convert "0" to 0 etc.
.c163  c9 02      cmp #$02         	CMP	#$02			; compare with max+1
.c165  90 e6      bcc $c14d        	BCC	LAB_NXCH		; branch exit if < 2
.c167                              lab_exch
.c167  4c f2 bc   jmp $bcf2        	JMP	LAB_28F6		; evaluate -ve flag & return
.c16a                              ctrlc
.c16a  ad 00 02   lda $0200        	LDA	ccflag		; get [CTRL-C] check flag
.c16d  d0 18      bne $c187        	BNE	LAB_FBA2		; exit if inhibited
.c16f  20 b7 c3   jsr $c3b7        	JSR	V_INPT		; scan input device
.c172  90 0b      bcc $c17f        	BCC	LAB_FBA0		; exit if buffer empty
.c174  8d 01 02   sta $0201        	STA	ccbyte		; save received byte
.c177  a2 20      ldx #$20         	LDX	#$20			; "life" timer for bytes
.c179  8e 02 02   stx $0202        	STX	ccnull		; set countdown
.c17c  4c 23 a8   jmp $a823        	JMP	LAB_1636		; return to BASIC
.c17f                              lab_fba0
.c17f  ae 02 02   ldx $0202        	LDX	ccnull		; get countdown byte
.c182  f0 03      beq $c187        	BEQ	LAB_FBA2		; exit if finished
.c184  ce 02 02   dec $0202        	DEC	ccnull		; else decrement countdown
.c187                              lab_fba2
.c187  a2 d8      ldx #$d8         	LDX	#NmiBase		; set pointer to NMI values
.c189  20 92 c1   jsr $c192        	JSR	LAB_CKIN		; go check interrupt
.c18c  a2 db      ldx #$db         	LDX	#IrqBase		; set pointer to IRQ values
.c18e  20 92 c1   jsr $c192        	JSR	LAB_CKIN		; go check interrupt
.c191                              lab_crts
.c191  60         rts              	RTS				;
.c192                              lab_ckin
.c192  b5 00      lda $00,x        	LDA	PLUS_0,X		; get interrupt flag byte
.c194  10 fb      bpl $c191        	BPL	LAB_CRTS		; branch if interrupt not enabled
.c196  0a         asl              	ASL	A			; move happened bit to setup bit
.c197  29 40      and #$40         	AND	#$40			; mask happened bits
.c199  f0 f6      beq $c191        	BEQ	LAB_CRTS		; if no interrupt then exit
.c19b  95 00      sta $00,x        	STA	PLUS_0,X		; save interrupt flag byte
.c19d  8a         txa              	TXA				; copy index ..
.c19e  a8         tay              	TAY				; .. to Y
.c19f  68         pla              	PLA				; dump return address low byte (call from CTRL-C)
.c1a0  68         pla              	PLA				; dump return address high byte
.c1a1  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for GOSUB
.c1a3  20 07 a4   jsr $a407        	JSR	LAB_1212		; check room on stack for A bytes
.c1a6  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.c1a8  48         pha              	PHA				; push on stack
.c1a9  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.c1ab  48         pha              	PHA				; push on stack
.c1ac  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.c1ae  48         pha              	PHA				; push on stack
.c1af  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.c1b1  48         pha              	PHA				; push on stack
.c1b2  a9 8d      lda #$8d         	LDA	#TK_GOSUB		; token for GOSUB
.c1b4  48         pha              	PHA				; push on stack
.c1b5  b9 01 00   lda $0001,y      	LDA	PLUS_1,Y		; get interrupt code pointer low byte
.c1b8  85 c3      sta $c3          	STA	Bpntrl		; save as BASIC execute pointer low byte
.c1ba  b9 02 00   lda $0002,y      	LDA	PLUS_2,Y		; get interrupt code pointer high byte
.c1bd  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.c1bf  4c c6 a7   jmp $a7c6        	JMP	LAB_15C2		; go do interpreter inner loop
.c1c2                              inget
.c1c2  20 b7 c3   jsr $c3b7        	JSR	V_INPT		; call scan input device
.c1c5  b0 09      bcs $c1d0        	BCS	LAB_FB95		; if byte go reset timer
.c1c7  ad 02 02   lda $0202        	LDA	ccnull		; get countdown
.c1ca  f0 09      beq $c1d5        	BEQ	LAB_FB96		; exit if empty
.c1cc  ad 01 02   lda $0201        	LDA	ccbyte		; get last received byte
.c1cf  38         sec              	SEC				; flag we got a byte
.c1d0                              lab_fb95
.c1d0  a2 00      ldx #$00         	LDX	#$00			; clear X
.c1d2  8e 02 02   stx $0202        	STX	ccnull		; clear timer because we got a byte
.c1d5                              lab_fb96
.c1d5  60         rts              	RTS				;
.c1d6                              lab_irq
.c1d6  a2 db      ldx #$db         	LDX	#IrqBase		; set pointer to IRQ values

>c1d8  2c                          	.byte	$2C			; make next line BIT abs.
.c1d9                              lab_nmi

.c1d9  a2 d8      ldx #$d8         	LDX	#NmiBase		; set pointer to NMI values
.c1db  c9 93      cmp #$93         	CMP	#TK_ON		; compare with token for ON
.c1dd  f0 12      beq $c1f1        	BEQ	LAB_INON		; go turn on interrupt
.c1df  c9 b4      cmp #$b4         	CMP	#TK_OFF		; compare with token for OFF
.c1e1  f0 08      beq $c1eb        	BEQ	LAB_IOFF		; go turn off interrupt
.c1e3  38         sec              	SEC				; set carry for subtract
.c1e4  e9 a2      sbc #$a2         	SBC	#TK_CLEAR		; compare with token for CLEAR (A = $00 if = TK_CLEAR)
.c1e6  f0 0e      beq $c1f6        	BEQ	LAB_INEX		; go clear interrupt flags & return
.c1e8  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; do syntax error, then warm start
.c1eb                              lab_ioff
.c1eb  a9 7f      lda #$7f         	LDA	#$7F			; clear A
.c1ed  35 00      and $00,x        	AND	PLUS_0,X		; AND with interrupt setup flag
.c1ef  10 05      bpl $c1f6        	BPL	LAB_INEX		; go clear interrupt enabled flag & return
.c1f1                              lab_inon
.c1f1  b5 00      lda $00,x        	LDA	PLUS_0,X		; get interrupt setup flag
.c1f3  0a         asl              	ASL	A			; Shift bit to enabled flag
.c1f4  15 00      ora $00,x        	ORA	PLUS_0,X		; OR with flag byte
.c1f6                              lab_inex
.c1f6  95 00      sta $00,x        	STA	PLUS_0,X		; save interrupt flag byte
.c1f8  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; update BASIC execute pointer & return
.c1fb                              lab_sirq
.c1fb  58         cli              	CLI				; enable interrupts
.c1fc  a2 db      ldx #$db         	LDX	#IrqBase		; set pointer to IRQ values

>c1fe  2c                          	.byte	$2C			; make next line BIT abs.
.c1ff                              lab_snmi

.c1ff  a2 d8      ldx #$d8         	LDX	#NmiBase		; set pointer to NMI values
.c201  86 78      stx $78          	STX	TempB			; save interrupt pointer
.c203  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment & scan memory (past token)
.c206  20 1c aa   jsr $aa1c        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.c209  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.c20b  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.c20d  20 30 a6   jsr $a630        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.c210  b0 03      bcs $c215        	BCS	LAB_LFND		; if carry set go set-up interrupt
.c212  4c 7e a9   jmp $a97e        	JMP	LAB_16F7		; else go do "Undefined statement" error & warm start
.c215                              lab_lfnd
.c215  a6 78      ldx $78          	LDX	TempB			; get interrupt pointer
.c217  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.c219  e9 01      sbc #$01         	SBC	#$01			; -1 (carry already set for subtract)
.c21b  95 01      sta $01,x        	STA	PLUS_1,X		; save as interrupt pointer low byte
.c21d  a5 ab      lda $ab          	LDA	Baslnh		; get pointer high byte
.c21f  e9 00      sbc #$00         	SBC	#$00			; subtract carry
.c221  95 02      sta $02,x        	STA	PLUS_2,X		; save as interrupt pointer high byte
.c223  a9 c0      lda #$c0         	LDA	#$C0			; set interrupt enabled/setup bits
.c225  95 00      sta $00,x        	STA	PLUS_0,X		; set interrupt flags
.c227                              lab_irts
.c227  60         rts              	RTS				;
.c228                              lab_retirq
.c228  d0 fd      bne $c227        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.c22a  a5 db      lda $db          	LDA	IrqBase		; get interrupt flags
.c22c  0a         asl              	ASL	A			; copy setup to enabled (b7)
.c22d  05 db      ora $db          	ORA	IrqBase		; OR in setup flag
.c22f  85 db      sta $db          	STA	IrqBase		; save enabled flag
.c231  4c 85 a9   jmp $a985        	JMP	LAB_16E8		; go do rest of RETURN
.c234                              lab_retnmi
.c234  d0 f1      bne $c227        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.c236  a5 d8      lda $d8          	LDA	NmiBase		; get set-up flag
.c238  0a         asl              	ASL	A			; copy setup to enabled (b7)
.c239  05 d8      ora $d8          	ORA	NmiBase		; OR in setup flag
.c23b  85 d8      sta $d8          	STA	NmiBase		; save enabled flag
.c23d  4c 85 a9   jmp $a985        	JMP	LAB_16E8		; go do rest of RETURN
.c240                              lab_max
.c240  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.c243  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.c246                              lab_maxn
.c246  20 7a c2   jsr $c27a        	JSR	LAB_PHFA		; push FAC1, evaluate expression,
.c249  10 fb      bpl $c246        	BPL	LAB_MAXN		; branch if no swap to do
.c24b  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.c24d  09 80      ora #$80         	ORA	#$80			; set top bit (clear sign from compare)
.c24f  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.c251  20 87 b8   jsr $b887        	JSR	LAB_279B		; copy FAC2 to FAC1
.c254  f0 f0      beq $c246        	BEQ	LAB_MAXN		; go do next (branch always)
.c256                              lab_min
.c256  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.c259  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.c25c                              lab_minn
.c25c  20 7a c2   jsr $c27a        	JSR	LAB_PHFA		; push FAC1, evaluate expression,
.c25f  30 fb      bmi $c25c        	BMI	LAB_MINN		; branch if no swap to do
.c261  f0 f9      beq $c25c        	BEQ	LAB_MINN		; branch if no swap to do
.c263  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.c265  09 80      ora #$80         	ORA	#$80			; set top bit (clear sign from compare)
.c267  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.c269  20 87 b8   jsr $b887        	JSR	LAB_279B		; copy FAC2 to FAC1
.c26c  f0 ee      beq $c25c        	BEQ	LAB_MINN		; go do next (branch always)
.c26e                              lab_mmec
.c26e  c9 29      cmp #$29         	CMP	#")"			; is it end of function?
.c270  d0 05      bne $c277        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
.c272  68         pla              	PLA				; dump return address low byte
.c273  68         pla              	PLA				; dump return address high byte
.c274  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
.c277                              lab_mmse
.c277  4c fb ae   jmp $aefb        	JMP	LAB_SNER		; do syntax error, then warm start
.c27a                              lab_phfa
.c27a  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.c27d  c9 2c      cmp #$2c         	CMP	#","			; is there more ?
.c27f  d0 ed      bne $c26e        	BNE	LAB_MMEC		; if not go do end check
.c281  20 a3 bb   jsr $bba3        	JSR	LAB_27BA		; round FAC1
.c284  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign
.c286  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.c288  25 ad      and $ad          	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
.c28a  48         pha              	PHA				; push on stack
.c28b  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.c28d  48         pha              	PHA				; push on stack
.c28e  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.c290  48         pha              	PHA				; push on stack
.c291  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c293  48         pha              	PHA				; push on stack
.c294  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; scan & get next BASIC byte (after ",")
.c297  20 99 ad   jsr $ad99        	JSR	LAB_EVNM		; evaluate expression & check is numeric,
.c29a  68         pla              	PLA				; pop exponent
.c29b  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.c29d  68         pla              	PLA				; pop mantissa3
.c29e  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.c2a0  68         pla              	PLA				; pop mantissa1
.c2a1  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.c2a3  68         pla              	PLA				; pop sign/mantissa1
.c2a4  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 sign/mantissa1
.c2a6  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign
.c2a8  a9 b3      lda #$b3         	LDA	#<FAC2_e		; set pointer low byte to FAC2
.c2aa  a0 00      ldy #$00         	LDY	#>FAC2_e		; set pointer high byte to FAC2
.c2ac  4c e1 bb   jmp $bbe1        	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) & return
.c2af                              lab_wdth
.c2af  c9 2c      cmp #$2c         	CMP	#","			; is next byte ","
.c2b1  f0 1b      beq $c2ce        	BEQ	LAB_TBSZ		; if so do tab size
.c2b3  20 50 b7   jsr $b750        	JSR	LAB_GTBY		; get byte parameter
.c2b6  8a         txa              	TXA				; copy width to A
.c2b7  f0 0a      beq $c2c3        	BEQ	LAB_NSTT		; branch if set for infinite line
.c2b9  e0 10      cpx #$10         	CPX	#$10			; else make min width = 16d
.c2bb  90 45      bcc $c302        	BCC	TabErr		; if less do function call error & exit
.c2bd  e4 64      cpx $64          	CPX	TabSiz		; compare with tab size
.c2bf  b0 02      bcs $c2c3        	BCS	LAB_NSTT		; branch if >= tab size
.c2c1  86 64      stx $64          	STX	TabSiz		; else make tab size = terminal width
.c2c3                              lab_nstt
.c2c3  86 0f      stx $0f          	STX	TWidth		; set the terminal width
.c2c5  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get BASIC byte back
.c2c8  f0 1a      beq $c2e4        	BEQ	WExit			; exit if no following
.c2ca  c9 2c      cmp #$2c         	CMP	#","			; else is it ","
.c2cc  d0 a9      bne $c277        	BNE	LAB_MMSE		; if not do syntax error
.c2ce                              lab_tbsz
.c2ce  20 4d b7   jsr $b74d        	JSR	LAB_SGBY		; scan and get byte parameter
.c2d1  8a         txa              	TXA				; copy TAB size
.c2d2  30 2e      bmi $c302        	BMI	TabErr		; if >127 do function call error & exit
.c2d4  e0 01      cpx #$01         	CPX	#$01			; compare with min-1
.c2d6  90 2a      bcc $c302        	BCC	TabErr		; if <=1 do function call error & exit
.c2d8  a5 0f      lda $0f          	LDA	TWidth		; set flags for width
.c2da  f0 06      beq $c2e2        	BEQ	LAB_SVTB		; skip check if infinite line
.c2dc  e4 0f      cpx $0f          	CPX	TWidth		; compare TAB with width
.c2de  f0 02      beq $c2e2        	BEQ	LAB_SVTB		; ok if =
.c2e0  b0 20      bcs $c302        	BCS	TabErr		; branch if too big
.c2e2                              lab_svtb
.c2e2  86 64      stx $64          	STX	TabSiz		; save TAB size
.c2e4                              wexit
.c2e4  a5 0f      lda $0f          	LDA	TWidth		; get width
.c2e6  f0 06      beq $c2ee        	BEQ	LAB_SULP		; branch if infinite line
.c2e8  c5 64      cmp $64          	CMP	TabSiz		; compare with tab size
.c2ea  b0 03      bcs $c2ef        	BCS	LAB_WDLP		; branch if >= tab size
.c2ec  85 64      sta $64          	STA	TabSiz		; else make tab size = terminal width
.c2ee                              lab_sulp
.c2ee  38         sec              	SEC				; set carry for subtract
.c2ef                              lab_wdlp
.c2ef  e5 64      sbc $64          	SBC	TabSiz		; subtract tab size
.c2f1  b0 fc      bcs $c2ef        	BCS	LAB_WDLP		; loop while no borrow
.c2f3  65 64      adc $64          	ADC	TabSiz		; add tab size back
.c2f5  18         clc              	CLC				; clear carry for add
.c2f6  65 64      adc $64          	ADC	TabSiz		; add tab size back again
.c2f8  85 10      sta $10          	STA	Iclim			; save for now
.c2fa  a5 0f      lda $0f          	LDA	TWidth		; get width back
.c2fc  38         sec              	SEC				; set carry for subtract
.c2fd  e5 10      sbc $10          	SBC	Iclim			; subtract remainder
.c2ff  85 10      sta $10          	STA	Iclim			; save tab column limit
.c301                              lab_nosq
.c301  60         rts              	RTS
.c302                              taberr
.c302  4c f9 b1   jmp $b1f9        	JMP	LAB_FCER		; do function call error, then warm start
.c305                              lab_sqr
.c305  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign
.c307  30 f9      bmi $c302        	BMI	TabErr		; if -ve do function call error
.c309                              lab_nofc
.c309  a5 ac      lda $ac          	LDA	FAC1_e		; get exponent
.c30b  f0 f4      beq $c301        	BEQ	LAB_NOSQ		; do root if non zero
.c30d  20 94 bb   jsr $bb94        	JSR	LAB_27AB		; round & copy FAC1 to FAC2
.c310  a9 00      lda #$00         	LDA	#$00			; clear A
.c312  85 77      sta $77          	STA	FACt_3		; clear remainder
.c314  85 76      sta $76          	STA	FACt_2		;
.c316  85 75      sta $75          	STA	FACt_1		;
.c318  85 78      sta $78          	STA	TempB			;
.c31a  85 af      sta $af          	STA	FAC1_3		; clear root
.c31c  85 ae      sta $ae          	STA	FAC1_2		;
.c31e  85 ad      sta $ad          	STA	FAC1_1		;
.c320  a2 18      ldx #$18         	LDX	#$18			; 24 pairs of bits to do
.c322  a5 b3      lda $b3          	LDA	FAC2_e		; get exponent
.c324  4a         lsr              	LSR	A			; check odd/even
.c325  b0 0e      bcs $c335        	BCS	LAB_SQE2		; if odd only 1 shift first time
.c327                              lab_sqe1
.c327  06 b6      asl $b6          	ASL	FAC2_3		; shift highest bit of number ..
.c329  26 b5      rol $b5          	ROL	FAC2_2		;
.c32b  26 b4      rol $b4          	ROL	FAC2_1		;
.c32d  26 77      rol $77          	ROL	FACt_3		; .. into remainder
.c32f  26 76      rol $76          	ROL	FACt_2		;
.c331  26 75      rol $75          	ROL	FACt_1		;
.c333  26 78      rol $78          	ROL	TempB			; .. never overflows
.c335                              lab_sqe2
.c335  06 b6      asl $b6          	ASL	FAC2_3		; shift highest bit of number ..
.c337  26 b5      rol $b5          	ROL	FAC2_2		;
.c339  26 b4      rol $b4          	ROL	FAC2_1		;
.c33b  26 77      rol $77          	ROL	FACt_3		; .. into remainder
.c33d  26 76      rol $76          	ROL	FACt_2		;
.c33f  26 75      rol $75          	ROL	FACt_1		;
.c341  26 78      rol $78          	ROL	TempB			; .. never overflows
.c343  06 af      asl $af          	ASL	FAC1_3		; root = root * 2
.c345  26 ae      rol $ae          	ROL	FAC1_2		;
.c347  26 ad      rol $ad          	ROL	FAC1_1		; .. never overflows
.c349  a5 af      lda $af          	LDA	FAC1_3		; get root low byte
.c34b  2a         rol              	ROL	A			; *2
.c34c  85 5b      sta $5b          	STA	Temp3			; save partial low byte
.c34e  a5 ae      lda $ae          	LDA	FAC1_2		; get root low mid byte
.c350  2a         rol              	ROL	A			; *2
.c351  85 5c      sta $5c          	STA	Temp3+1		; save partial low mid byte
.c353  a5 ad      lda $ad          	LDA	FAC1_1		; get root high mid byte
.c355  2a         rol              	ROL	A			; *2
.c356  85 5d      sta $5d          	STA	Temp3+2		; save partial high mid byte
.c358  a9 00      lda #$00         	LDA	#$00			; get root high byte (always $00)
.c35a  2a         rol              	ROL	A			; *2
.c35b  85 5e      sta $5e          	STA	Temp3+3		; save partial high byte
.c35d  a5 77      lda $77          	LDA	FACt_3		; get remainder low byte
.c35f  e5 5b      sbc $5b          	SBC	Temp3			; subtract partial low byte
.c361  85 5b      sta $5b          	STA	Temp3			; save partial low byte
.c363  a5 76      lda $76          	LDA	FACt_2		; get remainder low mid byte
.c365  e5 5c      sbc $5c          	SBC	Temp3+1		; subtract partial low mid byte
.c367  85 5c      sta $5c          	STA	Temp3+1		; save partial low mid byte
.c369  a5 75      lda $75          	LDA	FACt_1		; get remainder high mid byte
.c36b  e5 5d      sbc $5d          	SBC	Temp3+2		; subtract partial high mid byte
.c36d  a8         tay              	TAY				; copy partial high mid byte
.c36e  a5 78      lda $78          	LDA	TempB			; get remainder high byte
.c370  e5 5e      sbc $5e          	SBC	Temp3+3		; subtract partial high byte
.c372  90 0e      bcc $c382        	BCC	LAB_SQNS		; skip sub if remainder smaller
.c374  85 78      sta $78          	STA	TempB			; save remainder high byte
.c376  84 75      sty $75          	STY	FACt_1		; save remainder high mid byte
.c378  a5 5c      lda $5c          	LDA	Temp3+1		; get remainder low mid byte
.c37a  85 76      sta $76          	STA	FACt_2		; save remainder low mid byte
.c37c  a5 5b      lda $5b          	LDA	Temp3			; get partial low byte
.c37e  85 77      sta $77          	STA	FACt_3		; save remainder low byte
.c380  e6 af      inc $af          	INC	FAC1_3		; increment root low byte (never any rollover)
.c382                              lab_sqns
.c382  ca         dex              	DEX				; decrement bit pair count
.c383  d0 a2      bne $c327        	BNE	LAB_SQE1		; loop if not all done
.c385  38         sec              	SEC				; set carry for subtract
.c386  a5 b3      lda $b3          	LDA	FAC2_e		; get exponent
.c388  e9 80      sbc #$80         	SBC	#$80			; normalise
.c38a  6a         ror              	ROR	A			; /2 and re-bias to $80
.c38b  69 00      adc #$00         	ADC	#$00			; add bit zero back in (allow for half shift)
.c38d  85 ac      sta $ac          	STA	FAC1_e		; save it
.c38f  4c f8 b8   jmp $b8f8        	JMP	LAB_24D5		; normalise FAC1 & return
.c392                              lab_varptr
.c392  20 ed ae   jsr $aeed        	JSR	LAB_1BFE		; scan for "(" , else do syntax error, then warm start
.c395  20 7c b0   jsr $b07c        	JSR	LAB_GVAR		; get var address
.c398  20 ea ae   jsr $aeea        	JSR	LAB_1BFB		; scan for ")" , else do syntax error, then warm start
.c39b  a4 95      ldy $95          	LDY	Cvaral		; get var address low byte
.c39d  a5 96      lda $96          	LDA	Cvarah		; get var address high byte
.c39f  4c 29 b3   jmp $b329        	JMP	LAB_AYFC		; save & convert integer AY to FAC1 & return
.c3a2                              lab_pi
.c3a2  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.c3a4  a9 84      lda #$84         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.c3a6  a0 c4      ldy #$c4         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.c3a8  20 44 bb   jsr $bb44        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.c3ab  c6 ac      dec $ac          	DEC	FAC1_e		; make result = PI
.c3ad  60         rts              	RTS
.c3ae                              lab_twopi
.c3ae  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.c3b0  a9 84      lda #$84         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.c3b2  a0 c4      ldy #$c4         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.c3b4  4c 44 bb   jmp $bb44        	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 & return
.c3b7                              v_inpt
.c3b7  6c 05 02   jmp ($0205)      	JMP	(VEC_IN)		; non halting scan input device
.c3ba                              v_outp
.c3ba  6c 07 02   jmp ($0207)      	JMP	(VEC_OUT)		; send byte to output device
.c3bd                              v_load
.c3bd  6c 09 02   jmp ($0209)      	JMP	(VEC_LD)		; load BASIC program
.c3c0                              v_save
.c3c0  6c 0b 02   jmp ($020b)      	JMP	(VEC_SV)		; save BASIC program
.c3c3                              pg2_tabs

>c3c3  00                          	.byte	$00			; ctrl-c flag		-	$00 = enabled
>c3c4  00                          	.byte	$00			; ctrl-c byte		-	GET needs this
>c3c5  00                          	.byte	$00			; ctrl-c byte timeout	-	GET needs this
>c3c6  6a c1                       	.word	CTRLC			; ctrl c check vector
.c3c8                              pg2_tabe
.c3c8                              lab_2cee

.c3c8  e6 c3      inc $c3          	INC	Bpntrl		; increment BASIC execute pointer low byte
.c3ca  d0 02      bne $c3ce        	BNE	LAB_2CF4		; branch if no carry
.c3cc  e6 c4      inc $c4          	INC	Bpntrh		; increment BASIC execute pointer high byte
.c3ce                              lab_2cf4
.c3ce  ad ff ff   lda $ffff        	LDA	$FFFF			; get byte to scan (addr set by call routine)
.c3d1  c9 3a      cmp #$3a         	CMP	#$3A			; compare with ":"
.c3d3  b0 0a      bcs $c3df        	BCS	LAB_2D05		; exit if>= (not numeric, carry set)
.c3d5  c9 20      cmp #$20         	CMP	#$20			; compare with " "
.c3d7  f0 ef      beq $c3c8        	BEQ	LAB_2CEE		; if " " go do next
.c3d9  38         sec              	SEC				; set carry for SBC
.c3da  e9 30      sbc #$30         	SBC	#$30			; subtract "0"
.c3dc  38         sec              	SEC				; set carry for SBC
.c3dd  e9 d0      sbc #$d0         	SBC	#$D0			; subtract -"0"
.c3df                              lab_2d05
.c3df  60         rts              	RTS				;
.c3e0                              strtab

>c3e0  4c                          	.byte	$4C			; JMP opcode
>c3e1  00 a3                       	.word LAB_COLD		; initial warm start vector (cold start)
>c3e3  00                          	.byte	$00			; these bytes are not used by BASIC
>c3e4  00 00                       	.word	$0000			; 
>c3e6  00 00                       	.word	$0000			; 
>c3e8  00 00                       	.word	$0000			; 
>c3ea  4c                          	.byte	$4C			; JMP opcode
>c3eb  f9 b1                       	.word	LAB_FCER		; initial user function vector ("Function call" error)
>c3ed  00                          	.byte	$00			; default NULL count
>c3ee  00                          	.byte	$00			; clear terminal position
>c3ef  00                          	.byte	$00			; default terminal width byte
>c3f0  f2                          	.byte	$F2			; default limit for TAB = 14
>c3f1  00 04                       	.word	Ram_base		; start of user RAM
.c3f3                              endtab
.c3f3                              lab_mszm
>c3f3  0d 0a 4d 65 6d 6f 72 79 20 73 69 7a 65 20 00  	.byte	$0D,$0A,"Memory size ",$00
.c402                              lab_smsg
>c402  20 42 79 74 65 73 20 66 72 65 65 0d 0a 0a  	.byte	" Bytes free",$0D,$0A,$0A
>c410  45 6e 68 61 6e 63 65 64 20 42 41 53 49 43 20 31 2e 31 30 0a 00  	.byte	"Enhanced BASIC 1.10",$0A,$00
.c425                              lab_25a0
>c425  02                          	.byte	$02			; counter
>c426  80 19 56 62                 	.byte	$80,$19,$56,$62	; 0.59898
>c42a  80 76 22 f3                 	.byte	$80,$76,$22,$F3	; 0.96147
>c42e  82 38 aa 40                 	.byte	$82,$38,$AA,$40	; 2.88539
.c432                              lab_25ad
>c432  80 35 04 f3                 	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
.c436                              lab_25b1
>c436  81 35 04 f3                 	.byte	$81,$35,$04,$F3	; 1.41421	root 2
.c43a                              lab_25b5
>c43a  80 80 00 00                 	.byte	$80,$80,$00,$00	; -0.5
.c43e                              lab_25b9
>c43e  80 31 72 18                 	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
.c442                              lab_2947
>c442  91 43 4f f8                 	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
.c446                              lab_294b
>c446  94 74 23 f7                 	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
.c44a                              lab_294f
>c44a  94 74 24 00                 	.byte	$94,$74,$24,$00	; 1000000
.c44e                              lab_2afa
>c44e  81 38 aa 3b                 	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
.c452                              lab_2afe
>c452  06                          	.byte	$06			; counter
>c453  74 63 90 8c                 	.byte	$74,$63,$90,$8C	; 2.17023e-4
>c457  77 23 0c ab                 	.byte	$77,$23,$0C,$AB	; 0.00124
>c45b  7a 1e 94 00                 	.byte	$7A,$1E,$94,$00	; 0.00968
>c45f  7c 63 42 80                 	.byte	$7C,$63,$42,$80	; 0.05548
>c463  7e 75 fe d0                 	.byte	$7E,$75,$FE,$D0	; 0.24023
>c467  80 31 72 15                 	.byte	$80,$31,$72,$15	; 0.69315
>c46b  81 00 00 00                 	.byte	$81,$00,$00,$00	; 1.00000
.c46f                              lab_2c78
>c46f  81 49 0f db                 	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
.c473                              lab_2c84
>c473  04                          	.byte	$04			; counter
>c474  86 1e d7 fb                 	.byte	$86,$1E,$D7,$FB	; 39.7109
>c478  87 99 26 65                 	.byte	$87,$99,$26,$65	;-76.575
>c47c  87 23 34 58                 	.byte	$87,$23,$34,$58	; 81.6022
>c480  86 a5 5d e1                 	.byte	$86,$A5,$5D,$E1	;-41.3417
.c484                              lab_2c7c
>c484  83 49 0f db                 	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
.c488                              lab_2cc9
>c488  08                          	.byte	$08			; counter
>c489  78 3a c5 37                 	.byte	$78,$3A,$C5,$37	; 0.00285
>c48d  7b 83 a2 5c                 	.byte	$7B,$83,$A2,$5C	;-0.0160686
>c491  7c 2e dd 4d                 	.byte	$7C,$2E,$DD,$4D	; 0.0426915
>c495  7d 99 b0 1e                 	.byte	$7D,$99,$B0,$1E	;-0.0750429
>c499  7d 59 ed 24                 	.byte	$7D,$59,$ED,$24	; 0.106409
>c49d  7e 91 72 00                 	.byte	$7E,$91,$72,$00	;-0.142036
>c4a1  7e 4c b9 73                 	.byte	$7E,$4C,$B9,$73	; 0.199926
>c4a5  7f aa aa 53                 	.byte	$7F,$AA,$AA,$53	;-0.333331
.c4a9                              lab_259c
>c4a9  81                          	.byte	$81
.c4aa                              lab_1d96
>c4aa  00 00 00                    	.byte	$00,$00,$00		; 1.000000
.c4ad                              lab_2afd
>c4ad  81 80 00 00                 	.byte	$81,$80,$00,$00	; -1.00000 (used for DEC)
.c4b1                              lab_1df7
>c4b1  90                          	.byte	$90			;-32768 (uses first three bytes from 0.5)
.c4b2                              lab_2a96
>c4b2  80 00 00 00                 	.byte	$80,$00,$00,$00	; 0.5
.c4b6                              lab_2c80
>c4b6  7f 00 00 00                 	.byte	$7F,$00,$00,$00	; 0.25
.c4ba                              lab_26b5
>c4ba  84 20 00 00                 	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
.c4be                              lab_2a9a
>c4be  fe 79 60                    	.byte	$FE,$79,$60		; -100000
>c4c1  00 27 10                    	.byte	$00,$27,$10		; 10000
>c4c4  ff fc 18                    	.byte	$FF,$FC,$18		; -1000
>c4c7  00 00 64                    	.byte	$00,$00,$64		; 100
>c4ca  ff ff f6                    	.byte	$FF,$FF,$F6		; -10
>c4cd  00 00 01                    	.byte	$00,$00,$01		; 1
.c4d0                              lab_ctbl
>c4d0  26 a8                       	.word	(LAB_END-1)		; END
>c4d2  61 a7                       	.word	(LAB_FOR-1)		; FOR
>c4d4  30 ad                       	.word	(LAB_NEXT-1)	; NEXT
>c4d6  97 a9                       	.word	(LAB_DATA-1)	; DATA
>c4d8  18 ac                       	.word	(LAB_INPUT-1)	; INPUT
>c4da  30 b0                       	.word	(LAB_DIM-1)		; DIM
>c4dc  36 ac                       	.word	(LAB_READ-1)	; READ
>c4de  83 aa                       	.word	(LAB_LET-1)		; LET
>c4e0  55 aa                       	.word	(LAB_DEC-1)		; DEC			new command
>c4e2  f6 a8                       	.word	(LAB_GOTO-1)	; GOTO
>c4e4  b5 a8                       	.word	(LAB_RUN-1)		; RUN
>c4e6  ca a9                       	.word	(LAB_IF-1)		; IF
>c4e8  4d a8                       	.word	(LAB_RESTORE-1)	; RESTORE		modified command
>c4ea  d9 a8                       	.word	(LAB_GOSUB-1)	; GOSUB
>c4ec  27 c2                       	.word	(LAB_RETIRQ-1)	; RETIRQ		new command
>c4ee  33 c2                       	.word	(LAB_RETNMI-1)	; RETNMI		new command
>c4f0  82 a9                       	.word	(LAB_RETURN-1)	; RETURN
>c4f2  dd a9                       	.word	(LAB_REM-1)		; REM
>c4f4  24 a8                       	.word	(LAB_STOP-1)	; STOP
>c4f6  ed a9                       	.word	(LAB_ON-1)		; ON			modified command
>c4f8  8b a8                       	.word	(LAB_NULL-1)	; NULL		modified command
>c4fa  58 aa                       	.word	(LAB_INC-1)		; INC			new command
>c4fc  4c b8                       	.word	(LAB_WAIT-1)	; WAIT
>c4fe  bc c3                       	.word	(V_LOAD-1)		; LOAD
>c500  bf c3                       	.word	(V_SAVE-1)		; SAVE
>c502  45 b3                       	.word	(LAB_DEF-1)		; DEF
>c504  d1 b7                       	.word	(LAB_POKE-1)	; POKE
>c506  ed b7                       	.word	(LAB_DOKE-1)	; DOKE		new command
>c508  3a b8                       	.word	(LAB_CALL-1)	; CALL		new command
>c50a  bf a8                       	.word	(LAB_DO-1)		; DO			new command
>c50c  28 a9                       	.word	(LAB_LOOP-1)	; LOOP		new command
>c50e  24 ab                       	.word	(LAB_PRINT-1)	; PRINT
>c510  91 a8                       	.word	(LAB_CONT-1)	; CONT
>c512  ac a6                       	.word	(LAB_LIST-1)	; LIST
>c514  a9 a6                       	.word	(LAB_CLEAR-1)	; CLEAR
>c516  57 a6                       	.word	(LAB_NEW-1)		; NEW
>c518  ae c2                       	.word	(LAB_WDTH-1)	; WIDTH		new command
>c51a  f3 aa                       	.word	(LAB_GET-1)		; GET			new command
>c51c  12 b8                       	.word	(LAB_SWAP-1)	; SWAP		new command
>c51e  41 c0                       	.word	(LAB_BITSET-1)	; BITSET		new command
>c520  55 c0                       	.word	(LAB_BITCLR-1)	; BITCLR		new command
>c522  d5 c1                       	.word	(LAB_IRQ-1)		; IRQ			new command
>c524  d8 c1                       	.word	(LAB_NMI-1)		; NMI			new command
>c526  c1 bb                       	.word	LAB_SGN		; SGN()
>c528  4b bc                       	.word	LAB_INT		; INT()
>c52a  de bb                       	.word	LAB_ABS		; ABS()
>c52c  0a 00                       	.word	Usrjmp		; USR()
>c52e  15 b3                       	.word	LAB_FRE		; FRE()
>c530  36 b3                       	.word	LAB_POS		; POS()
>c532  05 c3                       	.word	LAB_SQR		; SQR()
>c534  61 bf                       	.word	LAB_RND		; RND()		modified function
>c536  bf b9                       	.word	LAB_LOG		; LOG()
>c538  c5 be                       	.word	LAB_EXP		; EXP()
>c53a  97 bf                       	.word	LAB_COS		; COS()
>c53c  9e bf                       	.word	LAB_SIN		; SIN()
>c53e  e7 bf                       	.word	LAB_TAN		; TAN()
>c540  13 c0                       	.word	LAB_ATN		; ATN()
>c542  c7 b7                       	.word	LAB_PEEK		; PEEK()
>c544  db b7                       	.word	LAB_DEEK		; DEEK()		new function
>c546  25 b7                       	.word	LAB_SADD		; SADD()		new function
>c548  2e b7                       	.word	LAB_LENS		; LEN()
>c54a  f7 b3                       	.word	LAB_STRS		; STR$()
>c54c  5f b7                       	.word	LAB_VAL		; VAL()
>c54e  3d b7                       	.word	LAB_ASC		; ASC()
>c550  05 b7                       	.word	LAB_UCASE		; UCASE$()		new function
>c552  e8 b6                       	.word	LAB_LCASE		; LCASE$()		new function
>c554  59 b6                       	.word	LAB_CHRS		; CHR$()
>c556  e5 c0                       	.word	LAB_HEXS		; HEX$()		new function
>c558  94 c0                       	.word	LAB_BINS		; BIN$()		new function
>c55a  6c c0                       	.word	LAB_BTST		; BITTST()		new function
>c55c  40 c2                       	.word	LAB_MAX		; MAX()		new function
>c55e  56 c2                       	.word	LAB_MIN		; MIN()		new function
>c560  a2 c3                       	.word	LAB_PI		; PI			new function
>c562  ae c3                       	.word	LAB_TWOPI		; TWOPI		new function
>c564  92 c3                       	.word	LAB_VARPTR		; VARPTR()		new function
>c566  6d b6                       	.word	LAB_LEFT		; LEFT$()
>c568  75 b6                       	.word	LAB_RIGHT		; RIGHT$()
>c56a  a3 b6                       	.word	LAB_MIDS		; MID$()
.c56c                              lab_oppt
>c56c  79                          	.byte	$79			; +
>c56d  84 b8                       	.word	(LAB_ADD-1)
>c56f  79                          	.byte	$79			; -
>c570  69 b8                       	.word	(LAB_SUBTRACT-1)
>c572  7b                          	.byte	$7B			; *
>c573  ff b9                       	.word	(LAB_MULTIPLY-1)
>c575  7b                          	.byte	$7B			; /
>c576  c7 ba                       	.word	(LAB_DIVIDE-1)
>c578  7f                          	.byte	$7F			; ^
>c579  80 be                       	.word	(LAB_POWER-1)
>c57b  50                          	.byte	$50			; AND
>c57c  a4 af                       	.word	(LAB_AND-1)
>c57e  46                          	.byte	$46			; EOR			new operator
>c57f  8a af                       	.word	(LAB_EOR-1)
>c581  46                          	.byte	$46			; OR
>c582  97 af                       	.word	(LAB_OR-1)
>c584  56                          	.byte	$56			; >>			new operator
>c585  52 b0                       	.word	(LAB_RSHIFT-1)
>c587  56                          	.byte	$56			; <<			new operator
>c588  3a b0                       	.word	(LAB_LSHIFT-1)
>c58a  7d                          	.byte	$7D			; >
>c58b  b9 be                       	.word	(LAB_GTHAN-1)
>c58d  5a                          	.byte	$5A			; =
>c58e  c7 ae                       	.word	(LAB_EQUAL-1)
>c590  64                          	.byte	$64			; <
>c591  c5 af                       	.word	(LAB_LTHAN-1)
.c593                              tab_1stc
>c593  2a                          	.byte	"*"
>c594  2b                          	.byte	"+"
>c595  2d                          	.byte	"-"
>c596  2f                          	.byte	"/"
>c597  3c                          	.byte	"<"
>c598  3d                          	.byte	"="
>c599  3e                          	.byte	">"
>c59a  3f                          	.byte	"?"
>c59b  41                          	.byte	"A"
>c59c  42                          	.byte	"B"
>c59d  43                          	.byte	"C"
>c59e  44                          	.byte	"D"
>c59f  45                          	.byte	"E"
>c5a0  46                          	.byte	"F"
>c5a1  47                          	.byte	"G"
>c5a2  48                          	.byte	"H"
>c5a3  49                          	.byte	"I"
>c5a4  4c                          	.byte	"L"
>c5a5  4d                          	.byte	"M"
>c5a6  4e                          	.byte	"N"
>c5a7  4f                          	.byte	"O"
>c5a8  50                          	.byte	"P"
>c5a9  52                          	.byte	"R"
>c5aa  53                          	.byte	"S"
>c5ab  54                          	.byte	"T"
>c5ac  55                          	.byte	"U"
>c5ad  56                          	.byte	"V"
>c5ae  57                          	.byte	"W"
>c5af  5e                          	.byte	"^"
>c5b0  00                          	.byte	$00			; table terminator
.c5b1                              tab_chrt
>c5b1  eb c5                       	.word	TAB_STAR		; table for "*"
>c5b3  ed c5                       	.word	TAB_PLUS		; table for "+"
>c5b5  ef c5                       	.word	TAB_MNUS		; table for "-"
>c5b7  f1 c5                       	.word	TAB_SLAS		; table for "/"
>c5b9  f3 c5                       	.word	TAB_LESS		; table for "<"
>c5bb  f7 c5                       	.word	TAB_EQUL		; table for "="
>c5bd  f9 c5                       	.word	TAB_MORE		; table for ">"
>c5bf  fd c5                       	.word	TAB_QEST		; table for "?"
>c5c1  ff c5                       	.word	TAB_ASCA		; table for "A"
>c5c3  0c c6                       	.word	TAB_ASCB		; table for "B"
>c5c5  23 c6                       	.word	TAB_ASCC		; table for "C"
>c5c7  38 c6                       	.word	TAB_ASCD		; table for "D"
>c5c9  50 c6                       	.word	TAB_ASCE		; table for "E"
>c5cb  5a c6                       	.word	TAB_ASCF		; table for "F"
>c5cd  63 c6                       	.word	TAB_ASCG		; table for "G"
>c5cf  70 c6                       	.word	TAB_ASCH		; table for "H"
>c5d1  75 c6                       	.word	TAB_ASCI		; table for "I"
>c5d3  86 c6                       	.word	TAB_ASCL		; table for "L"
>c5d5  a7 c6                       	.word	TAB_ASCM		; table for "M"
>c5d7  b2 c6                       	.word	TAB_ASCN		; table for "N"
>c5d9  c4 c6                       	.word	TAB_ASCO		; table for "O"
>c5db  cc c6                       	.word	TAB_ASCP		; table for "P"
>c5dd  df c6                       	.word	TAB_ASCR		; table for "R"
>c5df  0c c7                       	.word	TAB_ASCS		; table for "S"
>c5e1  32 c7                       	.word	TAB_ASCT		; table for "T"
>c5e3  45 c7                       	.word	TAB_ASCU		; table for "U"
>c5e5  54 c7                       	.word	TAB_ASCV		; table for "V"
>c5e7  5e c7                       	.word	TAB_ASCW		; table for "W"
>c5e9  6d c7                       	.word	TAB_POWR		; table for "^"
.c5eb                              tab_star
>c5eb  b7 00                       	.byte TK_MUL,$00		; *
.c5ed                              tab_plus
>c5ed  b5 00                       	.byte TK_PLUS,$00		; +
.c5ef                              tab_mnus
>c5ef  b6 00                       	.byte TK_MINUS,$00	; -
.c5f1                              tab_slas
>c5f1  b8 00                       	.byte TK_DIV,$00		; /
.c5f3                              tab_less
.c5f3                              lbb_lshift
>c5f3  3c be                       	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
>c5f5  c1                          	.byte TK_LT			; <
>c5f6  00                          	.byte	$00
.c5f7                              tab_equl
>c5f7  c0 00                       	.byte TK_EQUAL,$00	; =
.c5f9                              tab_more
.c5f9                              lbb_rshift
>c5f9  3e bd                       	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
>c5fb  bf                          	.byte TK_GT			; >
>c5fc  00                          	.byte	$00
.c5fd                              tab_qest
>c5fd  9f 00                       	.byte TK_PRINT,$00	; ?
.c5ff                              tab_asca
.c5ff                              lbb_abs
>c5ff  42 53 c4                    	.byte	"BS",TK_ABS		; ABS
.c602                              lbb_and
>c602  4e 44 ba                    	.byte	"ND",TK_AND		; AND
.c605                              lbb_asc
>c605  53 43 d6                    	.byte	"SC",TK_ASC		; ASC
.c608                              lbb_atn
>c608  54 4e cf                    	.byte	"TN",TK_ATN		; ATN
>c60b  00                          	.byte	$00
.c60c                              tab_ascb
.c60c                              lbb_bins
>c60c  49 4e 24 db                 	.byte	"IN$",TK_BINS	; BIN$
.c610                              lbb_bitclr
>c610  49 54 43 4c 52 a8           	.byte	"ITCLR",TK_BITCLR	; BITCLR
.c616                              lbb_bitset
>c616  49 54 53 45 54 a7           	.byte	"ITSET",TK_BITSET	; BITSET
.c61c                              lbb_bittst
>c61c  49 54 54 53 54 dc           	.byte	"ITTST",TK_BITTST	; BITTST
>c622  00                          	.byte	$00
.c623                              tab_ascc
.c623                              lbb_call
>c623  41 4c 4c 9c                 	.byte	"ALL",TK_CALL	; CALL
.c627                              lbb_chrs
>c627  48 52 24 d9                 	.byte	"HR$",TK_CHRS	; CHR$
.c62b                              lbb_clear
>c62b  4c 45 41 52 a2              	.byte	"LEAR",TK_CLEAR	; CLEAR
.c630                              lbb_cont
>c630  4f 4e 54 a0                 	.byte	"ONT",TK_CONT	; CONT
.c634                              lbb_cos
>c634  4f 53 cc                    	.byte	"OS",TK_COS		; COS
>c637  00                          	.byte	$00
.c638                              tab_ascd
.c638                              lbb_data
>c638  41 54 41 83                 	.byte	"ATA",TK_DATA	; DATA
.c63c                              lbb_dec
>c63c  45 43 88                    	.byte	"EC",TK_DEC		; DEC
.c63f                              lbb_deek
>c63f  45 45 4b d1                 	.byte	"EEK",TK_DEEK	; DEEK
.c643                              lbb_def
>c643  45 46 99                    	.byte	"EF",TK_DEF		; DEF
.c646                              lbb_dim
>c646  49 4d 85                    	.byte	"IM",TK_DIM		; DIM
.c649                              lbb_doke
>c649  4f 4b 45 9b                 	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
.c64d                              lbb_do
>c64d  4f 9d                       	.byte	"O",TK_DO		; DO
>c64f  00                          	.byte	$00
.c650                              tab_asce
.c650                              lbb_end
>c650  4e 44 80                    	.byte	"ND",TK_END		; END
.c653                              lbb_eor
>c653  4f 52 bb                    	.byte	"OR",TK_EOR		; EOR
.c656                              lbb_exp
>c656  58 50 cb                    	.byte	"XP",TK_EXP		; EXP
>c659  00                          	.byte	$00
.c65a                              tab_ascf
.c65a                              lbb_fn
>c65a  4e ad                       	.byte	"N",TK_FN		; FN
.c65c                              lbb_for
>c65c  4f 52 81                    	.byte	"OR",TK_FOR		; FOR
.c65f                              lbb_fre
>c65f  52 45 c6                    	.byte	"RE",TK_FRE		; FRE
>c662  00                          	.byte	$00
.c663                              tab_ascg
.c663                              lbb_get
>c663  45 54 a5                    	.byte	"ET",TK_GET		; GET
.c666                              lbb_gosub
>c666  4f 53 55 42 8d              	.byte	"OSUB",TK_GOSUB	; GOSUB
.c66b                              lbb_goto
>c66b  4f 54 4f 89                 	.byte	"OTO",TK_GOTO	; GOTO
>c66f  00                          	.byte	$00
.c670                              tab_asch
.c670                              lbb_hexs
>c670  45 58 24 da 00              	.byte	"EX$",TK_HEXS,$00	; HEX$
.c675                              tab_asci
.c675                              lbb_if
>c675  46 8b                       	.byte	"F",TK_IF		; IF
.c677                              lbb_inc
>c677  4e 43 95                    	.byte	"NC",TK_INC		; INC
.c67a                              lbb_input
>c67a  4e 50 55 54 84              	.byte	"NPUT",TK_INPUT	; INPUT
.c67f                              lbb_int
>c67f  4e 54 c3                    	.byte	"NT",TK_INT		; INT
.c682                              lbb_irq
>c682  52 51 a9                    	.byte	"RQ",TK_IRQ		; IRQ
>c685  00                          	.byte	$00
.c686                              tab_ascl
.c686                              lbb_lcases
>c686  43 41 53 45 24 d8           	.byte	"CASE$",TK_LCASES	; LCASE$
.c68c                              lbb_lefts
>c68c  45 46 54 24 e2              	.byte	"EFT$",TK_LEFTS	; LEFT$
.c691                              lbb_len
>c691  45 4e d3                    	.byte	"EN",TK_LEN		; LEN
.c694                              lbb_let
>c694  45 54 87                    	.byte	"ET",TK_LET		; LET
.c697                              lbb_list
>c697  49 53 54 a1                 	.byte	"IST",TK_LIST	; LIST
.c69b                              lbb_load
>c69b  4f 41 44 97                 	.byte	"OAD",TK_LOAD	; LOAD
.c69f                              lbb_log
>c69f  4f 47 ca                    	.byte	"OG",TK_LOG		; LOG
.c6a2                              lbb_loop
>c6a2  4f 4f 50 9e                 	.byte	"OOP",TK_LOOP	; LOOP
>c6a6  00                          	.byte	$00
.c6a7                              tab_ascm
.c6a7                              lbb_max
>c6a7  41 58 dd                    	.byte	"AX",TK_MAX		; MAX
.c6aa                              lbb_mids
>c6aa  49 44 24 e4                 	.byte	"ID$",TK_MIDS	; MID$
.c6ae                              lbb_min
>c6ae  49 4e de                    	.byte	"IN",TK_MIN		; MIN
>c6b1  00                          	.byte	$00
.c6b2                              tab_ascn
.c6b2                              lbb_new
>c6b2  45 57 a3                    	.byte	"EW",TK_NEW		; NEW
.c6b5                              lbb_next
>c6b5  45 58 54 82                 	.byte	"EXT",TK_NEXT	; NEXT
.c6b9                              lbb_nmi
>c6b9  4d 49 aa                    	.byte	"MI",TK_NMI		; NMI
.c6bc                              lbb_not
>c6bc  4f 54 b0                    	.byte	"OT",TK_NOT		; NOT
.c6bf                              lbb_null
>c6bf  55 4c 4c 94                 	.byte	"ULL",TK_NULL	; NULL
>c6c3  00                          	.byte	$00
.c6c4                              tab_asco
.c6c4                              lbb_off
>c6c4  46 46 b4                    	.byte	"FF",TK_OFF		; OFF
.c6c7                              lbb_on
>c6c7  4e 93                       	.byte	"N",TK_ON		; ON
.c6c9                              lbb_or
>c6c9  52 bc                       	.byte	"R",TK_OR		; OR
>c6cb  00                          	.byte	$00
.c6cc                              tab_ascp
.c6cc                              lbb_peek
>c6cc  45 45 4b d0                 	.byte	"EEK",TK_PEEK	; PEEK
.c6d0                              lbb_pi
>c6d0  49 df                       	.byte	"I",TK_PI		; PI
.c6d2                              lbb_poke
>c6d2  4f 4b 45 9a                 	.byte	"OKE",TK_POKE	; POKE
.c6d6                              lbb_pos
>c6d6  4f 53 c7                    	.byte	"OS",TK_POS		; POS
.c6d9                              lbb_print
>c6d9  52 49 4e 54 9f              	.byte	"RINT",TK_PRINT	; PRINT
>c6de  00                          	.byte	$00
.c6df                              tab_ascr
.c6df                              lbb_read
>c6df  45 41 44 86                 	.byte	"EAD",TK_READ	; READ
.c6e3                              lbb_rem
>c6e3  45 4d 91                    	.byte	"EM",TK_REM		; REM
.c6e6                              lbb_restore
>c6e6  45 53 54 4f 52 45 8c        	.byte	"ESTORE",TK_RESTORE	; RESTORE
.c6ed                              lbb_retirq
>c6ed  45 54 49 52 51 8e           	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
.c6f3                              lbb_retnmi
>c6f3  45 54 4e 4d 49 8f           	.byte	"ETNMI",TK_RETNMI	; RETNMI
.c6f9                              lbb_return
>c6f9  45 54 55 52 4e 90           	.byte	"ETURN",TK_RETURN	; RETURN
.c6ff                              lbb_rights
>c6ff  49 47 48 54 24 e3           	.byte	"IGHT$",TK_RIGHTS	; RIGHT$
.c705                              lbb_rnd
>c705  4e 44 c9                    	.byte	"ND",TK_RND		; RND
.c708                              lbb_run
>c708  55 4e 8a                    	.byte	"UN",TK_RUN		; RUN
>c70b  00                          	.byte	$00
.c70c                              tab_ascs
.c70c                              lbb_sadd
>c70c  41 44 44 d2                 	.byte	"ADD",TK_SADD	; SADD
.c710                              lbb_save
>c710  41 56 45 98                 	.byte	"AVE",TK_SAVE	; SAVE
.c714                              lbb_sgn
>c714  47 4e c2                    	.byte	"GN",TK_SGN		; SGN
.c717                              lbb_sin
>c717  49 4e cd                    	.byte	"IN",TK_SIN		; SIN
.c71a                              lbb_spc
>c71a  50 43 28 ae                 	.byte	"PC(",TK_SPC	; SPC(
.c71e                              lbb_sqr
>c71e  51 52 c8                    	.byte	"QR",TK_SQR		; SQR
.c721                              lbb_step
>c721  54 45 50 b1                 	.byte	"TEP",TK_STEP	; STEP
.c725                              lbb_stop
>c725  54 4f 50 92                 	.byte	"TOP",TK_STOP	; STOP
.c729                              lbb_strs
>c729  54 52 24 d4                 	.byte	"TR$",TK_STRS	; STR$
.c72d                              lbb_swap
>c72d  57 41 50 a6                 	.byte	"WAP",TK_SWAP	; SWAP
>c731  00                          	.byte	$00
.c732                              tab_asct
.c732                              lbb_tab
>c732  41 42 28 ab                 	.byte	"AB(",TK_TAB	; TAB(
.c736                              lbb_tan
>c736  41 4e ce                    	.byte	"AN",TK_TAN		; TAN
.c739                              lbb_then
>c739  48 45 4e af                 	.byte	"HEN",TK_THEN	; THEN
.c73d                              lbb_to
>c73d  4f ac                       	.byte	"O",TK_TO		; TO
.c73f                              lbb_twopi
>c73f  57 4f 50 49 e0              	.byte	"WOPI",TK_TWOPI	; TWOPI
>c744  00                          	.byte	$00
.c745                              tab_ascu
.c745                              lbb_ucases
>c745  43 41 53 45 24 d7           	.byte	"CASE$",TK_UCASES	; UCASE$
.c74b                              lbb_until
>c74b  4e 54 49 4c b2              	.byte	"NTIL",TK_UNTIL	; UNTIL
.c750                              lbb_usr
>c750  53 52 c5                    	.byte	"SR",TK_USR		; USR
>c753  00                          	.byte	$00
.c754                              tab_ascv
.c754                              lbb_val
>c754  41 4c d5                    	.byte	"AL",TK_VAL		; VAL
.c757                              lbb_vptr
>c757  41 52 50 54 52 e1           	.byte	"ARPTR",TK_VPTR	; VARPTR
>c75d  00                          	.byte	$00
.c75e                              tab_ascw
.c75e                              lbb_wait
>c75e  41 49 54 96                 	.byte	"AIT",TK_WAIT	; WAIT
.c762                              lbb_while
>c762  48 49 4c 45 b3              	.byte	"HILE",TK_WHILE	; WHILE
.c767                              lbb_width
>c767  49 44 54 48 a4              	.byte	"IDTH",TK_WIDTH	; WIDTH
>c76c  00                          	.byte	$00
.c76d                              tab_powr
>c76d  b9 00                       	.byte	TK_POWER,$00	; ^
.c76f                              lab_keyt
>c76f  03 45                       	.byte	3,"E"
>c771  50 c6                       	.word	LBB_END		; END
>c773  03 46                       	.byte	3,"F"
>c775  5c c6                       	.word	LBB_FOR		; FOR
>c777  04 4e                       	.byte	4,"N"
>c779  b5 c6                       	.word	LBB_NEXT		; NEXT
>c77b  04 44                       	.byte	4,"D"
>c77d  38 c6                       	.word	LBB_DATA		; DATA
>c77f  05 49                       	.byte	5,"I"
>c781  7a c6                       	.word	LBB_INPUT		; INPUT
>c783  03 44                       	.byte	3,"D"
>c785  46 c6                       	.word	LBB_DIM		; DIM
>c787  04 52                       	.byte	4,"R"
>c789  df c6                       	.word	LBB_READ		; READ
>c78b  03 4c                       	.byte	3,"L"
>c78d  94 c6                       	.word	LBB_LET		; LET
>c78f  03 44                       	.byte	3,"D"
>c791  3c c6                       	.word	LBB_DEC		; DEC
>c793  04 47                       	.byte	4,"G"
>c795  6b c6                       	.word	LBB_GOTO		; GOTO
>c797  03 52                       	.byte	3,"R"
>c799  08 c7                       	.word	LBB_RUN		; RUN
>c79b  02 49                       	.byte	2,"I"
>c79d  75 c6                       	.word	LBB_IF		; IF
>c79f  07 52                       	.byte	7,"R"
>c7a1  e6 c6                       	.word	LBB_RESTORE		; RESTORE
>c7a3  05 47                       	.byte	5,"G"
>c7a5  66 c6                       	.word	LBB_GOSUB		; GOSUB
>c7a7  06 52                       	.byte	6,"R"
>c7a9  ed c6                       	.word	LBB_RETIRQ		; RETIRQ
>c7ab  06 52                       	.byte	6,"R"
>c7ad  f3 c6                       	.word	LBB_RETNMI		; RETNMI
>c7af  06 52                       	.byte	6,"R"
>c7b1  f9 c6                       	.word	LBB_RETURN		; RETURN
>c7b3  03 52                       	.byte	3,"R"
>c7b5  e3 c6                       	.word	LBB_REM		; REM
>c7b7  04 53                       	.byte	4,"S"
>c7b9  25 c7                       	.word	LBB_STOP		; STOP
>c7bb  02 4f                       	.byte	2,"O"
>c7bd  c7 c6                       	.word	LBB_ON		; ON
>c7bf  04 4e                       	.byte	4,"N"
>c7c1  bf c6                       	.word	LBB_NULL		; NULL
>c7c3  03 49                       	.byte	3,"I"
>c7c5  77 c6                       	.word	LBB_INC		; INC
>c7c7  04 57                       	.byte	4,"W"
>c7c9  5e c7                       	.word	LBB_WAIT		; WAIT
>c7cb  04 4c                       	.byte	4,"L"
>c7cd  9b c6                       	.word	LBB_LOAD		; LOAD
>c7cf  04 53                       	.byte	4,"S"
>c7d1  10 c7                       	.word	LBB_SAVE		; SAVE
>c7d3  03 44                       	.byte	3,"D"
>c7d5  43 c6                       	.word	LBB_DEF		; DEF
>c7d7  04 50                       	.byte	4,"P"
>c7d9  d2 c6                       	.word	LBB_POKE		; POKE
>c7db  04 44                       	.byte	4,"D"
>c7dd  49 c6                       	.word	LBB_DOKE		; DOKE
>c7df  04 43                       	.byte	4,"C"
>c7e1  23 c6                       	.word	LBB_CALL		; CALL
>c7e3  02 44                       	.byte	2,"D"
>c7e5  4d c6                       	.word	LBB_DO		; DO
>c7e7  04 4c                       	.byte	4,"L"
>c7e9  a2 c6                       	.word	LBB_LOOP		; LOOP
>c7eb  05 50                       	.byte	5,"P"
>c7ed  d9 c6                       	.word	LBB_PRINT		; PRINT
>c7ef  04 43                       	.byte	4,"C"
>c7f1  30 c6                       	.word	LBB_CONT		; CONT
>c7f3  04 4c                       	.byte	4,"L"
>c7f5  97 c6                       	.word	LBB_LIST		; LIST
>c7f7  05 43                       	.byte	5,"C"
>c7f9  2b c6                       	.word	LBB_CLEAR		; CLEAR
>c7fb  03 4e                       	.byte	3,"N"
>c7fd  b2 c6                       	.word	LBB_NEW		; NEW
>c7ff  05 57                       	.byte	5,"W"
>c801  67 c7                       	.word	LBB_WIDTH		; WIDTH
>c803  03 47                       	.byte	3,"G"
>c805  63 c6                       	.word	LBB_GET		; GET
>c807  04 53                       	.byte	4,"S"
>c809  2d c7                       	.word	LBB_SWAP		; SWAP
>c80b  06 42                       	.byte	6,"B"
>c80d  16 c6                       	.word	LBB_BITSET		; BITSET
>c80f  06 42                       	.byte	6,"B"
>c811  10 c6                       	.word	LBB_BITCLR		; BITCLR
>c813  03 49                       	.byte	3,"I"
>c815  82 c6                       	.word	LBB_IRQ		; IRQ
>c817  03 4e                       	.byte	3,"N"
>c819  b9 c6                       	.word	LBB_NMI		; NMI
>c81b  04 54                       	.byte	4,"T"
>c81d  32 c7                       	.word	LBB_TAB		; TAB
>c81f  02 54                       	.byte	2,"T"
>c821  3d c7                       	.word	LBB_TO		; TO
>c823  02 46                       	.byte	2,"F"
>c825  5a c6                       	.word	LBB_FN		; FN
>c827  04 53                       	.byte	4,"S"
>c829  1a c7                       	.word	LBB_SPC		; SPC
>c82b  04 54                       	.byte	4,"T"
>c82d  39 c7                       	.word	LBB_THEN		; THEN
>c82f  03 4e                       	.byte	3,"N"
>c831  bc c6                       	.word	LBB_NOT		; NOT
>c833  04 53                       	.byte	4,"S"
>c835  21 c7                       	.word	LBB_STEP		; STEP
>c837  05 55                       	.byte	5,"U"
>c839  4b c7                       	.word	LBB_UNTIL		; UNTIL
>c83b  05 57                       	.byte	5,"W"
>c83d  62 c7                       	.word	LBB_WHILE		; WHILE
>c83f  03 4f                       	.byte	3,"O"
>c841  c4 c6                       	.word	LBB_OFF		; OFF
>c843  01 2b                       	.byte	1,"+"
>c845  00 00                       	.word	$0000			; +
>c847  01 2d                       	.byte	1,"-"
>c849  00 00                       	.word	$0000			; -
>c84b  01 2a                       	.byte	1,"*"
>c84d  00 00                       	.word	$0000			; *
>c84f  01 2f                       	.byte	1,"/"
>c851  00 00                       	.word	$0000			; /
>c853  01 5e                       	.byte	1,"^"
>c855  00 00                       	.word	$0000			; ^
>c857  03 41                       	.byte	3,"A"
>c859  02 c6                       	.word	LBB_AND		; AND
>c85b  03 45                       	.byte	3,"E"
>c85d  53 c6                       	.word	LBB_EOR		; EOR
>c85f  02 4f                       	.byte	2,"O"
>c861  c9 c6                       	.word	LBB_OR		; OR
>c863  02 3e                       	.byte	2,">"
>c865  f9 c5                       	.word	LBB_RSHIFT		; >>
>c867  02 3c                       	.byte	2,"<"
>c869  f3 c5                       	.word	LBB_LSHIFT		; <<
>c86b  01 3e                       	.byte	1,">"
>c86d  00 00                       	.word	$0000			; >
>c86f  01 3d                       	.byte	1,"="
>c871  00 00                       	.word	$0000			; =
>c873  01 3c                       	.byte	1,"<"
>c875  00 00                       	.word	$0000			; <
>c877  03 53                       	.byte	3,"S"
>c879  14 c7                       	.word	LBB_SGN		; SGN
>c87b  03 49                       	.byte	3,"I"
>c87d  7f c6                       	.word	LBB_INT		; INT
>c87f  03 41                       	.byte	3,"A"
>c881  ff c5                       	.word	LBB_ABS		; ABS
>c883  03 55                       	.byte	3,"U"
>c885  50 c7                       	.word	LBB_USR		; USR
>c887  03 46                       	.byte	3,"F"
>c889  5f c6                       	.word	LBB_FRE		; FRE
>c88b  03 50                       	.byte	3,"P"
>c88d  d6 c6                       	.word	LBB_POS		; POS
>c88f  03 53                       	.byte	3,"S"
>c891  1e c7                       	.word	LBB_SQR		; SQR
>c893  03 52                       	.byte	3,"R"
>c895  05 c7                       	.word	LBB_RND		; RND
>c897  03 4c                       	.byte	3,"L"
>c899  9f c6                       	.word	LBB_LOG		; LOG
>c89b  03 45                       	.byte	3,"E"
>c89d  56 c6                       	.word	LBB_EXP		; EXP
>c89f  03 43                       	.byte	3,"C"
>c8a1  34 c6                       	.word	LBB_COS		; COS
>c8a3  03 53                       	.byte	3,"S"
>c8a5  17 c7                       	.word	LBB_SIN		; SIN
>c8a7  03 54                       	.byte	3,"T"
>c8a9  36 c7                       	.word	LBB_TAN		; TAN
>c8ab  03 41                       	.byte	3,"A"
>c8ad  08 c6                       	.word	LBB_ATN		; ATN
>c8af  04 50                       	.byte	4,"P"
>c8b1  cc c6                       	.word	LBB_PEEK		; PEEK
>c8b3  04 44                       	.byte	4,"D"
>c8b5  3f c6                       	.word	LBB_DEEK		; DEEK
>c8b7  04 53                       	.byte	4,"S"
>c8b9  0c c7                       	.word	LBB_SADD		; SADD
>c8bb  03 4c                       	.byte	3,"L"
>c8bd  91 c6                       	.word	LBB_LEN		; LEN
>c8bf  04 53                       	.byte	4,"S"
>c8c1  29 c7                       	.word	LBB_STRS		; STR$
>c8c3  03 56                       	.byte	3,"V"
>c8c5  54 c7                       	.word	LBB_VAL		; VAL
>c8c7  03 41                       	.byte	3,"A"
>c8c9  05 c6                       	.word	LBB_ASC		; ASC
>c8cb  06 55                       	.byte	6,"U"
>c8cd  45 c7                       	.word	LBB_UCASES		; UCASE$
>c8cf  06 4c                       	.byte	6,"L"
>c8d1  86 c6                       	.word	LBB_LCASES		; LCASE$
>c8d3  04 43                       	.byte	4,"C"
>c8d5  27 c6                       	.word	LBB_CHRS		; CHR$
>c8d7  04 48                       	.byte	4,"H"
>c8d9  70 c6                       	.word	LBB_HEXS		; HEX$
>c8db  04 42                       	.byte	4,"B"
>c8dd  0c c6                       	.word	LBB_BINS		; BIN$
>c8df  06 42                       	.byte	6,"B"
>c8e1  1c c6                       	.word	LBB_BITTST		; BITTST
>c8e3  03 4d                       	.byte	3,"M"
>c8e5  a7 c6                       	.word	LBB_MAX		; MAX
>c8e7  03 4d                       	.byte	3,"M"
>c8e9  ae c6                       	.word	LBB_MIN		; MIN
>c8eb  02 50                       	.byte	2,"P"
>c8ed  d0 c6                       	.word	LBB_PI		; PI
>c8ef  05 54                       	.byte	5,"T"
>c8f1  3f c7                       	.word	LBB_TWOPI		; TWOPI
>c8f3  06 56                       	.byte	6,"V"
>c8f5  57 c7                       	.word	LBB_VPTR		; VARPTR
>c8f7  05 4c                       	.byte	5,"L"
>c8f9  8c c6                       	.word	LBB_LEFTS		; LEFT$
>c8fb  06 52                       	.byte	6,"R"
>c8fd  ff c6                       	.word	LBB_RIGHTS		; RIGHT$
>c8ff  04 4d                       	.byte	4,"M"
>c901  aa c6                       	.word	LBB_MIDS		; MID$
.c903                              lab_baer
>c903  27 c9                       	.word	LAB_NF		;$00 NEXT without FOR
>c905  38 c9                       	.word	LAB_SN		;$02 syntax
>c907  3f c9                       	.word	LAB_RG		;$04 RETURN without GOSUB
>c909  54 c9                       	.word	LAB_OD		;$06 out of data
>c90b  60 c9                       	.word	LAB_FC		;$08 function call
>c90d  6e c9                       	.word	LAB_OV		;$0A overflow
>c90f  77 c9                       	.word	LAB_OM		;$0C out of memory
>c911  85 c9                       	.word	LAB_US		;$0E undefined statement
>c913  99 c9                       	.word	LAB_BS		;$10 array bounds
>c915  a6 c9                       	.word	LAB_DD		;$12 double dimension array
>c917  b7 c9                       	.word	LAB_D0		;$14 divide by 0
>c919  c6 c9                       	.word	LAB_ID		;$16 illegal direct
>c91b  d5 c9                       	.word	LAB_TM		;$18 type mismatch
>c91d  e3 c9                       	.word	LAB_LS		;$1A long string
>c91f  f3 c9                       	.word	LAB_ST		;$1C string too complex
>c921  06 ca                       	.word	LAB_CN		;$1E continue error
>c923  15 ca                       	.word	LAB_UF		;$20 undefined function
>c925  28 ca                       	.word LAB_LD		;$22 LOOP without DO
>c927  4e 45 58 54 20 77 69 74 68 6f 75 74 20 46 4f 52 00  LAB_NF	.byte	"NEXT without FOR",$00
>c938  53 79 6e 74 61 78 00        LAB_SN	.byte	"Syntax",$00
>c93f  52 45 54 55 52 4e 20 77 69 74 68 6f 75 74 20 47 4f 53 55 42 00  LAB_RG	.byte	"RETURN without GOSUB",$00
>c954  4f 75 74 20 6f 66 20 44 41 54 41 00  LAB_OD	.byte	"Out of DATA",$00
>c960  46 75 6e 63 74 69 6f 6e 20 63 61 6c 6c 00  LAB_FC	.byte	"Function call",$00
>c96e  4f 76 65 72 66 6c 6f 77 00  LAB_OV	.byte	"Overflow",$00
>c977  4f 75 74 20 6f 66 20 6d 65 6d 6f 72 79 00  LAB_OM	.byte	"Out of memory",$00
>c985  55 6e 64 65 66 69 6e 65 64 20 73 74 61 74 65 6d 65 6e 74 00  LAB_US	.byte	"Undefined statement",$00
>c999  41 72 72 61 79 20 62 6f 75 6e 64 73 00  LAB_BS	.byte	"Array bounds",$00
>c9a6  44 6f 75 62 6c 65 20 64 69 6d 65 6e 73 69 6f 6e 00  LAB_DD	.byte	"Double dimension",$00
>c9b7  44 69 76 69 64 65 20 62 79 20 7a 65 72 6f 00  LAB_D0	.byte	"Divide by zero",$00
>c9c6  49 6c 6c 65 67 61 6c 20 64 69 72 65 63 74 00  LAB_ID	.byte	"Illegal direct",$00
>c9d5  54 79 70 65 20 6d 69 73 6d 61 74 63 68 00  LAB_TM	.byte	"Type mismatch",$00
>c9e3  53 74 72 69 6e 67 20 74 6f 6f 20 6c 6f 6e 67 00  LAB_LS	.byte	"String too long",$00
>c9f3  53 74 72 69 6e 67 20 74 6f 6f 20 63 6f 6d 70 6c 65 78 00  LAB_ST	.byte	"String too complex",$00
>ca06  43 61 6e 27 74 20 63 6f 6e 74 69 6e 75 65 00  LAB_CN	.byte	"Can't continue",$00
>ca15  55 6e 64 65 66 69 6e 65 64 20 66 75 6e 63 74 69 6f 6e 00  LAB_UF	.byte	"Undefined function",$00
>ca28  4c 4f 4f 50 20 77 69 74 68 6f 75 74 20 44 4f 00  LAB_LD	.byte	"LOOP without DO",$00
>ca38  0d 0a 42 72 65 61 6b 00     LAB_BMSG	.byte	$0D,$0A,"Break",$00
>ca40  20 45 72 72 6f 72 00        LAB_EMSG	.byte	" Error",$00
>ca47  20 69 6e 20 6c 69 6e 65 00  LAB_LMSG	.byte	" in line",$00
>ca50  0d 0a 52 65 61 64 79 0d 0a 00  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
>ca5a  20 45 78 74 72 61 20 69 67 6e 6f 72 65 64 0d 0a 00  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
>ca6b  20 52 65 64 6f 20 66 72 6f 6d 20 73 74 61 72 74 0d 0a 00  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
.ca7e                              end
.ca7e                              psave

.ca7e  20 bd ca   jsr $cabd        		jsr	pscan
.ca81  a0 00      ldy #$00         		ldy	#$00
.ca83  a5 11      lda $11          		lda	itempl
.ca85  91 11      sta ($11),y      		sta	(itempl),y
.ca87  c8         iny              		iny
.ca88  a5 12      lda $12          		lda	itemph
.ca8a  91 11      sta ($11),y      		sta	(itempl),y
.ca8c  a6 79      ldx $79          		ldx	smeml
.ca8e  a5 7a      lda $7a          		lda	smemh
.ca90  20 6b e7   jsr $e76b        		jsr	print2byte
.ca93  20 5e e7   jsr $e75e        		jsr	print_cr
.ca96  38         sec              		sec
.ca97  a5 11      lda $11          		lda	itempl
.ca99  e5 79      sbc $79          		sbc	smeml
.ca9b  aa         tax              		tax
.ca9c  a5 12      lda $12          		lda	itemph
.ca9e  e5 7a      sbc $7a          		sbc	smemh
.caa0  20 6b e7   jsr $e76b        		jsr	print2byte
.caa3  20 5e e7   jsr $e75e        		jsr	print_cr
.caa6  60         rts              		rts
.caa7                              pload
.caa7  20 bd ca   jsr $cabd        		jsr	pscan
.caaa  a5 11      lda $11          		lda	itempl
.caac  85 7b      sta $7b          		sta	svarl
.caae  85 7d      sta $7d          		sta	sarryl
.cab0  85 7f      sta $7f          		sta	earryl
.cab2  a5 12      lda $12          		lda	itemph
.cab4  85 7c      sta $7c          		sta	svarh
.cab6  85 7e      sta $7e          		sta	sarryh
.cab8  85 80      sta $80          		sta	earryh
.caba  4c 16 a5   jmp $a516        		JMP   LAB_1319		
.cabd                              pscan
.cabd  a5 79      lda $79          		lda	smeml
.cabf  85 11      sta $11                	sta	itempl
.cac1  a5 7a      lda $7a                	lda	smemh
.cac3  85 12      sta $12                	sta	itemph
.cac5  a0 00      ldy #$00         pscan1	ldy   #$00
.cac7  b1 11      lda ($11),y      		lda   (itempl),y
.cac9  d0 13      bne $cade        		bne   pscan2
.cacb  c8         iny              		iny   
.cacc  b1 11      lda ($11),y      		lda   (itempl),y
.cace  d0 0e      bne $cade        		bne   pscan2
.cad0  18         clc              		clc
.cad1  a9 02      lda #$02         		lda   #$02
.cad3  65 11      adc $11          		adc   itempl
.cad5  85 11      sta $11          		sta	itempl
.cad7  a9 00      lda #$00         		lda	#$00
.cad9  65 12      adc $12          		adc	itemph
.cadb  85 12      sta $12          		sta	itemph
.cadd  60         rts              		rts
.cade  a0 00      ldy #$00         pscan2	ldy   #$00
.cae0  b1 11      lda ($11),y      		lda	(itempl),y
.cae2  aa         tax              		tax
.cae3  c8         iny              		iny
.cae4  b1 11      lda ($11),y      		lda	(itempl),y
.cae6  85 12      sta $12          		sta	itemph
.cae8  86 11      stx $11          		stx	itempl
.caea  80 d9      bra $cac5        		bra	pscan1

.d900  4c 51 d9   jmp $d951        _IEC	 JMP IEC_Init	; initialization code; called at monitor startup
.d903  4c ff df   jmp $dfff        _DOS	 JMP Dos_Init	; main entry to DOS
.d906  4c 76 d9   jmp $d976        _SETTMO  JMP SETTMO	; set IEC bus timeout
.d909  4c 79 d9   jmp $d979        _SETNAM	 JMP SETNAM	; set filename parameters
.d90c  4c 81 d9   jmp $d981        _SETLFS  JMP SETLFS	; set logical file parameters
.d90f  4c 88 d9   jmp $d988        _MEMBOT  JMP MEMBOT	; set bottom of memory
.d912  4c 9c d9   jmp $d99c        _OPEN    JMP OPEN	; open logical file
.d915  4c d7 d9   jmp $d9d7        _CLOSE 	 JMP CLOSE	; close logical file
.d918  4c 1e da   jmp $da1e        _CLALL   JMP CLOSEALL	; close all open logical files
.d91b  4c 2d da   jmp $da2d        _CHKIN	 JMP CHKIN	; set channel for input
.d91e  4c 5e da   jmp $da5e        _CHKOUT	 JMP CHKOUT	; set channel for output
.d921  4c 8d da   jmp $da8d        _GETIN	 JMP GETIN	; get character from head of keyboard buffer
.d924  4c 91 da   jmp $da91        _CHRIN	 JMP CHRIN	; get character from channel
.d927  4c 0a db   jmp $db0a        _CHROUT	 JMP CHROUT	; send character to IEC
.d92a  4c 26 da   jmp $da26        _READST	 JMP READST	; read IEC status variable
.d92d  4c 24 dc   jmp $dc24        _CLRCH	 JMP CLRCH	; clear I/O channels
.d930  4c 93 d9   jmp $d993        _SETMS	 JMP SETMS	; set system message mode
.d933  4c 3b dc   jmp $dc3b        _LOAD	 JMP LOAD	; load
.d936  4c bb dc   jmp $dcbb        _SAVE	 JMP SAVE	; save
.d939  4c a1 da   jmp $daa1        _ACPTR	 JMP ACPTR	; get character from IEC (low-level)
.d93c  4c 1c db   jmp $db1c        _CIOUT	 JMP CIOUT	; output character to IEC (low-level)
.d93f  4c 3f db   jmp $db3f        _LISTEN  JMP LISTEN	; send LISTEN command
.d942  4c 2e db   jmp $db2e        _LSECOND JMP SECOND	; send secondary address
.d945  4c 3c db   jmp $db3c        _TALK	 JMP TALK	; send TALK command
.d948  4c eb db   jmp $dbeb        _TSECOND JMP TALKSA	; send TALK command with secondary address
.d94b  4c 0f dc   jmp $dc0f        _UNLSTN  JMP UNLISTEN	; send UNLISTEN command
.d94e  4c 01 dc   jmp $dc01        _UNTALK  JMP UNTALK	; send UNTALK command
.d951                              iec_init
.d951  a9 80      lda #$80         	lda #$80
.d953  20 93 d9   jsr $d993        	jsr SETMS	; command mode (80=direct; 0=programmed)
.d956  a9 00      lda #$00          	lda #$00	;
.d958  8d 90 02   sta $0290        	sta CSRMOD	; cursor mode (0=direct; 80=programmed)
.d95b  8d 58 7f   sta $7f58        	sta D1TM2L
.d95e  8d 59 7f   sta $7f59        	sta D1TM2H
.d961  20 76 d9   jsr $d976        	jsr SETTMO	; enable timeouts (0=enable; 80=disable)
.d964  a2 03      ldx #$03         	ldx #$03	; screen device
.d966  20 34 dc   jsr $dc34        	jsr CLR2	; set default devices (in CLRCH)
.d969  a0 04      ldy #$04         	ldy #>RAMBOT	; MSB
.d96b  a2 00      ldx #$00         	ldx #<RAMBOT	; LSB
.d96d  18         clc              	clc
.d96e  20 88 d9   jsr $d988        	jsr MEMBOT	; set bottom of RAM to YYXX
.d971  a9 4c      lda #$4c         	lda #$4c
.d973  85 14      sta $14          	sta USRPOK	; set JSR opcode
.d975  60         rts              	rts
.d976                              settmo
.d976  85 1a      sta $1a          	STA STIMOT
.d978  60         rts              	RTS
.d979                              setnam
.d979  8d 8f 02   sta $028f        	STA FNMLEN		;set length
.d97c  86 26      stx $26          	STX FNPTR		;ptr L
.d97e  84 27      sty $27          	STY FNPTR+1		;ptr H
.d980  60         rts              	RTS
.d981                              setlfs
.d981  85 28      sta $28          	STA LOGFIL		;file#
.d983  86 2a      stx $2a          	STX CHANNL		;device
.d985  84 29      sty $29          	STY SECADR		;secondary address
.d987  60         rts              	RTS
.d988                              membot
.d988  90 04      bcc $d98e        	BCC STOBOT
.d98a  a6 17      ldx $17          	LDX OSSTAR		; address L
.d98c  a4 18      ldy $18          	LDY OSSTAR+1		; address H
.d98e                              stobot
.d98e  86 17      stx $17          	STX OSSTAR		; address L
.d990  84 18      sty $18          	STY OSSTAR+1		; address H
.d992  60         rts              	RTS
.d993                              setms
.d993  85 20      sta $20          	STA CMDMOD		;save message #
.d995  a5 19      lda $19          	LDA CSTAT		;get status
.d997                              isetms1
.d997  05 19      ora $19          	ORA CSTAT		;twiddle bits
.d999  85 19      sta $19          	STA CSTAT		;save status
.d99b  60         rts              	RTS
.d99c                              open
.d99c  a6 28      ldx $28          	LDX LOGFIL		;get file number
.d99e  d0 03      bne $d9a3        	BNE IOPEN_S1		;F411 <>0 not "save"
.d9a0  4c 30 de   jmp $de30        	JMP IOERMS6		;$F78D "NOT INPUT FILE" error
.d9a3                              iopen_s1
.d9a3  20 61 dd   jsr $dd61        	JSR FIND		;locate file# in table, X is free spot
.d9a6  d0 03      bne $d9ab        	BNE IOPEN_S2		;F419 not found; any more free spots
.d9a8  4c 24 de   jmp $de24        	JMP IOERMS2		;$F781 "FILE OPEN" error
.d9ab                              iopen_s2
.d9ab  a6 24      ldx $24          	LDX COPNFL		;get # of open files
.d9ad  e0 0a      cpx #$0a         	CPX #$0A		;10 files open?
.d9af  90 03      bcc $d9b4        	BCC IOPEN_S3		;F422 no, OK to open it
.d9b1  4c 21 de   jmp $de21        	JMP IOERMS1		;"TOO MANY FILES" error
.d9b4                              iopen_s3
.d9b4  a5 2a      lda $2a          	LDA CHANNL		; get device#
.d9b6  c9 03      cmp #$03         	CMP #$03
.d9b8  b0 03      bcs $d9bd        	BCS IOPEN_S4		; device 4 or greater, send SA to IEEE
.d9ba  4c 39 de   jmp $de39        	jmp IOERMS9		; anything else, ILLEGAL DEVICE error
.d9bd                              iopen_s4
.d9bd  e6 24      inc $24          	INC COPNFL		;bump count
.d9bf  a5 28      lda $28          	LDA LOGFIL
.d9c1  9d 70 02   sta $0270,x      	STA FILTBL,X		;save file# in table
.d9c4  a5 29      lda $29          	LDA SECADR		;flag and save SA
.d9c6  09 60      ora #$60         	ORA #%01100000		;$60
.d9c8  85 29      sta $29          	STA SECADR
.d9ca  9d 84 02   sta $0284,x      	STA SECATB,X
.d9cd  a5 2a      lda $2a          	LDA CHANNL		;save device
.d9cf  9d 7a 02   sta $027a,x      	STA DEVTBL,X
.d9d2  20 ae dd   jsr $ddae        	JSR SENDSA		;send secondary to IEEE
.d9d5  18         clc              	CLC
.d9d6  60         rts              	RTS
.d9d7                              close
.d9d7  20 66 dd   jsr $dd66        	JSR FIND1		;$F3D4 locate file#
.d9da  f0 02      beq $d9de        	BEQ ICLSE		;$F351 found it, go to closer
.d9dc  18         clc              	CLC
.d9dd  60         rts              	RTS			;not found, return CY=0
.d9de                              iclse
.d9de  20 9e dd   jsr $dd9e        	JSR FLATRB		;get file attributes
.d9e1  8a         txa              	TXA			;save table offset
.d9e2  48         pha              	PHA			;push it
.d9e3  a5 2a      lda $2a          	LDA CHANNL		;get device
.d9e5  c9 03      cmp #$03         	CMP #$03		;screen?
.d9e7  b0 02      bcs $d9eb        	BCS ICLSE1		;$F3AE device#>3, close IEEE 
.d9e9  18         clc              	CLC			; invalid device (<3)
.d9ea  60         rts              	RTS
.d9eb                              iclse1
.d9eb  24 29      bit $29          	BIT SECADR		; test bit7 of secondary address
.d9ed  30 2d      bmi $da1c        	BMI ICLSEX		; if not file-oriented channel, just exit
.d9ef  a5 2a      lda $2a          	LDA CHANNL		;get device number and
.d9f1  20 3f db   jsr $db3f        	JSR LISTEN		;command it to listen
.d9f4  a5 29      lda $29          	LDA SECADR		;get secondary address
.d9f6  29 ef      and #$ef         	AND #%11101111		;$EF
.d9f8  09 e0      ora #$e0         	ORA #%11100000		;$E0 CLOSE command
.d9fa  20 2e db   jsr $db2e        	JSR SECOND		;send secondary address
.d9fd  20 0f dc   jsr $dc0f        	JSR UNLISTEN		;finally, command device to unlisten
.da00  68         pla              	PLA			;restore table offset
.da01  aa         tax              	TAX
.da02  c6 24      dec $24          	DEC COPNFL		;decrement # of open files
.da04  e4 24      cpx $24          	CPX COPNFL		;no more files open, go to ready
.da06  f0 14      beq $da1c        	BEQ ICLSEX		;$F3CD return CY=0
.da08  a4 24      ldy $24          	LDY COPNFL		;delete device by moving last entry
.da0a  b9 70 02   lda $0270,y       	LDA FILTBL,Y		;in table into deleted position
.da0d  9d 70 02   sta $0270,x      	STA FILTBL,X
.da10  b9 7a 02   lda $027a,y      	LDA DEVTBL,Y
.da13  9d 7a 02   sta $027a,x      	STA DEVTBL,X
.da16  b9 84 02   lda $0284,y      	LDA SECATB,Y
.da19  9d 84 02   sta $0284,x      	STA SECATB,X
.da1c                              iclsex
.da1c  18         clc              	CLC
.da1d  60         rts              	RTS			;exit clear
.da1e                              closeall
.da1e  a9 00      lda #$00         	LDA #$00
.da20  85 24      sta $24          	STA COPNFL		;zero-out count of open files
.da22  20 24 dc   jsr $dc24        	JSR CLRCH		; restore I/O channels
.da25  60         rts              	RTS
.da26                              readst
.da26  a5 19      lda $19          	LDA CSTAT		;get status
.da28  05 19      ora $19          	ORA CSTAT		;clear status bits
.da2a  85 19      sta $19          	STA CSTAT		;save status
.da2c  60         rts              	RTS			
.da2d                              chkin
.da2d  20 61 dd   jsr $dd61        	JSR FIND		;find file# in tables
.da30  f0 03      beq $da35        	BEQ ICHKI1		;$F2CF found, continue
.da32  4c 27 de   jmp $de27        	JMP IOERMS3		;'FILE NOT OPEN' error
.da35                              ichki1
.da35  20 9e dd   jsr $dd9e        	JSR FLATRB		;set file# params
.da38  a5 2a      lda $2a          	LDA CHANNL		;get device 
.da3a  c9 03      cmp #$03         	CMP #$03
.da3c  b0 03      bcs $da41        	BCS ICHKI3		;$F2F0 IEEE? yes, handle IEEE
.da3e  4c 39 de   jmp $de39        	jmp IOERMS9		; ILLEGAL DEVICE
.da41                              ichki3
.da41  aa         tax              	TAX			;copy device
.da42  20 3c db   jsr $db3c        	JSR TALK		;command device to talk 
.da45  a5 29      lda $29          	LDA SECADR		;is there a secondary address?
.da47  10 06      bpl $da4f        	BPL ICHKI4		;$F2FE yes, send it
.da49  20 f0 db   jsr $dbf0        	JSR CLKWAIT		;no, send regular talk command
.da4c  4c 52 da   jmp $da52        	jmp ICHKI5		;$F301
.da4f                              ichki4
.da4f  20 eb db   jsr $dbeb        	JSR TALKSA		;send secondary address talk
.da52                              ichki5
.da52  8a         txa              	TXA			;restore device#
.da53  24 19      bit $19          	BIT CSTAT		;BIT7= Dev not present
.da55  10 03      bpl $da5a        	BPL ICHKIEX		;all clear, exit
.da57  4c 2d de   jmp $de2d        	JMP IOERMS5		;"DEVICE NOT PRESENT" error; Exit
.da5a                              ichkiex
.da5a  85 1e      sta $1e          	STA INDEV		; save as input device
.da5c  18         clc              	CLC
.da5d  60         rts              	RTS
.da5e                              chkout
.da5e  20 61 dd   jsr $dd61        	JSR FIND		;locate file# in tables
.da61  f0 03      beq $da66        	BEQ ICHKO1		;$F311 found, continue
.da63  4c 27 de   jmp $de27        	JMP IOERMS3		;$F784 "FILE NOT OPEN" error
.da66                              ichko1
.da66  20 9e dd   jsr $dd9e        	JSR FLATRB		;set file attributes
.da69  a5 2a      lda $2a          	LDA CHANNL		;get device
.da6b  c9 03      cmp #$03         	CMP #$03
.da6d  b0 02      bcs $da71        	BCS ICHKO2		;$F2F0 IEEE? yes, handle IEEE
.da6f  18         clc              	CLC
.da70  60         rts              	RTS
.da71                              ichko2
.da71  aa         tax              	TAX			;save device#
.da72  20 3f db   jsr $db3f        	JSR LISTEN		;command device to listen
.da75  a5 29      lda $29          	LDA SECADR		;is there an SA?
.da77  10 05      bpl $da7e        	BPL ICHKO_S4		;$F33F yes, send SA
.da79  20 33 db   jsr $db33        	JSR CLRATN		;no, clear ATN line and make sure
.da7c  d0 03      bne $da81        	BNE ICHKO_S5		; device is present
.da7e                              ichko_s4
.da7e  20 2e db   jsr $db2e        	JSR SECOND		;send SA
.da81                              ichko_s5
.da81  8a         txa              	TXA			;restore device#
.da82  24 19      bit $19          	BIT CSTAT		;BIT7=Dev not present
.da84  10 03      bpl $da89        	BPL ICHKO_S6		;$F32E
.da86  4c 2d de   jmp $de2d        	JMP IOERMS5		;$F78A "DEVICE NOT PRESENT" error
.da89                              ichko_s6
.da89  85 1f      sta $1f          	STA OUTDEV		;set OUTDEV and exit
.da8b  18         clc              	CLC
.da8c  60         rts              	RTS
.da8d                              getin
.da8d  20 0a e8   jsr $e80a        	JSR Scan_Input		; map KERNAL routine to SBCOS
.da90  60         rts              	RTS
.da91                              chrin
.da91  a5 1e      lda $1e          	LDA INDEV		;get input device
.da93  c9 03      cmp #$03         	CMP #$03		; allowed IEC device?
.da95  b0 02      bcs $da99        	BCS CHINIE		; yes, go get char
.da97  18         clc              	CLC			; return clear
.da98  60         rts              	RTS
.da99                              chinie
.da99  a5 19      lda $19          	LDA CSTAT		;any IEEE errors? 
.da9b  f0 04      beq $daa1        	BEQ ACPTR		;no, get next char from device
.da9d  a9 0d      lda #$0d         	LDA #$0D		;yes, return <CR> and exit
.da9f  18         clc              	CLC
.daa0  60         rts              	RTS
.daa1                              acptr
.daa1  78         sei              	SEI           		;kill interrupts
.daa2  a9 00      lda #$00         	LDA #$00			
.daa4  85 23      sta $23          	STA CNTDN		;zero-out bit count
.daa6  20 41 dd   jsr $dd41        	JSR SCLK1		;assert CLK
.daa9                              iacplp1
.daa9  20 37 dd   jsr $dd37        	JSR SDCLK		;get CLK answer
.daac  90 fb      bcc $daa9        	BCC IACPLP1		;wait for CLK=H
.daae  20 25 dd   jsr $dd25        	JSR SOUT1		; answer with DATA=H
.dab1                              iacptr1
.dab1  a9 01      lda #$01         	LDA #$01		; delay for 256us...
.dab3  8d 59 7f   sta $7f59        	STA D1TM2H
.dab6                              iacplp2
.dab6  ad 5d 7f   lda $7f5d        	LDA D1IFR
.dab9  29 20      and #$20         	AND #%00100000		;Timer2 time-out flagged?
.dabb  d0 07      bne $dac4        	BNE IACPTR2
.dabd  20 37 dd   jsr $dd37        	JSR SDCLK		;...then check CLK again
.dac0  b0 f4      bcs $dab6        	BCS IACPLP2		;CLK=H, then EOI (ignore)
.dac2  90 16      bcc $dada        	BCC IACPTR3A		;CLK=L, then start clocking data
.dac4                              iacptr2
.dac4  a5 23      lda $23          	LDA CNTDN		; get bit count
.dac6  f0 03      beq $dacb        	BEQ IACPTR3		; no more to shift, move on
.dac8  4c df db   jmp $dbdf        	JMP FLGER02		; error code 2 (read timeout)
.dacb                              iacptr3
.dacb  20 2e dd   jsr $dd2e        	JSR SOUT0		; clear DATA
.dace  20 17 dc   jsr $dc17        	JSR UNLSTN2		; send unlisten
.dad1  a9 40      lda #$40         	LDA #$40		;EOF error
.dad3  20 97 d9   jsr $d997        	JSR ISETMS1
.dad6  e6 23      inc $23          	INC CNTDN
.dad8  d0 d7      bne $dab1        	BNE IACPTR1
.dada                              iacptr3a
.dada  a9 08      lda #$08         	LDA #$08		;set bit count
.dadc  85 23      sta $23          	STA CNTDN		
.dade                              iacplp4
.dade  ad 5f 7f   lda $7f5f        	LDA D1ORAH
.dae1  cd 5f 7f   cmp $7f5f        	CMP D1ORAH
.dae4  d0 f8      bne $dade        	BNE IACPLP4
.dae6  4a         lsr              	LSR A
.dae7  90 f5      bcc $dade        	BCC IACPLP4
.dae9  4a         lsr              	LSR A
.daea  66 22      ror $22          	ROR CYCLE
.daec                              iacplp5
.daec  ad 5f 7f   lda $7f5f        	LDA D1ORAH
.daef  cd 5f 7f   cmp $7f5f        	CMP D1ORAH
.daf2  d0 f8      bne $daec        	BNE IACPLP5
.daf4  4a         lsr              	LSR A
.daf5  b0 f5      bcs $daec        	BCS IACPLP5
.daf7  c6 23      dec $23          	DEC CNTDN
.daf9  d0 e3      bne $dade        	BNE IACPLP4
.dafb  20 2e dd   jsr $dd2e        	JSR SOUT0		; clear DATA
.dafe  a5 19      lda $19          	LDA CSTAT		; error? 
.db00  f0 03      beq $db05        	BEQ IACPEX		; no, continue shifting
.db02  20 17 dc   jsr $dc17        	JSR UNLSTN2		; yes, unlisten and exit.
.db05                              iacpex
.db05  a5 22      lda $22          	LDA CYCLE
.db07  58         cli              	CLI
.db08  18         clc              	CLC
.db09  60         rts              	RTS
.db0a                              chrout
.db0a  48         pha              	PHA			; save char
.db0b  a5 1f      lda $1f          	LDA OUTDEV		; get output device
.db0d  c9 03      cmp #$03         	CMP #$03		; is it the screen?
.db0f  d0 05      bne $db16        	BNE NOTSCR		; no, test other devices
.db11  68         pla              	PLA			; restore character
.db12  20 0d e8   jsr $e80d        	JSR OUTPUT		; send it to the terminal
.db15  60         rts              	RTS			; and return
.db16                              notscr
.db16  68         pla              	PLA			; restore character; CY should not be effected
.db17  b0 03      bcs $db1c        	BCS CIOUT		; IEC? Yes, send it.
.db19  4c 33 de   jmp $de33        	JMP IOERMS7		; Otherwise, "Not Output File" error
.db1c                              ciout
.db1c  24 1c      bit $1c          	BIT C3PO       		;deferred character?
.db1e  30 05      bmi $db25        	BMI ICIOUT1		; no, send it now	
.db20  38         sec              	SEC
.db21  66 1c      ror $1c          	ROR C3PO
.db23  d0 05      bne $db2a        	BNE ICIOUT2		;send it later
.db25                              iciout1
.db25  48         pha              	PHA			;save byte	
.db26  20 71 db   jsr $db71        	JSR OTDSBU		;send it immediately	
.db29  68         pla              	PLA			;restore it	
.db2a                              iciout2
.db2a  85 1d      sta $1d          	STA BSOUT		;deferred character	
.db2c  18         clc              	CLC
.db2d  60         rts              	RTS
.db2e                              second
.db2e  85 1d      sta $1d          	STA BSOUT		; save secondary address
.db30  20 68 db   jsr $db68        	JSR ILISTEX		; output with ATN
.db33                              clratn
.db33  ad 5f 7f   lda $7f5f        	LDA D1ORAH		; ATN=0, DATA=1, CLK=1
.db36  29 7f      and #$7f         	AND #%01111111		;$7F
.db38  8d 5f 7f   sta $7f5f        	STA D1ORAH			
.db3b  60         rts              	RTS			
.db3c                              talk
.db3c  09 40      ora #$40         	ORA #%01000000		;$40 BIT6 = Talk address

>db3e  2c                          	.byte $2c
.db3f                              listen

.db3f  09 20      ora #$20         	ORA #%00100000		;$20 BIT5 = Listen address
.db41  20 60 dd   jsr $dd60        	JSR SBIDLE		; Wait for RS232 idle state
.db44                              lsnoidle
.db44  48         pha              	PHA			;save device address
.db45  24 1c      bit $1c          	BIT C3PO		;char waiting?
.db47  10 0a      bpl $db53        	BPL LISN1		;no, branch $EE2B
.db49  38         sec              	SEC			;yes, output bit
.db4a  66 21      ror $21          	ROR SBITCF		;bit count
.db4c  20 71 db   jsr $db71        	JSR OTDSBU		;output
.db4f  46 1c      lsr $1c          	LSR C3PO		;go to next
.db51  46 21      lsr $21          	LSR SBITCF			
.db53                              lisn1
.db53  68         pla              	PLA			;restore device address
.db54  85 1d      sta $1d          	STA BSOUT		;save to xmit buffer
.db56  20 25 dd   jsr $dd25        	JSR SOUT1		;send DATA=1
.db59  c9 3f      cmp #$3f         	CMP #%00111111		;$3F Data=0? 7-5=DATA 4=SRQ 3-1=CLK
.db5b  d0 03      bne $db60        	BNE LISN2		;no answer yet, send ATN
.db5d  20 41 dd   jsr $dd41        	JSR SCLK1		;send SCLK=1 answer
.db60                              lisn2
.db60  ad 5f 7f   lda $7f5f        	LDA D1ORAH			
.db63  09 80      ora #$80         	ORA #%10000000		;$80 set PA.7=1 Assert ATN (inverted to 0)
.db65  8d 5f 7f   sta $7f5f        	STA D1ORAH		; (LOW at IEC port is "true" and HIGH is "false")
.db68                              ilistex
.db68  20 4a dd   jsr $dd4a        	JSR SCLK0		;send SCLK=0 (true)
.db6b  20 25 dd   jsr $dd25        	JSR SOUT1		;send DATA=1 (false)
.db6e  20 53 dd   jsr $dd53        	JSR DDELAY		;wait 1ms
.db71                              otdsbu
.db71  78         sei              	SEI			;kill interrupts
.db72  20 25 dd   jsr $dd25        	JSR SOUT1		;send DATA=1
.db75  20 37 dd   jsr $dd37        	JSR SDCLK		;Get clk_in/data_in status
.db78  4a         lsr              	LSR A			;shift to data_in
.db79  b0 61      bcs $dbdc        	BCS FLGERR		;data_in=1, device not present
.db7b  20 41 dd   jsr $dd41        	JSR SCLK1		;got device ack, ack with CLK=1
.db7e  24 21      bit $21          	BIT SBITCF		;more bits?
.db80  10 0c      bpl $db8e        	BPL OTDLP3		;$EE66 yes, skip EOI handler
.db82                              otdlp1
.db82  20 37 dd   jsr $dd37        	JSR SDCLK		;wait for DIn=H
.db85  4a         lsr              	LSR A			;roll data into carry
.db86  90 fa      bcc $db82        	BCC OTDLP1		;$EE5A
.db88                              otdlp2
.db88  20 37 dd   jsr $dd37        	JSR SDCLK		;wait for DIn=L
.db8b  4a         lsr              	LSR A			;roll data into carry
.db8c  b0 fa      bcs $db88        	BCS OTDLP2		;$EE60
.db8e                              otdlp3
.db8e  20 37 dd   jsr $dd37        	JSR SDCLK		;wait again for DIn=H
.db91  4a         lsr              	LSR A			;roll data into carry
.db92  90 fa      bcc $db8e        	BCC OTDLP3		;$EE66
.db94  20 4a dd   jsr $dd4a        	JSR SCLK0		;send CLK=0
.db97  a9 08      lda #$08         	LDA #$08		;bit counter
.db99  85 23      sta $23          	STA CNTDN		;save as bit count-down
.db9b                              otdlp4
.db9b  ad 5f 7f   lda $7f5f        	LDA D1ORAH		;wait for idle
.db9e  cd 5f 7f   cmp $7f5f        	CMP D1ORAH			
.dba1  d0 f8      bne $db9b        	BNE OTDLP4
.dba3  4a         lsr              	LSR A			
.dba4  4a         lsr              	LSR A			; LSR to data_in 
.dba5  90 3b      bcc $dbe2        	BCC FLGER03		; data_in=0 time-out error
.dba7  66 1d      ror $1d          	ROR BSOUT		;get bit
.dba9  b0 05      bcs $dbb0        	BCS OTDSB1		; if 1, send DATA=1
.dbab  20 2e dd   jsr $dd2e        	JSR SOUT0		;not 1, must be 0; DATA=0
.dbae  d0 03      bne $dbb3        	BNE OTDSB2
.dbb0                              otdsb1
.dbb0  20 25 dd   jsr $dd25        	JSR SOUT1		;send DATA=1
.dbb3                              otdsb2
.dbb3  20 41 dd   jsr $dd41        	JSR SCLK1		;clock it out
.dbb6  ea         nop              	nop			;The NOP instruction is 2 clock cycles,
.dbb7  ea         nop              	nop			; so maybe this is a short delay to let
.dbb8  ea         nop              	nop			; signals settle
.dbb9  ea         nop              	nop
.dbba  ad 5c 7f   lda $7f5c        	LDA D1PCR		;get PCR
.dbbd  29 df      and #$df         	AND #%11011111		;$DF CB2=L (DATA=1)
.dbbf  09 02      ora #$02         	ORA #%00000010		;$02 CA2=H (CLK=0)
.dbc1  8d 5c 7f   sta $7f5c        	STA D1PCR		;output it
.dbc4  c6 23      dec $23          	DEC CNTDN		;process next bit
.dbc6  d0 d3      bne $db9b        	BNE OTDLP4		;loop
.dbc8  a9 04      lda #$04         	LDA #$04		;set time-out
.dbca  8d 59 7f   sta $7f59        	STA D1TM2H			
.dbcd                              otdlp5
.dbcd  ad 5d 7f   lda $7f5d        	LDA D1IFR		;test timer
.dbd0  29 20      and #$20         	AND #%00100000		;$20
.dbd2  d0 0e      bne $dbe2        	BNE FLGER03		; bus timeout
.dbd4  20 37 dd   jsr $dd37        	JSR SDCLK		;wait for data_in=L
.dbd7  4a         lsr              	LSR A
.dbd8  b0 f3      bcs $dbcd        	BCS OTDLP5		;$EEA5
.dbda  58         cli              	CLI
.dbdb  60         rts              	RTS
.dbdc                              flgerr
.dbdc  a9 80      lda #$80         	LDA #$80		; Error $80 - device not present

>dbde  2c                          	.byte $2C
.dbdf                              flger02

.dbdf  a9 02      lda #$02         	LDA #$02		; Error $02 - read timeout

>dbe1  2c                          	.byte $2C
.dbe2                              flger03

.dbe2  a9 03      lda #$03         	LDA #$03		; Error $03 - write timeout
.dbe4  20 97 d9   jsr $d997        	JSR ISETMS1		;$FE6A set status
.dbe7  58         cli              	CLI
.dbe8  18         clc              	CLC
.dbe9  90 29      bcc $dc14        	bcc UNLSTN1
.dbeb                              talksa
.dbeb  85 1d      sta $1d          	STA BSOUT     		;save secondary address to xmit
.dbed  20 68 db   jsr $db68        	JSR ILISTEX		; output with ATN
.dbf0                              clkwait
.dbf0  78         sei              	SEI			;kill interrupts
.dbf1  20 2e dd   jsr $dd2e        	JSR SOUT0		;DATA=0
.dbf4  20 33 db   jsr $db33        	JSR CLRATN		;clear ATN
.dbf7  20 41 dd   jsr $dd41        	JSR SCLK1		;CLK=1
.dbfa                              clkwait1
.dbfa  20 37 dd   jsr $dd37        	JSR SDCLK		;wait for CLK=0
.dbfd  b0 fb      bcs $dbfa        	BCS CLKWAIT1
.dbff  58         cli              	CLI			
.dc00  60         rts              	RTS
.dc01                              untalk
.dc01  20 4a dd   jsr $dd4a        	JSR SCLK0		;CLK=0
.dc04  ad 5f 7f   lda $7f5f        	LDA D1ORAH
.dc07  09 80      ora #$80         	ORA #%10000000		;$80 send ATN
.dc09  8d 5f 7f   sta $7f5f        	STA D1ORAH
.dc0c  a9 5f      lda #$5f         	LDA #$5F		; %01011111 UNTALK

>dc0e  2c                          	.byte $2C		;really BIT $3FA9 to skip EF04
.dc0f                              unlisten

.dc0f  a9 3f      lda #$3f         	LDA #$3F		; %00111111 UNLISTEN
.dc11  20 44 db   jsr $db44        	JSR LSNOIDLE		; send UNLSTN; skip idle test
.dc14                              unlstn1
.dc14  20 33 db   jsr $db33        	JSR CLRATN		;clear ATN
.dc17                              unlstn2
.dc17  8a         txa              	TXA			
.dc18  a2 0b      ldx #$0b         	LDX #$0B		;pause loop (40ms)
.dc1a                              iunlp1
.dc1a  ca         dex              	DEX			
.dc1b  d0 fd      bne $dc1a        	BNE IUNLP1		; pause
.dc1d  aa         tax              	TAX			
.dc1e  20 41 dd   jsr $dd41        	JSR SCLK1		;CLK=1
.dc21  4c 25 dd   jmp $dd25        	JMP SOUT1		;DATA=1 EXIT
.dc24                              clrch
.dc24  a2 03      ldx #$03         	LDX #$03		; see if device is output device
.dc26  e4 1f      cpx $1f          	CPX OUTDEV
.dc28  b0 03      bcs $dc2d        	BCS CLR1		; No. See if it's an input device then.
.dc2a  20 0f dc   jsr $dc0f        	JSR UNLISTEN		; Yes. Send unlisten command to IEC
.dc2d                              clr1
.dc2d  e4 1e      cpx $1e          	CPX INDEV
.dc2f  b0 03      bcs $dc34        	BCS CLR2		; No. Restore default devices
.dc31  20 01 dc   jsr $dc01        	JSR UNTALK		; Yes. Send untalk command to IEC
.dc34  86 1f      stx $1f          CLR2	STX OUTDEV
.dc36  a9 00      lda #$00         	LDA #$00
.dc38  85 1e      sta $1e          	STA INDEV		;restore default I/O devices
.dc3a  60         rts              	RTS
.dc3b                              load
.dc3b  86 2d      stx $2d          	STX MEMUSS		;save load location from call
.dc3d  84 2e      sty $2e          	STY MEMUSS+1
.dc3f  85 1b      sta $1b          	STA IOFLG2		;load/verify flag
.dc41  a9 00      lda #$00         	LDA #$00
.dc43  85 19      sta $19          	STA CSTAT		;clear ST 
.dc45  a5 2a      lda $2a          	LDA CHANNL		;get device
.dc47  c9 07      cmp #$07         	CMP #$07		; LOADING from IEC drives allowed
.dc49  b0 03      bcs $dc4e        	BCS SERLOAD
.dc4b  4c 39 de   jmp $de39        	JMP IOERMS9		;exit through "ILLEGAL DEVICE" error
.dc4e                              serload
.dc4e  ac 8f 02   ldy $028f        	LDY FNMLEN		;get filename length
.dc51  d0 03      bne $dc56        	BNE SERLO_S1		;F563 filename required on IEEE
.dc53  4c 36 de   jmp $de36        	JMP IOERMS8		;$F793 "FILENAME MISSING" error
.dc56                              serlo_s1
.dc56  20 8b dd   jsr $dd8b        	JSR SSADR		;$E4BC print "Searching"
.dc59  a9 60      lda #$60         	LDA #$60
.dc5b  85 29      sta $29          	STA SECADR		;set default SA to 0
.dc5d  20 ae dd   jsr $ddae        	JSR SENDSA		;send it
.dc60  a5 2a      lda $2a          	LDA CHANNL		;get device
.dc62  20 3c db   jsr $db3c        	JSR TALK		;command it to talk
.dc65  a5 29      lda $29          	LDA SECADR		;get SA
.dc67  20 eb db   jsr $dbeb        	JSR TALKSA		;send SA for talk
.dc6a  20 a1 da   jsr $daa1        	JSR ACPTR		;get char
.dc6d  85 e0      sta $e0          	STA EAL			;save it as start address L
.dc6f  a5 19      lda $19          	LDA CSTAT		;status
.dc71  4a         lsr              	LSR A
.dc72  4a         lsr              	LSR A
.dc73  b0 3d      bcs $dcb2        	BCS SERLDEX		;$F5C7 timeout? Yes, error
.dc75  20 a1 da   jsr $daa1        	JSR ACPTR		;get next char
.dc78  85 e1      sta $e1          	STA EAL+1		;save as start address H
.dc7a  20 90 dd   jsr $dd90        	JSR SLDPCH		;$E4C1 print "Loading" msg and set load
.dc7d                              serldlp
.dc7d  a9 fd      lda #$fd         	LDA #%11111101		;$FD timeout bit
.dc7f  25 19      and $19          	AND CSTAT		;clear it
.dc81  85 19      sta $19          	STA CSTAT		;save ST
.dc83                              serlo_s2
.dc83  20 a1 da   jsr $daa1        	JSR ACPTR		;get next char - program byte
.dc86  aa         tax              	TAX			;save it
.dc87  a5 19      lda $19          	LDA CSTAT		;check status
.dc89  4a         lsr              	LSR A
.dc8a  4a         lsr              	LSR A
.dc8b  b0 f0      bcs $dc7d        	BCS SERLDLP		;$F58A error, interrupt process
.dc8d  8a         txa              	TXA			;restore char
.dc8e  a4 1b      ldy $1b          	LDY IOFLG2		;check load/verify flag
.dc90  f0 0c      beq $dc9e        	BEQ SERLD1		;$F5B3 =0, load
.dc92  a0 00      ldy #$00         	LDY #$00		;verify comparison
.dc94  d1 e0      cmp ($e0),y      	CMP (EAL),Y
.dc96  f0 08      beq $dca0        	BEQ SERLD2		;$F5B5 match, continue
.dc98  a9 10      lda #$10         	LDA #$10		;not a match, error
.dc9a  20 97 d9   jsr $d997        	JSR ISETMS1		; $FE6A set status

>dc9d  2c                          	.byte $2C		;bit $ae91
.dc9e                              serld1

.dc9e  91 e0      sta ($e0),y      	STA (EAL),Y		;save byte
.dca0                              serld2
.dca0  e6 e0      inc $e0          	INC EAL			;increment address
.dca2  d0 02      bne $dca6        	BNE SERLO_S3		;$F5BB
.dca4  e6 e1      inc $e1          	INC EAL+1			
.dca6                              serlo_s3
.dca6  24 19      bit $19          	BIT CSTAT		;test for EOF
.dca8  50 d3      bvc $dc7d        	BVC SERLDLP		;$F58A not EOF, loop
.dcaa  20 01 dc   jsr $dc01        	JSR UNTALK		;EOF, send untalk
.dcad  20 0e dd   jsr $dd0e        	JSR SERSAV1A		;close file
.dcb0  90 03      bcc $dcb5        	BCC LOADEX		;$F641 exit no error
.dcb2                              serldex
.dcb2  4c 2a de   jmp $de2a        	JMP IOERMS4		;$F787 "FILE NOT FOUND" error
.dcb5                              loadex
.dcb5  18         clc              	CLC			
.dcb6  a6 e0      ldx $e0          	LDX EAL			;return program end address 
.dcb8  a4 e1      ldy $e1          	LDY EAL+1			
.dcba  60         rts              	RTS			
.dcbb                              save
.dcbb  86 e0      stx $e0          	STX EAL			;copy "save to" address
.dcbd  84 e1      sty $e1          	STY EAL+1
.dcbf  aa         tax              	TAX
.dcc0  b5 14      lda $14,x        	LDA USRPOK,X
.dcc2  85 2b      sta $2b          	STA STAL		;save start address L
.dcc4  b5 15      lda $15,x        	LDA USRVEC,X
.dcc6  85 2c      sta $2c          	STA STAL+1		;save start address H
.dcc8  a5 2a      lda $2a          	LDA CHANNL		;get device
.dcca  c9 07      cmp #$07         	CMP #$07		; SAVING to IEC drives allowed
.dccc  b0 03      bcs $dcd1        	BCS SERSAV
.dcce  4c 39 de   jmp $de39        	JMP IOERMS9		;$F796 "ILLEGAL DEVICE" error
.dcd1                              sersav
.dcd1  a9 61      lda #$61         	LDA #$61		;SA=1
.dcd3  85 29      sta $29          	STA SECADR		;set it
.dcd5  ac 8f 02   ldy $028f        	LDY FNMLEN		;get filename length
.dcd8  d0 03      bne $dcdd        	BNE SERSAV_S1		;$F69D not 0, continue
.dcda  4c 36 de   jmp $de36        	JMP IOERMS8		;$F793 "FILENAME MISSING" error
.dcdd                              sersav_s1
.dcdd  20 ae dd   jsr $ddae        	JSR SENDSA		;send filename
.dce0  20 14 de   jsr $de14        	JSR SAVEMS		;print "Saving" message
.dce3  a5 2a      lda $2a          	LDA CHANNL		;get device
.dce5  20 3f db   jsr $db3f        	JSR LISTEN		;command it to listen EE17
.dce8  a5 29      lda $29          	LDA SECADR		;get SA
.dcea  20 2e db   jsr $db2e        	JSR SECOND		;send it
.dced  a0 00      ldy #$00         	LDY #$00
.dcef  20 71 dd   jsr $dd71        	JSR RSTTPP		;save start address to SAL
.dcf2  a5 de      lda $de          	LDA SAL
.dcf4  20 1c db   jsr $db1c        	JSR CIOUT		;send start address L...
.dcf7  a5 df      lda $df          	LDA SAL+1
.dcf9  20 1c db   jsr $db1c        	JSR CIOUT		;...and start address H
.dcfc                              sersavlp
.dcfc  20 7a dd   jsr $dd7a        	JSR CKWRPT		;reached end yet?
.dcff  b0 0a      bcs $dd0b        	BCS SERSAV1		;$F6D7 yes, go to ready
.dd01  b1 de      lda ($de),y      	LDA (SAL),Y		;get program byte
.dd03  20 1c db   jsr $db1c        	JSR CIOUT		;send it
.dd06                              savexit2
.dd06  20 84 dd   jsr $dd84        	JSR INCRDP		;$FD1B bump current address
.dd09  d0 f1      bne $dcfc        	BNE SERSAVLP		;$F6BC continue saving
.dd0b                              sersav1
.dd0b  20 0f dc   jsr $dc0f        	JSR UNLISTEN		;send unlisten
.dd0e                              sersav1a
.dd0e  24 29      bit $29          	BIT SECADR
.dd10  30 11      bmi $dd23        	BMI SERSAVRC
.dd12  a5 2a      lda $2a          	LDA CHANNL		;get device
.dd14  20 3f db   jsr $db3f        	JSR LISTEN		;command it to listen
.dd17  a5 29      lda $29          	LDA SECADR		;get SA
.dd19  29 ef      and #$ef         	AND #%11101111		;$EF twiddle some bits
.dd1b  09 e0      ora #$e0         	ORA #%11100000		;$E0
.dd1d  20 2e db   jsr $db2e        	JSR SECOND		;send SA
.dd20  20 0f dc   jsr $dc0f        	JSR UNLISTEN		;send unlisten 
.dd23                              sersavrc
.dd23  18         clc              	CLC
.dd24  60         rts              	RTS			;return clear
.dd25                              sout1
.dd25  ad 5c 7f   lda $7f5c        	LDA D1PCR		;load PCR
.dd28  29 df      and #$df         	AND #%11011111		;$DF CB2=L
.dd2a  8d 5c 7f   sta $7f5c        	STA D1PCR		;save change
.dd2d  60         rts              	RTS
.dd2e                              sout0
.dd2e  ad 5c 7f   lda $7f5c        	LDA D1PCR		;load PCR
.dd31  09 20      ora #$20         	ORA #%00100000		;$20 CB2=H
.dd33  8d 5c 7f   sta $7f5c        	STA D1PCR		;save change
.dd36  60         rts              	RTS			
.dd37                              sdclk
.dd37  ad 5f 7f   lda $7f5f        	LDA D1ORAH		;load register
.dd3a  cd 5f 7f   cmp $7f5f        	CMP D1ORAH		;any change?
.dd3d  d0 f8      bne $dd37        	BNE SDCLK		;yes (unstable), loop
.dd3f  4a         lsr              	LSR A			;shift PA.0 (clk_in) to CY
.dd40  60         rts              	RTS			
.dd41                              sclk1
.dd41  ad 5c 7f   lda $7f5c        	LDA D1PCR		;PCR
.dd44  29 fd      and #$fd         	AND #%11111101		;$FD CA2=L
.dd46  8d 5c 7f   sta $7f5c        	STA D1PCR		;save it
.dd49  60         rts              	RTS			
.dd4a                              sclk0
.dd4a  ad 5c 7f   lda $7f5c        	LDA D1PCR		;PCR
.dd4d  09 02      ora #$02         	ORA #%00000010		;$02 CA2=H
.dd4f  8d 5c 7f   sta $7f5c        	STA D1PCR		;save it
.dd52  60         rts              	RTS			
.dd53                              ddelay
.dd53  a9 04      lda #$04         	LDA #$04		;set time-out counter
.dd55  8d 59 7f   sta $7f59        	STA D1TM2H		; IFR cleared on write (was D2)
.dd58                              dlyloop
.dd58  ad 5d 7f   lda $7f5d        	LDA D1IFR		;IFR
.dd5b  29 20      and #$20         	AND #%00100000		;Timer2 time-out flagged?
.dd5d  f0 f9      beq $dd58        	BEQ DLYLOOP		;no, loop
.dd5f  60         rts              	RTS			
.dd60                              sbidle
.dd60  60         rts              	RTS
.dd61                              find
.dd61  a9 00      lda #$00         	LDA #$00			
.dd63  85 19      sta $19          	STA CSTAT		;clear status
.dd65  8a         txa              	TXA		
.dd66                              find1
.dd66  a6 24      ldx $24          	LDX COPNFL		;get #of open files
.dd68                              findloop
.dd68  ca         dex              	DEX			
.dd69  30 05      bmi $dd70        	BMI FEXIT		;reached 0, then exit
.dd6b  dd 70 02   cmp $0270,x      	CMP FILTBL,X		;is this the one?
.dd6e  d0 f8      bne $dd68        	BNE FINDLOOP		;$F3D6 no, try again
.dd70                              fexit
.dd70  60         rts              	RTS			;return
.dd71                              rsttpp
.dd71  a5 2c      lda $2c          	LDA STAL+1
.dd73  85 df      sta $df          	STA SAL+1
.dd75  a5 2b      lda $2b          	LDA STAL
.dd77  85 de      sta $de          	STA SAL
.dd79  60         rts              	RTS
.dd7a                              ckwrpt
.dd7a  38         sec              	SEC
.dd7b  a5 de      lda $de          	LDA SAL			;SAL is current address
.dd7d  e5 e0      sbc $e0          	SBC EAL			;EAL is end address
.dd7f  a5 df      lda $df          	LDA SAL+1
.dd81  e5 e1      sbc $e1          	SBC EAL+1
.dd83  60         rts              	RTS
.dd84                              incrdp
.dd84  e6 de      inc $de          	INC SAL
.dd86  d0 02      bne $dd8a        	BNE INCRSK
.dd88  e6 df      inc $df          	INC SAL+1
.dd8a                              incrsk
.dd8a  60         rts              	RTS
.dd8b                              ssadr
.dd8b  a6 29      ldx $29          	LDX SECADR		;get secondary address
.dd8d  4c e3 dd   jmp $dde3        	JMP SRCHMS		;print "Searching..."
.dd90                              sldpch
.dd90  8a         txa              	TXA
.dd91  d0 08      bne $dd9b        	BNE SLDEXIT		;load location not set in LOAD call, so
.dd93  a5 2d      lda $2d          	LDA MEMUSS		;get specified load address from call...
.dd95  85 e0      sta $e0          	STA EAL			;and save as program start address
.dd97  a5 2e      lda $2e          	LDA MEMUSS+1
.dd99  85 e1      sta $e1          	STA EAL+1
.dd9b                              sldexit
.dd9b  4c 09 de   jmp $de09        	JMP LOADMS		;print "Loading"
.dd9e                              flatrb
.dd9e  bd 70 02   lda $0270,x      	LDA FILTBL,X
.dda1  85 28      sta $28          	STA LOGFIL		;get file#
.dda3  bd 7a 02   lda $027a,x      	LDA DEVTBL,X
.dda6  85 2a      sta $2a          	STA CHANNL		;get device
.dda8  bd 84 02   lda $0284,x      	LDA SECATB,X
.ddab  85 29      sta $29          	STA SECADR		;get SA
.ddad  60         rts              	RTS			
.ddae                              sendsa
.ddae  a5 29      lda $29          	LDA SECADR		;get SA
.ddb0  30 2f      bmi $dde1        	BMI SNDSARC		;$F4C5 neg, exit
.ddb2  ac 8f 02   ldy $028f        	LDY FNMLEN		;get filename length
.ddb5  f0 2a      beq $dde1        	BEQ SNDSARC		;$F4C5 0, error	
.ddb7  a5 2a      lda $2a          	LDA CHANNL		;get device
.ddb9  20 3f db   jsr $db3f        	JSR LISTEN		;command it to listen
.ddbc  a5 29      lda $29          	LDA SECADR		;get SA
.ddbe  09 f0      ora #$f0         	ORA #%11110000		;$F0
.ddc0  20 2e db   jsr $db2e        	JSR SECOND		;$EEC0	sent it
.ddc3  a5 19      lda $19          	LDA CSTAT		;status
.ddc5  10 05      bpl $ddcc        	BPL SENDSA1		;$F4B2 OK, continue
.ddc7  68         pla              	PLA			;error, set RTS for caller's caller
.ddc8  68         pla              	PLA
.ddc9  4c 2d de   jmp $de2d        	JMP IOERMS5		;$F78A "DEVICE NOT PRESENT" error
.ddcc                              sendsa1
.ddcc  ad 8f 02   lda $028f        	LDA FNMLEN		;get filename length
.ddcf  f0 0d      beq $ddde        	BEQ SNDSARU		;$F4C2 len=0, send unlisten and exit
.ddd1  a0 00      ldy #$00         	LDY #$00
.ddd3                              sendsalp
.ddd3  b1 26      lda ($26),y      	LDA (FNPTR),Y		;send filename to IEEE
.ddd5  20 1c db   jsr $db1c        	JSR CIOUT		;send char
.ddd8  c8         iny              	INY
.ddd9  cc 8f 02   cpy $028f        	CPY FNMLEN
.dddc  d0 f5      bne $ddd3        	BNE SENDSALP		;$F4B8 loop
.ddde                              sndsaru
.ddde  20 0f dc   jsr $dc0f        	JSR UNLISTEN		;done, send unlisten command
.dde1                              sndsarc
.dde1  18         clc              	CLC
.dde2  60         rts              	RTS
.dde3                              srchms
.dde3  a5 20      lda $20          	LDA CMDMOD		;direct mode?
.dde5  10 21      bpl $de08        	BPL SRCHEX		;$F669 no, exit
.dde7  a0 8c      ldy #$8c         	LDY #KIM_SRCH		;"Searching for"
.dde9  20 69 de   jsr $de69        	JSR DMSG		;output message
.ddec  ad 8f 02   lda $028f        	LDA FNMLEN		;filename length
.ddef  f0 17      beq $de08        	BEQ SRCHEX		;$F669 no filename, skip "for"
.ddf1  a0 96      ldy #$96         	LDY #KIM_FOR		;point to "FOR" in "Searching For"
.ddf3  20 69 de   jsr $de69        	JSR DMSG		;print it
.ddf6                              flnmms
.ddf6  ac 8f 02   ldy $028f        	LDY FNMLEN		;get filename length
.ddf9  f0 0d      beq $de08        	BEQ SRCHEX		;$F669 no filename, exit
.ddfb  a0 00      ldy #$00         	LDY #$00
.ddfd                              flnmlp
.ddfd  b1 26      lda ($26),y      	LDA (FNPTR),Y		;print filename
.ddff  20 0d e8   jsr $e80d        	JSR OUTPUT
.de02  c8         iny              	INY
.de03  cc 8f 02   cpy $028f        	CPY FNMLEN
.de06  d0 f5      bne $ddfd        	BNE FLNMLP
.de08                              srchex
.de08  60         rts              	RTS			;exit
.de09                              loadms
.de09  a0 9a      ldy #$9a         	LDY #KIM_LOAD		;"Loading" assumed
.de0b  a5 1b      lda $1b          	LDA IOFLG2		;check load/verify flag-0=load
.de0d  f0 02      beq $de11        	BEQ DOMESG		;$F672 load, print message
.de0f  a0 a9      ldy #$a9         	LDY #KIM_VERF		;flag=1, "Verifying"
.de11                              domesg
.de11  4c 69 de   jmp $de69        	JMP DMSG		;print message
.de14                              savems
.de14  a5 20      lda $20          	LDA CMDMOD		;direct mode?
.de16  10 08      bpl $de20        	BPL SVRET		;no, exit
.de18  a0 a1      ldy #$a1         	LDY #KIM_SAVE		;yes, print 'Saving
.de1a  20 69 de   jsr $de69        	JSR DMSG		;print message
.de1d  4c f6 dd   jmp $ddf6        	JMP FLNMMS		;print filename
.de20                              svret
.de20  60         rts              	RTS
.de21                              ioerms1
.de21  a9 06      lda #$06         	LDA #$06		;Too Many Files

>de23  2c                          	.byte $2C	
.de24                              ioerms2

.de24  a9 14      lda #$14         	LDA #$14		;File Already Open 

>de26  2c                          	.byte $2C 
.de27                              ioerms3

.de27  a9 1d      lda #$1d         	LDA #$1d		;File Not Open

>de29  2c                          	.byte $2C 
.de2a                              ioerms4

.de2a  a9 2a      lda #$2a         	LDA #$2a		;File Not Found

>de2c  2c                          	.byte $2C 
.de2d                              ioerms5

.de2d  a9 38      lda #$38         	LDA #$38		;Device Not Present

>de2f  2c                          	.byte $2C 
.de30                              ioerms6

.de30  a9 4a      lda #$4a         	LDA #$4a		;Not Input File

>de32  2c                          	.byte $2C 
.de33                              ioerms7

.de33  a9 58      lda #$58         	LDA #$58		;Not Output File

>de35  2c                          	.byte $2C 
.de36                              ioerms8

.de36  a9 67      lda #$67         	LDA #$67		;Missing File Name

>de38  2c                          	.byte $2C 
.de39                              ioerms9

.de39  a9 77      lda #$77         	LDA #$77		;Illegal Device Number
.de3b  a8         tay              	TAY			; copy message number to offset
.de3c  20 24 dc   jsr $dc24        	JSR CLRCH		; clear I/O channel
.de3f  20 5e e7   jsr $e75e        	jsr Print_CR
.de42  20 69 de   jsr $de69        	JSR DMSG		; print error message
.de45  a0 ec      ldy #$ec         	ldy #$ec		;
.de47  20 69 de   jsr $de69        	JSR DMSG		; print " ERROR"
.de4a  20 5e e7   jsr $e75e        	jsr Print_CR
.de4d                              ioermsex
.de4d  20 1e da   jsr $da1e        	jsr CLOSEALL		; operation totally. All open files are
.de50  4c 15 e0   jmp $e015        	jmp DPROMPT		; closed.
.de53                              prmerr
.de53  a9 d9      lda #$d9         	lda #$d9		;Bad Parameter error

>de55  2c                          	.byte $2c
.de56                              snerr

.de56  a9 e6      lda #$e6         	lda #$e6		;Syntax error
.de58  a8         tay              	tay			; copy message number to offset
.de59  20 5e e7   jsr $e75e        	jsr Print_CR
.de5c  20 69 de   jsr $de69        	JSR DMSG		; print error message
.de5f  a0 ec      ldy #$ec         	ldy #$ec		;
.de61  20 69 de   jsr $de69        	JSR DMSG		; print " ERROR"
.de64  20 5e e7   jsr $e75e        	jsr Print_CR
.de67                              smsgex
.de67  38         sec              	SEC
.de68  60         rts              	RTS
.de69                              dmsg
.de69  b9 78 de   lda $de78,y      	LDA KRNLMSGS,Y
.de6c  08         php              	PHP			;save character
.de6d  29 7f      and #$7f         	AND #%01111111		;$7F clear character shift
.de6f  20 0d e8   jsr $e80d        	JSR OUTPUT		;output character
.de72  c8         iny              	INY			;increment
.de73  28         plp              	PLP
.de74  10 f3      bpl $de69        	BPL DMSG		;loop
.de76                              msgexit
.de76  18         clc              	CLC
.de77  60         rts              	RTS			;exit clear
.de78                              krnlmsgs

>de78  42 52 45 41 4b cb           	.byte "BREAK", $CB			;00h
>de7e  54 4f 4f 20 4d 41 4e 59 20 46 49 4c 45 d3  	.byte "TOO MANY FILE", $D3		;06
>de8c  46 49 4c 45 20 4f 50 45 ce  	.byte "FILE OPE", $CE			;14
>de95  46 49 4c 45 20 4e 4f 54 20 4f 50 45 ce  	.byte "FILE NOT OPE", $CE		;1d
>dea2  46 49 4c 45 20 4e 4f 54 20 46 4f 55 4e c4  	.byte "FILE NOT FOUN", $C4		;2a
>deb0  44 45 56 49 43 45 20 4e 4f 54 20 50 52 45 53 45 4e d4  	.byte "DEVICE NOT PRESEN", $D4		;38
>dec2  4e 4f 54 20 49 4e 50 55 54 20 46 49 4c c5  	.byte "NOT INPUT FIL", $C5		;4a
>ded0  4e 4f 54 20 4f 55 54 50 55 54 20 46 49 4c c5  	.byte "NOT OUTPUT FIL", $C5		;58
>dedf  4d 49 53 53 49 4e 47 20 46 49 4c 45 4e 41 4d c5  	.byte "MISSING FILENAM", $C5		;67
>deef  49 4c 4c 45 47 41 4c 20 44 45 56 49 43 45 20 4e 55 4d 42 45 d2  	.byte "ILLEGAL DEVICE NUMBE", $D2	;77
>df04  53 45 41 52 43 48 49 4e 47 a0 46 4f 52 a0  	.byte "SEARCHING", $A0, "FOR", $A0	;8c
>df12  4c 4f 41 44 49 4e c7        	.byte "LOADIN", $C7			;9a
>df19  57 52 49 54 49 4e 47 a0     	.byte "WRITING", $A0			;a1
>df21  56 45 52 49 46 59 49 4e c7  	.byte "VERIFYIN", $C7			;a9
>df2a  46 4f 55 4e 44 a0           	.byte "FOUND", $A0			;b2
>df30  4f 4b 8d                    	.byte "OK", $8D				;b8
>df33  52 45 41 44 59 2e 8d        	.byte "READY.", $8D			;bb
>df3a  41 52 45 20 59 4f 55 20 53 55 52 45 20 bf  	.byte "ARE YOU SURE ", $BF		;c2
>df48  42 41 44 20 44 49 53 4b 8d  	.byte "BAD DISK", $8D			;d0
>df51  42 41 44 20 50 41 52 41 4d 45 54 45 d2  	.byte "BAD PARAMETE",$D2		;d9
>df5e  53 59 4e 54 41 d8           	.byte "SYNTA", $d8			;e6
>df64  20 45 52 52 4f 52 8d        	.byte " ERROR",$8d			;ec-f2
.df6b                              signonmsg
>df6b  0d 0a 43 6f 6d 6d 6f 64 6f 72 65 20 44 4f 53 20 43 6f 6d 6d 61 6e 64 20 49 6e 74 65 72 70 72 65 74 65 72 20 76 2e 31 2e 30 0d 0a  	.byte $0d, $0a, "Commodore DOS Command Interpreter v.1.0", $0d, $0a
>df96  28 63 29 20 32 30 30 33 20 52 69 63 68 61 72 64 20 41 2e 20 43 69 6e 69 0d 0a 52 65 61 64 79 2e 00  	.byte "(c) 2003 Richard A. Cini", $0d, $0a, "Ready.", $00
.dfb7                              dlist
>dfb7  79 e0                       	.word CATALOG
>dfb9  13 e1                       	.word COLLECT
>dfbb  74 e1                       	.word COPY
>dfbd  3c e2                       	.word DS
>dfbf  9f e2                       	.word HEADER
>dfc1  60 e3                       	.word INITDRV
>dfc3  bf e3                       	.word RENAME
>dfc5  01 e4                       	.word SCRATCH
>dfc7  6e e0                       	.word Exit_Dos
.dfc9                              wlist
>dfc9  43 41 54 41 4c 4f c7        	.byte "CATALO",$C7	; disk directory (non-native)
>dfd0  43 4f 4c 4c 45 43 d4        	.byte "COLLEC",$D4	; collect/validate
>dfd7  43 4f 50 d9                 	.byte "COP",$D9		; copy
>dfdb  44 d3                       	.byte "D",$D3		; DS (non-native)
>dfdd  48 45 41 44 45 d2           	.byte "HEADE",$D2	; header/new
>dfe3  49 4e 49 54 49 41 4c 49 5a c5  	.byte "INITIALIZ",$C5	; initialize
>dfed  52 45 4e 41 4d c5           	.byte "RENAM",$C5	; rename
>dff3  53 43 52 41 54 43 c8        	.byte "SCRATC",$C8	; scratch
>dffa  51 55 49 d4                 	.byte "QUI",$D4		; quits DOS
>dffe  00                          	.byte $00		; end of table marker
.dfff                              dos_init

.dfff  a2 ff      ldx #$ff         	ldx #$ff
.e001  9a         txs              	txs		; establish stack
.e002  a2 00      ldx #$00         	ldx #$00	; clear working variables
.e004  86 2f      stx $2f          	stx BUFIDX
.e006  86 30      stx $30          	stx KWCNT
.e008  86 31      stx $31          	stx TMP3
.e00a                              msgloop
.e00a  bd 6b df   lda $df6b,x      	lda SIGNONMSG,x
.e00d  f0 06      beq $e015        	beq DPROMPT
.e00f  20 0d e8   jsr $e80d        	jsr OUTPUT
.e012  e8         inx              	inx
.e013  d0 f5      bne $e00a        	bne MSGLOOP
.e015                              dprompt
.e015  20 94 e7   jsr $e794        	jsr Input_DOS	; Returns command line in Buffer; terminated with <CR>
.e018  20 5e e7   jsr $e75e        	jsr Print_CR	;
.e01b                              crunch
.e01b  a0 00      ldy #$00         	ldy #$00	; start at char 0 in buffer
.e01d                              loopot
.e01d  b9 00 03   lda $0300,y      	lda Buffer,y	; get character
.e020  c9 0d      cmp #$0d         	cmp #$0d	; <CR>?
.e022  f0 f1      beq $e015        	beq DPROMPT	; Prompt again
.e024  c9 41      cmp #$41          	cmp #"A"	; Check if in alpha range...
.e026  90 2a      bcc $e052        	bcc LOOPBK	; No...BELOW
.e028  c9 5b      cmp #$5b         	cmp #"["	; "Z"+1
.e02a  b0 26      bcs $e052        	bcs LOOPBK	; No...ABOVE
.e02c  84 2f      sty $2f          	sty BUFIDX	; save current index into Buffer for this compare
.e02e  a2 00      ldx #$00         	ldx #$00
.e030  86 30      stx $30          	stx KWCNT	; keyword count
.e032  38         sec              LOOPIN	sec		; 
.e033  fd c9 df   sbc $dfc9,x      	sbc WLIST,x	; check character
.e036  f0 13      beq $e04b        	beq LNEXT	; Match? Continue checking
.e038  c9 80      cmp #$80         	cmp #$80	; 80h remainder?
.e03a  f0 19      beq $e055        	beq BYEBYE	; Yes, end of keyword and a match. Go to dispatcher...
.e03c  bd c9 df   lda $dfc9,x      LOOPNO	lda WLIST,X	; No-match, so loop through rest of keyword
.e03f  f0 11      beq $e052        	beq LOOPBK	; At end of keyword list
.e041  30 03      bmi $e046        	bmi CONTLP	; At end of keyword, compare to next keyword
.e043  e8         inx              	inx
.e044  d0 f6      bne $e03c        	bne LOOPNO	; Jump
.e046                              contlp
.e046  e6 30      inc $30          	inc KWCNT	; Increment keyword count
.e048  a4 2f      ldy $2f          	ldy BUFIDX	; re-point to beginning of Buffer

>e04a  a9                          	.byte $A9	; Skip "iny" (LDA #)

.e04b  c8         iny              LNEXT	iny		; get next character in command buffer
.e04c  b9 00 03   lda $0300,y      	lda Buffer,y	; 
.e04f  e8         inx              	inx		; get next character in keyword list
.e050  d0 e0      bne $e032        	bne LOOPIN	; compare next
.e052                              loopbk
.e052  c8         iny              	iny
.e053  d0 c8      bne $e01d        	bne LOOPOT
.e055                              byebye
.e055  84 2f      sty $2f          	sty BUFIDX	; save last index value
.e057  a5 30      lda $30          	lda KWCNT	; KWCNT should be index# of command in DLIST
.e059  0a         asl              	asl a		; Multiply by 2
.e05a  a8         tay              	tay			
.e05b  b9 b8 df   lda $dfb8,y      	lda DLIST+1,y	; Index into dispatch list
.e05e  85 16      sta $16          	sta USRVEC+1	; save MSB
.e060  b9 b7 df   lda $dfb7,y      	lda DLIST,y
.e063  85 15      sta $15          	sta USRVEC	; save LSB
.e065  a9 e0      lda #$e0         	lda #>DPROMPT	; MSB setup stack for return
.e067  48         pha              	pha
.e068  a9 15      lda #$15         	lda #<DPROMPT	; LSB
.e06a  48         pha              	pha 
.e06b  6c 15 00   jmp ($0015)      	jmp (USRVEC)	; Jump to actual routine. When routine completes,
.e06e                              exit_dos
.e06e  68         pla              	pla		; Pop address of "DPROMPT" off of
.e06f  68         pla              	pla		; the stack and...
.e070  4c 00 e7   jmp $e700        	jmp Start_OS	; ...return to the Monitor
.e073                              cncher
.e073  20 56 de   jsr $de56        	jsr SNERR
.e076  4c 15 e0   jmp $e015        	jmp DPROMPT
.e079                              catalog
.e079  a2 08      ldx #$08         	ldx #$08	; set default device to U8
.e07b  8e 8e 02   stx $028e        	stx CMD_DEV
.e07e  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e080  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e083  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e085  c8         iny              	iny		; move to next char in buffer
.e086  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e089  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e08b  f0 1d      beq $e0aa        	beq CAT0	; Yes. Do directory with ID=8
.e08d  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e08f  f0 03      beq $e094        	beq CDRV	; Yes. Get drive ID
.e091  4c 0d e1   jmp $e10d        	jmp CAERR	; Anything else is an error
.e094                              cdrv
.e094  c8         iny              	iny		; move to next character
.e095  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to current char/offset
.e098  20 9f e4   jsr $e49f        	jsr GETBYT	; get byte parameter. Should pickup any errors.
.e09b  b0 70      bcs $e10d        	bcs CAERR	; error catch-all
.e09d  a5 31      lda $31          	lda TMP3	; load converted value
.e09f  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e0a1  30 6a      bmi $e10d        	bmi CAERR	; yes...error
.e0a3  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e0a5  10 66      bpl $e10d        	bpl CAERR	; yes...error
.e0a7  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e0aa                              cat0
.e0aa  20 5e e7   jsr $e75e        	jsr Print_CR	; start on new line
.e0ad  a9 01      lda #$01         	LDA #$01	; setup filename "$"
.e0af  a2 27      ldx #$27         	LDX #<SDIR	; LSB
.e0b1  a0 e5      ldy #$e5         	LDY #>SDIR	; MSB
.e0b3  20 79 d9   jsr $d979        	JSR SETNAM
.e0b6  a9 ff      lda #$ff         	LDA #$ff	; handle $ff
.e0b8  ae 8e 02   ldx $028e        	LDX CMD_DEV	; device
.e0bb  a0 00      ldy #$00         	LDY #$00	; secondary
.e0bd  20 81 d9   jsr $d981        	JSR SETLFS	; set file parameters...
.e0c0  20 9c d9   jsr $d99c        	JSR OPEN	; ...and open
.e0c3  a2 ff      ldx #$ff         	LDX #$ff	; set channel for input
.e0c5  20 2d da   jsr $da2d        	JSR CHKIN	; ignore
.e0c8  20 91 da   jsr $da91        	JSR CHRIN	; ignore first two bytes retrieved 
.e0cb  20 91 da   jsr $da91        	JSR CHRIN	;(starting address of BASIC line)
.e0ce  20 91 da   jsr $da91        SKIP	JSR CHRIN 	;skip poiner to next BASIC line (2 bytes)
.e0d1  20 91 da   jsr $da91        BCK1	JSR CHRIN
.e0d4  20 91 da   jsr $da91        LINE	JSR CHRIN	;get BASIC line# LSB (#blocks)	
.e0d7  a8         tay              	tay		; move save LSB to .Y
.e0d8  20 91 da   jsr $da91        	JSR CHRIN	;get BASIC line# MSB
.e0db  48         pha              	PHA		; push MSB
.e0dc  98         tya              	TYA		; move lsb from .Y to .A...
.e0dd  aa         tax              	TAX		; ..then to .X
.e0de  68         pla              	PLA		; restore MSB to .A
.e0df  20 0c e5   jsr $e50c        	JSR Prt_AX_Dec	; in BASIC; print AX as unsigned integer
.e0e2  a9 20      lda #$20         	LDA #$20	; print a <space>
.e0e4  20 0d e8   jsr $e80d        	JSR OUTPUT
.e0e7                              lp2
.e0e7  20 91 da   jsr $da91        	JSR CHRIN	; get character
.e0ea  f0 06      beq $e0f2        	BEQ C2		; EOL?
.e0ec  20 0d e8   jsr $e80d        	JSR OUTPUT	; no, print char
.e0ef  38         sec              	SEC
.e0f0  b0 f5      bcs $e0e7        	BCS LP2		; loop
.e0f2                              c2
.e0f2  20 5e e7   jsr $e75e        	jsr Print_CR	; print CRLF
.e0f5  20 91 da   jsr $da91        	JSR CHRIN	; get next char (s/b nxt_ptr_L or 0)
.e0f8  d0 d7      bne $e0d1        	BNE BCK1	; If not 0, get next char (nxt_ptr_H)
.e0fa  20 91 da   jsr $da91        	JSR CHRIN	; Got first 0, so check for second. Two nulls here means end of dir.
.e0fd  d0 d5      bne $e0d4        	BNE LINE	; not 0 so loop back and get line#
.e0ff                              exit
.e0ff  20 5e e7   jsr $e75e        	jsr Print_CR
.e102  20 24 dc   jsr $dc24        	JSR CLRCH
.e105  a9 ff      lda #$ff         	LDA #$ff	; We reached the end of the directory so close up
.e107  20 d7 d9   jsr $d9d7        	JSR CLOSE
.e10a  4c 15 e0   jmp $e015        	jmp DPROMPT	
.e10d  20 53 de   jsr $de53        CAERR	jsr PRMERR
.e110  4c 15 e0   jmp $e015        	jmp DPROMPT
.e113                              collect
.e113  a2 08      ldx #$08         	ldx #$08	; set default device to U8
.e115  8e 8e 02   stx $028e        	stx CMD_DEV
.e118  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e11a  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e11d  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e11f  c8         iny              	iny		; move to next char in buffer
.e120  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e123  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e125  f0 1d      beq $e144        	beq COL0	; Yes. Do command with ID=8
.e127  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e129  f0 03      beq $e12e        	beq COLDRV	; Yes. Get drive ID
.e12b  4c 6e e1   jmp $e16e        	jmp CERROR	; Anything else is an error
.e12e                              coldrv
.e12e  c8         iny              	iny		; move to next character
.e12f  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to current char/offset
.e132  20 9f e4   jsr $e49f        	jsr GETBYT	; get byte parameter. Should pickup any errors.
.e135  b0 37      bcs $e16e        	bcs CERROR	; error catch-all
.e137  a5 31      lda $31          	lda TMP3	; load converted value
.e139  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e13b  30 31      bmi $e16e        	bmi CERROR	; yes...error
.e13d  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e13f  10 2d      bpl $e16e        	bpl CERROR	; yes...error
.e141  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e144                              col0
.e144  a9 00      lda #$00         	LDA #$00	; setup filename (none required)
.e146  20 79 d9   jsr $d979        	JSR SETNAM
.e149  a9 ff      lda #$ff         	LDA #$ff	; setup OPEN params
.e14b  ae 8e 02   ldx $028e        	LDX CMD_DEV
.e14e  a0 0f      ldy #$0f         	LDY #$0f
.e150  20 81 d9   jsr $d981        	JSR SETLFS
.e153  20 9c d9   jsr $d99c        	JSR OPEN	; OPEN device
.e156  a2 ff      ldx #$ff         	LDX #$ff	; set channel for output
.e158  20 5e da   jsr $da5e        	JSR CHKOUT
.e15b  20 26 da   jsr $da26        	JSR READST
.e15e  a9 56      lda #$56         	lda #$56	; select validate command
.e160  20 0a db   jsr $db0a        	JSR CHROUT	; send command to channel
.e163  20 24 dc   jsr $dc24        	JSR CLRCH
.e166  a9 ff      lda #$ff         	LDA #$ff	; Now close the file
.e168  20 d7 d9   jsr $d9d7        	JSR CLOSE
.e16b  4c 15 e0   jmp $e015        	jmp DPROMPT
.e16e  20 53 de   jsr $de53        CERROR	jsr PRMERR
.e171  4c 15 e0   jmp $e015        	jmp DPROMPT
.e174                              copy
.e174  a2 08      ldx #$08         	ldx #$08	; set default device to U8
.e176  8e 8e 02   stx $028e        	stx CMD_DEV
.e179  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e17b  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e17e  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e180  c8         iny              	iny		; move to next char in buffer
.e181  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e184  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e186  f0 06      beq $e18e        	beq CPYERR	; Yes. Command with no params. Error
.e188  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e18a  f0 08      beq $e194        	beq CPYDRV	; Yes. Get drive ID
.e18c  d0 1a      bne $e1a8        	bne NOCDRV	; No. Skip drive ID
.e18e  20 53 de   jsr $de53        CPYERR	jsr PRMERR
.e191  4c 15 e0   jmp $e015        	jmp DPROMPT
.e194                              cpydrv
.e194  c8         iny              	iny		; move to next character
.e195  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to current char/offset
.e198  20 9f e4   jsr $e49f        	jsr GETBYT	; Get byte parameter. A/Y set to first char after numeric parm
.e19b  a5 31      lda $31          	lda TMP3	; load converted value
.e19d  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e19f  30 ed      bmi $e18e        	bmi CPYERR	; yes...error
.e1a1  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e1a3  10 e9      bpl $e18e        	bpl CPYERR	; yes...error
.e1a5  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e1a8                              nocdrv
.e1a8  a2 00      ldx #$00         	ldx #$00	; start at 0 of command buffer
.e1aa                              ccl0
.e1aa  bd 28 e5   lda $e528,x      	lda SCPY,x	; copy drive command string to buffer
.e1ad  f0 06      beq $e1b5        	beq RCPY
.e1af  9d 91 02   sta $0291,x      	sta FNM1,x
.e1b2  e8         inx              	inx
.e1b3  d0 f5      bne $e1aa        	bne CCL0
.e1b5                              rcpy
.e1b5  c8         iny              	iny		; move to next character
.e1b6  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces
.e1b9  c9 22      cmp #$22         	cmp #$22
.e1bb  d0 d1      bne $e18e        	bne CPYERR
.e1bd  a9 11      lda #$11         	lda #$11	; Yes. Got first quote
.e1bf  8d 8f 02   sta $028f        	sta FNMLEN	; set filename length variable to 16+1
.e1c2  c8         iny              	iny		; get first char of filename 1
.e1c3                              cqloop1
.e1c3  b9 00 03   lda $0300,y      	lda Buffer,y	; get char (not a leading space)
.e1c6  c9 22      cmp #$22         	cmp #$22	; second quote?
.e1c8  d0 02      bne $e1cc        	bne NOTYET1	; No. Copy character
.e1ca  f0 0c      beq $e1d8        	beq CHKEQ	; Yes. Check for equal sign
.e1cc                              notyet1
.e1cc  9d 91 02   sta $0291,x      	sta FNM1,x	; Quote not found yet so copy filename
.e1cf  e8         inx              	inx		; next char in FNM1
.e1d0  c8         iny              	iny		; next char in Buffer
.e1d1  ce 8f 02   dec $028f        	dec FNMLEN
.e1d4  f0 02      beq $e1d8        	beq CHKEQ	; Done. Check for equal sign
.e1d6  80 eb      bra $e1c3        	bra CQLOOP1	; No. Copy more.
.e1d8                              chkeq
.e1d8  c8         iny              	iny		; next char in Buffer past quote
.e1d9  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces
.e1dc  c9 3d      cmp #$3d         	cmp #$3D	;"="
.e1de  d0 ae      bne $e18e        	bne CPYERR	; missing = 
.e1e0  9d 91 02   sta $0291,x      	sta FNM1,x	; save "=" in command buffer
.e1e3  e8         inx              	inx		; next char in FNM1
.e1e4  c8         iny              	iny		; next char in Buffer past equal sign
.e1e5  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces again
.e1e8  c9 22      cmp #$22         	cmp #$22	; quote?
.e1ea  d0 a2      bne $e18e        	bne CPYERR	; No. Missing second file name
.e1ec  a9 11      lda #$11         	lda #$11	; Yes. Got first quote of second name
.e1ee  8d 8f 02   sta $028f        	sta FNMLEN	; set filename length variable to 16+1
.e1f1  c8         iny              	iny		; get first char of filename 2
.e1f2                              cqloop2
.e1f2  b9 00 03   lda $0300,y      	lda Buffer,y	; get char (not a leading space)
.e1f5  c9 22      cmp #$22         	cmp #$22	; second quote of second filename?
.e1f7  d0 02      bne $e1fb        	bne NOTYET2	; No. Copy character of filename
.e1f9  f0 0c      beq $e207        	beq CFN2D	; Yes. Do command
.e1fb                              notyet2
.e1fb  9d 91 02   sta $0291,x      	sta FNM1,x	; Quote not found yet so copy filename
.e1fe  e8         inx              	inx		; next char in FNM1
.e1ff  c8         iny              	iny		; next char in Buffer
.e200  ce 8f 02   dec $028f        	dec FNMLEN
.e203  f0 02      beq $e207        	beq CFN2D	; Done. Pointer points at last quote
.e205  80 eb      bra $e1f2        	bra CQLOOP2	; No. Copy more.
.e207                              cfn2d
.e207  a9 00      lda #$00         	LDA #$00	; setup filename (none required)
.e209  9d 91 02   sta $0291,x      	sta FNM1,x	; zero-terminate string
.e20c  20 79 d9   jsr $d979        	JSR SETNAM
.e20f  a9 ff      lda #$ff         	LDA #$ff	; setup OPEN params
.e211  ae 8e 02   ldx $028e        	LDX CMD_DEV
.e214  a0 0f      ldy #$0f         	LDY #$0f
.e216  20 81 d9   jsr $d981        	JSR SETLFS
.e219  20 9c d9   jsr $d99c        	JSR OPEN	; OPEN device
.e21c  a2 ff      ldx #$ff         	LDX #$ff	; set channel for output
.e21e  20 5e da   jsr $da5e        	JSR CHKOUT
.e221  20 26 da   jsr $da26        	JSR READST
.e224  a2 00      ldx #$00         	ldx #$00
.e226                              ccmdl
.e226  bd 91 02   lda $0291,x      	lda FNM1,x	; get char in command string
.e229  f0 06      beq $e231        	beq CCMDL1
.e22b  20 0a db   jsr $db0a        	JSR CHROUT	; send character to channel
.e22e  e8         inx              	inx
.e22f  80 f5      bra $e226        	bra CCMDL	; copy more
.e231                              ccmdl1
.e231  20 24 dc   jsr $dc24        	JSR CLRCH	; Done, so clear channel status
.e234  a9 ff      lda #$ff         	LDA #$ff	; Now close the file
.e236  20 d7 d9   jsr $d9d7        	JSR CLOSE
.e239  4c 15 e0   jmp $e015        	jmp DPROMPT
.e23c                              ds
.e23c  a9 08      lda #$08         	lda #$08	; default to unit 8
.e23e  8d 8e 02   sta $028e        	sta CMD_DEV	; save default device for current command
.e241  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e243  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e246  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e248  c8         iny              	iny		; move to first character past keyword
.e249  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e24c  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e24e  f0 1d      beq $e26d        	beq DOSTAT	; Yes. No param so just do command
.e250  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e252  f0 03      beq $e257        	beq DDRV	; Yes. Get drive ID
.e254  4c 99 e2   jmp $e299        	jmp DSERR	; Anything else is an error
.e257                              ddrv
.e257  c8         iny              	iny		; Got comma; point to next char
.e258  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to current char/offset
.e25b  20 9f e4   jsr $e49f        	jsr GETBYT	; get byte parameter into TMP3
.e25e  b0 39      bcs $e299        	bcs DSERR	; invalid parameter
.e260  a5 31      lda $31          	lda TMP3	; get converted parameter
.e262  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e264  30 33      bmi $e299        	bmi DSERR	; yes...error
.e266  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e268  10 2f      bpl $e299        	bpl DSERR	; yes...error
.e26a  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e26d                              dostat
.e26d  a9 00      lda #$00         	LDA #$00	; setup filename
.e26f  20 79 d9   jsr $d979        	JSR SETNAM	; none required for DS
.e272  a9 ff      lda #$ff         	LDA #$ff	; setup OPEN params
.e274  ae 8e 02   ldx $028e        	LDX CMD_DEV
.e277  a0 0f      ldy #$0f         	LDY #$0f
.e279  20 81 d9   jsr $d981        	JSR SETLFS
.e27c  20 9c d9   jsr $d99c        	JSR OPEN	; open device
.e27f  a2 ff      ldx #$ff         	LDX #$ff	; set channel for input
.e281  20 2d da   jsr $da2d        	JSR CHKIN
.e284  20 91 da   jsr $da91        DSLOOP	JSR CHRIN	; read until receiving <CR>
.e287  20 0d e8   jsr $e80d        	JSR OUTPUT
.e28a  c9 0d      cmp #$0d         	CMP #$0D
.e28c  d0 f6      bne $e284        	BNE DSLOOP
.e28e  20 24 dc   jsr $dc24        	JSR CLRCH
.e291  a9 ff      lda #$ff         	LDA #$FF	; Now close the file
.e293  20 d7 d9   jsr $d9d7        	JSR CLOSE
.e296  4c 15 e0   jmp $e015        	jmp DPROMPT
.e299  20 53 de   jsr $de53        DSERR	jsr PRMERR
.e29c  4c 15 e0   jmp $e015        	jmp DPROMPT
.e29f                              header
.e29f  a2 08      ldx #$08         	ldx #$08	; set default device to U8
.e2a1  8e 8e 02   stx $028e        	stx CMD_DEV
.e2a4  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e2a6  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e2a9  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e2ab  c8         iny              	iny		; move to next char in buffer
.e2ac  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e2af  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e2b1  f0 06      beq $e2b9        	beq HDRERR	; Yes. Command with no params. Error
.e2b3  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e2b5  f0 08      beq $e2bf        	beq HDRDRV	; Yes. Get drive ID
.e2b7  d0 1a      bne $e2d3        	bne NOHDRV	; No. Skip drive ID
.e2b9  20 53 de   jsr $de53        HDRERR	jsr PRMERR
.e2bc  4c 15 e0   jmp $e015        	jmp DPROMPT
.e2bf                              hdrdrv
.e2bf  c8         iny              	iny		; move to next character
.e2c0  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to current char/offset
.e2c3  20 9f e4   jsr $e49f        	jsr GETBYT	; get byte parameter. Should pickup any errors.
.e2c6  a5 31      lda $31          	lda TMP3	; load converted value
.e2c8  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e2ca  30 ed      bmi $e2b9        	bmi HDRERR	; yes...error
.e2cc  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e2ce  10 e9      bpl $e2b9        	bpl HDRERR	; yes...error
.e2d0  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e2d3                              nohdrv
.e2d3  a2 00      ldx #$00         	ldx #$00	; start at 0 of command buffer
.e2d5                              hcl0
.e2d5  bd 2c e5   lda $e52c,x      	lda SNEW,x
.e2d8  f0 06      beq $e2e0        	beq HCL1 
.e2da  9d 91 02   sta $0291,x      	sta FNM1,x
.e2dd  e8         inx              	inx
.e2de  d0 f5      bne $e2d5        	bne HCL0
.e2e0                              hcl1
.e2e0  c8         iny              	iny		; move to next character
.e2e1  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces
.e2e4  c9 22      cmp #$22         	cmp #$22
.e2e6  d0 d1      bne $e2b9        	bne HDRERR	; No. Missing quote error
.e2e8  a9 11      lda #$11         	lda #$11	; Yes. Got first quote
.e2ea  8d 8f 02   sta $028f        	sta FNMLEN	; set filename length variable to 16+1
.e2ed  c8         iny              	iny		; increment buffer pointer
.e2ee                              hqloop1
.e2ee  b9 00 03   lda $0300,y      	lda Buffer,y	; get char (not a leading space)
.e2f1  c9 22      cmp #$22         	cmp #$22	; test for second quote
.e2f3  d0 02      bne $e2f7        	bne NOTYETH	; No. copy character
.e2f5  f0 0c      beq $e303        	beq HFN1D	; Yes. Move on to second param
.e2f7                              notyeth
.e2f7  9d 91 02   sta $0291,x      	sta FNM1,x	; Quote not found yet so copy filename
.e2fa  e8         inx              	inx		; next char in FNM1
.e2fb  c8         iny              	iny		; next char in Buffer
.e2fc  ce 8f 02   dec $028f        	dec FNMLEN
.e2ff  f0 02      beq $e303        	beq HFN1D	; Done processing disk name
.e301  80 eb      bra $e2ee        	bra HQLOOP1	; No. Copy more.
.e303                              hfn1d
.e303  c8         iny              	iny		; next char in Buffer
.e304  20 d3 e4   jsr $e4d3        	jsr SKIPSP
.e307  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e309  f0 02      beq $e30d        	beq IPARAM	; Yes. Get disk ID param
.e30b  d0 1d      bne $e32a        	bne NEWDISK	; No. Directory erase command, so NEW disk
.e30d                              iparam
.e30d  9d 91 02   sta $0291,x      	sta FNM1,x	; save comma to disk command buffer
.e310  e8         inx              	inx		; next char in FNM1
.e311  c8         iny              	iny		; next char in Buffer
.e312  b9 00 03   lda $0300,y      	lda Buffer,y	; get next char 
.e315  20 de e4   jsr $e4de        	jsr CHKASC
.e318  b0 9f      bcs $e2b9        	bcs HDRERR
.e31a  9d 91 02   sta $0291,x      	sta FNM1,x	; save first ID
.e31d  e8         inx              	inx		; next slots
.e31e  c8         iny              	iny
.e31f  b9 00 03   lda $0300,y      	lda Buffer,y	; get next char 
.e322  20 de e4   jsr $e4de        	jsr CHKASC
.e325  b0 92      bcs $e2b9        	bcs HDRERR
.e327  9d 91 02   sta $0291,x      	sta FNM1,x	; save second ID
.e32a                              newdisk
.e32a  e8         inx              	inx		; Done; move to last slot of command string
.e32b  a9 00      lda #$00         	LDA #$00	; setup filename (none required)
.e32d  9d 91 02   sta $0291,x      	sta FNM1,x 	; zero-terminate command string
.e330  20 79 d9   jsr $d979        	JSR SETNAM
.e333  a9 ff      lda #$ff         	LDA #$ff	; setup OPEN params
.e335  ae 8e 02   ldx $028e        	LDX CMD_DEV
.e338  a0 0f      ldy #$0f         	LDY #$0f
.e33a  20 81 d9   jsr $d981        	JSR SETLFS
.e33d  20 9c d9   jsr $d99c        	JSR OPEN	; OPEN device
.e340  a2 ff      ldx #$ff         	LDX #$ff	; set channel for output
.e342  20 5e da   jsr $da5e        	JSR CHKOUT
.e345  20 26 da   jsr $da26        	JSR READST
.e348  a2 00      ldx #$00         	ldx #$00
.e34a                              newcmdl
.e34a  bd 91 02   lda $0291,x      	lda FNM1,x	; get char in command string
.e34d  f0 06      beq $e355        	beq NEWEX1	; end of string; done
.e34f  20 0a db   jsr $db0a        	JSR CHROUT	; send character to channel
.e352  e8         inx              	inx
.e353  80 f5      bra $e34a        	bra NEWCMDL	; Loop
.e355                              newex1
.e355  20 24 dc   jsr $dc24        	JSR CLRCH	; Command done, so clear channel status
.e358  a9 ff      lda #$ff         	LDA #$ff	; Close the file
.e35a  20 d7 d9   jsr $d9d7        	JSR CLOSE
.e35d                              newexit
.e35d  4c 15 e0   jmp $e015        	jmp DPROMPT
.e360                              initdrv
.e360  a2 08      ldx #$08         	ldx #$08	; set default device to U8
.e362  8e 8e 02   stx $028e        	stx CMD_DEV
.e365  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e367  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e36a  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e36c  c8         iny              	iny		; move to next char in buffer
.e36d  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e370  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e372  f0 1b      beq $e38f        	beq INIT0	; Yes. Do command with ID=8
.e374  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e376  f0 03      beq $e37b        	beq INDRV	; Yes. Get drive ID
.e378  4c b9 e3   jmp $e3b9        	jmp INERROR	; Anything else is an error
.e37b                              indrv
.e37b  c8         iny              	iny		; move to next character
.e37c  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to current char/offset
.e37f  20 9f e4   jsr $e49f        	jsr GETBYT	; get byte parameter. Should pickup any errors.
.e382  a5 31      lda $31          	lda TMP3	; load converted value
.e384  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e386  30 31      bmi $e3b9        	bmi INERROR	; yes...error
.e388  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e38a  10 2d      bpl $e3b9        	bpl INERROR	; yes...error
.e38c  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e38f                              init0
.e38f  a9 00      lda #$00         	LDA #$00	; setup filename (none required)
.e391  20 79 d9   jsr $d979        	JSR SETNAM
.e394  a9 ff      lda #$ff         	LDA #$ff	; setup OPEN params
.e396  ae 8e 02   ldx $028e        	LDX CMD_DEV
.e399  a0 0f      ldy #$0f         	LDY #$0f
.e39b  20 81 d9   jsr $d981        	JSR SETLFS
.e39e  20 9c d9   jsr $d99c        	JSR OPEN	; OPEN device
.e3a1  a2 ff      ldx #$ff         	LDX #$ff	; set channel for output
.e3a3  20 5e da   jsr $da5e        	JSR CHKOUT
.e3a6  20 26 da   jsr $da26        	JSR READST
.e3a9  a9 49      lda #$49         	lda #$49	; select initialize command
.e3ab  20 0a db   jsr $db0a        	JSR CHROUT	; send command to channel
.e3ae  20 24 dc   jsr $dc24        	JSR CLRCH
.e3b1  a9 ff      lda #$ff         	LDA #$ff	; Now close the file
.e3b3  20 d7 d9   jsr $d9d7        	JSR CLOSE
.e3b6  4c 15 e0   jmp $e015        	jmp DPROMPT
.e3b9                              inerror
.e3b9  20 53 de   jsr $de53        	jsr PRMERR
.e3bc  4c 15 e0   jmp $e015        	jmp DPROMPT
.e3bf                              rename
.e3bf  a2 08      ldx #$08         	ldx #$08	; set default device to U8
.e3c1  8e 8e 02   stx $028e        	stx CMD_DEV
.e3c4  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e3c6  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e3c9  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e3cb  c8         iny              	iny		; move to next char in buffer
.e3cc  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e3cf  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e3d1  f0 28      beq $e3fb        	beq RNERROR	; Yes. Command with no params. Error
.e3d3  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e3d5  f0 02      beq $e3d9        	beq RENDRV	; Yes. Get drive ID
.e3d7  d0 14      bne $e3ed        	bne NORDRV	; No. Skip drive ID
.e3d9                              rendrv
.e3d9  c8         iny              	iny		; move to next character
.e3da  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to current char/offset
.e3dd  20 9f e4   jsr $e49f        	jsr GETBYT	; get byte parameter. A/Y set to first char after numeric param
.e3e0  a5 31      lda $31          	lda TMP3	; load converted value
.e3e2  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e3e4  30 15      bmi $e3fb        	bmi RNERROR	; yes...error
.e3e6  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e3e8  10 11      bpl $e3fb        	bpl RNERROR	; yes...error
.e3ea  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e3ed                              nordrv
.e3ed  a2 00      ldx #$00         	ldx #$00	; start at 0 of command buffer
.e3ef                              rcl0
.e3ef  bd 30 e5   lda $e530,x      	lda SREN,x
.e3f2  9d 91 02   sta $0291,x      	sta FNM1,x
.e3f5  e8         inx              	inx
.e3f6  d0 f7      bne $e3ef        	bne RCL0
.e3f8  4c b5 e1   jmp $e1b5        	jmp RCPY	; coninue RENAME command through COPY code.
.e3fb                              rnerror
.e3fb  20 53 de   jsr $de53        	jsr PRMERR
.e3fe  4c 15 e0   jmp $e015        	jmp DPROMPT
.e401                              scratch
.e401  a2 08      ldx #$08         	ldx #$08	; set default device to U8
.e403  8e 8e 02   stx $028e        	stx CMD_DEV
.e406  a9 ff      lda #$ff         	lda #$ff	; system LFN
.e408  20 d7 d9   jsr $d9d7        	jsr CLOSE	; close it just in case 
.e40b  a4 2f      ldy $2f          	ldy BUFIDX	; get current offset into command line
.e40d  c8         iny              	iny		; move to next char in buffer
.e40e  b9 00 03   lda $0300,y      	lda Buffer,y	; get it
.e411  c9 0d      cmp #$0d         	cmp #$0d	; end of line?
.e413  f0 06      beq $e41b        	beq SCRERR	; Yes. Command with no params. Error
.e415  c9 2c      cmp #$2c         	cmp #$2C	; comma?
.e417  f0 08      beq $e421        	beq SCRDRV	; Yes. Get drive ID
.e419  d0 1a      bne $e435        	bne NOSDRV	; No. Skip drive ID
.e41b  20 53 de   jsr $de53        SCRERR	jsr PRMERR
.e41e  4c 15 e0   jmp $e015        	jmp DPROMPT
.e421                              scrdrv
.e421  c8         iny              	iny		; next char in Buffer
.e422  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces after comma. A/Y set to first char after last space
.e425  20 9f e4   jsr $e49f        	jsr GETBYT	; Get byte parameter. A/Y set to first char after numeric param
.e428  a5 31      lda $31          	lda TMP3	; load converted value
.e42a  c9 08      cmp #$08         	cmp #$08	; Below 8?
.e42c  30 ed      bmi $e41b        	bmi SCRERR	; yes...error
.e42e  c9 0c      cmp #$0c         	cmp #$0c	; above 11 (11+1)?
.e430  10 e9      bpl $e41b        	bpl SCRERR	; yes...error
.e432  8d 8e 02   sta $028e        	sta CMD_DEV	; overwrite default device
.e435                              nosdrv
.e435  a2 00      ldx #$00         	ldx #$00	; Start at beginning of command buffer
.e437                              scmdl
.e437  bd 34 e5   lda $e534,x      	lda SSCR,x	; Copy drive command to buffer
.e43a  f0 06      beq $e442        	beq SCMDD
.e43c  9d 91 02   sta $0291,x      	sta FNM1,x
.e43f  e8         inx              	inx
.e440  d0 f5      bne $e437        	bne SCMDL
.e442                              scmdd
.e442  c8         iny              	iny
.e443  20 d3 e4   jsr $e4d3        	jsr SKIPSP	; skip any spaces between device ID and string
.e446  c9 22      cmp #$22         	cmp #$22	; next char a quote?
.e448  d0 d1      bne $e41b        	bne SCRERR	; No. Missing quote error
.e44a  a9 11      lda #$11         	lda #$11	; 
.e44c  8d 8f 02   sta $028f        	sta FNMLEN	; set max filename length variable to 16+1
.e44f  c8         iny              	iny		; next char (first char of filename)
.e450                              sqloop1
.e450  b9 00 03   lda $0300,y      	lda Buffer,y	; get char (not a leading space)
.e453  c9 22      cmp #$22         	cmp #$22	; second quote
.e455  d0 02      bne $e459        	bne NOTYET3	; No. Copy character.
.e457  f0 0c      beq $e465        	beq SFN1D	; Yes. Do command. Could be NULL string
.e459                              notyet3
.e459  9d 91 02   sta $0291,x      	sta FNM1,x	; Quote not found yet so put char in command buffer
.e45c  e8         inx              	inx		; next char in FNM1
.e45d  c8         iny              	iny		; next char in Buffer
.e45e  ce 8f 02   dec $028f        	dec FNMLEN
.e461  f0 02      beq $e465        	beq SFN1D	; reached max# of chars, so do command (***ADDED)
.e463  80 eb      bra $e450        	bra SQLOOP1	; No. Copy more. (branch always)
.e465                              sfn1d
.e465  20 f2 e4   jsr $e4f2        	jsr CONFOPS	; filename is done. Query user to make sure that this is OK
.e468  b0 32      bcs $e49c        	bcs SCMDL4	; Not OK, exit
.e46a  a9 00      lda #$00         	LDA #$00	; setup filename (none required)
.e46c  9d 91 02   sta $0291,x      	sta FNM1,x	; terminate disk command string (***ADDED)
.e46f  20 79 d9   jsr $d979        	JSR SETNAM
.e472  a9 ff      lda #$ff         	LDA #$ff	; setup OPEN params
.e474  ae 8e 02   ldx $028e        	LDX CMD_DEV
.e477  a0 0f      ldy #$0f         	LDY #$0f
.e479  20 81 d9   jsr $d981        	JSR SETLFS
.e47c  20 9c d9   jsr $d99c        	JSR OPEN	; OPEN device
.e47f  a2 ff      ldx #$ff         	LDX #$ff	; set channel for output
.e481  20 5e da   jsr $da5e        	JSR CHKOUT
.e484  20 26 da   jsr $da26        	JSR READST
.e487  a2 00      ldx #$00         	ldx #$00	; start at beginning of command buffer
.e489                              scmdl2
.e489  bd 91 02   lda $0291,x      	lda FNM1,x	; get char in command string
.e48c  f0 06      beq $e494        	beq SCMDL3
.e48e  20 0a db   jsr $db0a        	JSR CHROUT	; send character to channel
.e491  e8         inx              	inx
.e492  80 f5      bra $e489        	bra SCMDL2	; Copy more.
.e494                              scmdl3
.e494  20 24 dc   jsr $dc24        	JSR CLRCH	; Done, so clear channel status
.e497  a9 ff      lda #$ff         	LDA #$ff	; Now close the file
.e499  20 d7 d9   jsr $d9d7        	JSR CLOSE
.e49c                              scmdl4
.e49c  4c 15 e0   jmp $e015        	jmp DPROMPT
.e49f                              getbyt
.e49f  b9 00 03   lda $0300,y      	lda  Buffer,y	; get char
.e4a2  c9 30      cmp #$30         	cmp  #$30	;  ascii "0"
.e4a4  30 2c      bmi $e4d2        	bmi  GERROR	; not a valid digit
.e4a6  c9 3a      cmp #$3a         	cmp  #$3a	; ascii "9"+1
.e4a8  10 28      bpl $e4d2        	bpl  GERROR	; mask out valid ascii digit
.e4aa  29 0f      and #$0f         	and  #$0f	; convert it to binary
.e4ac  85 31      sta $31          	sta  TMP3
.e4ae  c8         iny              	iny
.e4af  b9 00 03   lda $0300,y      	lda  Buffer,y	; get next digit
.e4b2  c9 30      cmp #$30         	cmp  #$30
.e4b4  30 1b      bmi $e4d1        	bmi  NONDIG	; test it for valid ascii code
.e4b6  c9 3a      cmp #$3a         	cmp  #$3a
.e4b8  10 17      bpl $e4d1        	bpl  NONDIG	; next chr is not a digit, we are done
.e4ba  a5 31      lda $31          	lda  TMP3	; get value
.e4bc  0a         asl              	asl		; mult x2
.e4bd  85 31      sta $31          	sta  TMP3	; save it
.e4bf  0a         asl              	asl
.e4c0  0a         asl              	asl		; mult x8
.e4c1  18         clc              	clc
.e4c2  65 31      adc $31          	adc  TMP3	; add val*8 to val*2
.e4c4  85 31      sta $31          	sta  TMP3	; value *10 in temp
.e4c6  b9 00 03   lda $0300,y      	lda  Buffer,y	; get second digit again
.e4c9  29 0f      and #$0f         	and  #$0f	; already tested, so convert to bin
.e4cb  65 31      adc $31          	adc  TMP3	; add to first digit
.e4cd  85 31      sta $31          	sta  TMP3
.e4cf  c8         iny              	iny		; adjust buffer pointer if needed
.e4d0  18         clc              	clc
.e4d1  60         rts              NONDIG	rts		; return with value in temp
.e4d2                              gerror
.e4d2  38         sec              	sec
.e4d3                              ret
.e4d3                              skipsp
.e4d3  b9 00 03   lda $0300,y      	lda Buffer,y	; reload char at current offset
.e4d6  c9 20      cmp #$20         	cmp #" "	; space?
.e4d8  d0 03      bne $e4dd        	bne SPEXIT	; No...just exit
.e4da  c8         iny              	iny		; Yes...check next char and loop
.e4db  80 f6      bra $e4d3        	bra SKIPSP		
.e4dd                              spexit
.e4dd  60         rts              	rts
.e4de                              chkasc
.e4de  c9 30      cmp #$30         	cmp #"0"	; 0-9=30h-39h; A-Z=41h-5ah
.e4e0  30 0c      bmi $e4ee        	bmi ASCERR
.e4e2  c9 5b      cmp #$5b         	cmp #$5b	; "Z"+1
.e4e4  10 08      bpl $e4ee        	bpl ASCERR
.e4e6  c9 3a      cmp #$3a         	cmp #$3a	; "9"+1
.e4e8  30 06      bmi $e4f0        	bmi ASCOK
.e4ea  c9 40      cmp #$40         	cmp #$40	; last punct
.e4ec  10 02      bpl $e4f0        	bpl ASCOK
.e4ee                              ascerr
.e4ee  38         sec              	sec
.e4ef  60         rts              	rts
.e4f0                              ascok
.e4f0  18         clc              	clc
.e4f1  60         rts              	rts
.e4f2                              confops
.e4f2  a0 c2      ldy #$c2         	ldy #$c2	;print "Are you sure?"
.e4f4  20 69 de   jsr $de69        	jsr DMSG
.e4f7  20 07 e8   jsr $e807        	jsr Input_Chr	;get a single character (waits for input)
.e4fa  c9 59      cmp #$59         	cmp #"Y"	;"Y" Yes
.e4fc  f0 0a      beq $e508        	beq CONF1
.e4fe  c9 4e      cmp #$4e         	cmp #"N"	;"N"
.e500  f0 08      beq $e50a        	beq CONF2
.e502  c9 0d      cmp #$0d         	cmp #$0d	;<CR>?
.e504  f0 04      beq $e50a        	beq CONF2	; exit
.e506  80 ea      bra $e4f2        	bra CONFOPS	; loop
.e508                              conf1
.e508  18         clc              	clc
.e509  60         rts              	rts
.e50a                              conf2
.e50a  38         sec              	sec
.e50b  60         rts              	rts
.e50c                              prt_ax_dec
.e50c  85 ad      sta $ad          	STA	FAC1_1		; save high byte as FAC1 mantissa1
.e50e  86 ae      stx $ae          	STX	FAC1_2		; save low byte as FAC1 mantissa2
.e510  a2 90      ldx #$90         	LDX	#$90		; set exponent to 16d bits
.e512  38         sec              	SEC			; set integer is +ve flag
.e513  20 d1 bb   jsr $bbd1        	JSR	LAB_STFA	; set exp=X, clearFAC1 ...	
.e516  20 5b bd   jsr $bd5b        	JSR	LAB_296E	; convert FAC1 to string
.e519  a0 01      ldy #$01         	ldy	#$01
.e51b  b9 ef 00   lda $00ef,y      lp1	lda	Decss,y
.e51e  f0 06      beq $e526        	beq	done2
.e520  20 0d e8   jsr $e80d        	jsr	OUTPUT
.e523  c8         iny              	iny
.e524  80 f5      bra $e51b        	bra	lp1
.e526  60         rts              done2	rts

>e527  24                          SDIR	.byte "$"		; catalog/directory filename
>e528  43 30 3a 00                 SCPY	.byte "C0:",$00		; copy
>e52c  4e 30 3a 00                 SNEW	.byte "N0:",$00		; header/new
>e530  52 30 3a 00                 SREN	.byte "R0:",$00		; rename
>e534  53 30 3a 00                 SSCR	.byte "S0:",$00		; scratch

.e600  a9 7f      lda #$7f         Via1_init	LDA   #%01111111	;$7F
.e602  8d 5e 7f   sta $7f5e        		STA   Via1IER		; clear and disable all VIA interrupt sources
.e605  a9 40      lda #$40         		LDA   #%01000000	;$40 T1 free-running (PB7 output disabled)/T2
.e607  8d 5b 7f   sta $7f5b        		sta   Via1ACR		;interval counter/shift registers disabled/
.e60a  a9 de      lda #$de         	       	LDA   #%11011110	;$DE CB2 manual L/ CB1 IF set on L->H/ CA2 manual
.e60c  8d 5c 7f   sta $7f5c        	    	STA   Via1PCR		;H/ CA2 IF set on H->L
.e60f  a2 00      ldx #$00         	       	LDX   #$00		;$00 'iiiiiiii'	
.e611  8e 52 7f   stx $7f52        	    	STX   Via1DDRB		; save to DDRB
.e614  8e 5d 7f   stx $7f5d        	    	stx   Via1IFR		; clear IFR
.e617  a2 80      ldx #$80         	     	LDX   #%10000000	;$80 'oiiiiiii' PA.7=ATN_OUT
.e619  8e 53 7f   stx $7f53        	    	STX   Via1DDRA		; save to DDRA
.e61c  a2 00      ldx #$00         		ldx   #$00
.e61e  8e 5f 7f   stx $7f5f        		stx   Via1PRA1		; clear PA (CLKIN, DATAIN, ATNOUT)
.e621  20 41 dd   jsr $dd41        		jsr   SCLK1		; set IEC clock line
.e624  a9 7f      lda #$7f         		lda   #%01111111	; leave all interrupt sources disabled
.e626  8d 5e 7f   sta $7f5e        		sta   Via1IER		; save to IER (preserved for timing)
.e629  20 4a dd   jsr $dd4a        		jsr   SCLK0		; reset IEC clock line
.e62c  60         rts              		rts                     ; done
.e62d  a2 00      ldx #$00         Via2_init      ldx   #$00              ; get data from table
.e62f  bd 3b e6   lda $e63b,x      Via2init1      lda   Via2idata,x       ; init all 16 regs from 00 to 0F
.e632  9d 60 7f   sta $7f60,x                     sta   Via2Base,x        ; 
.e635  e8         inx                             inx                     ; 
.e636  e0 0f      cpx #$0f                        cpx   #$0f              ; 
.e638  d0 f5      bne $e62f                       bne   Via2init1         ;       
.e63a  60         rts                             rts                     ; done

>e63b  00                          Via2idata      .byte $00               ; prb  '00000000'
>e63c  00                                         .byte $00               ; pra  "00000000'
>e63d  00                                         .byte $00               ; ddrb 'iiiiiiii'
>e63e  00                                         .byte $00               ; ddra 'iiiiiiii'
>e63f  00                                         .byte $00               ; tacl  
>e640  00                                         .byte $00               ; tach  
>e641  00                                         .byte $00               ; tall  
>e642  00                                         .byte $00               ; talh  
>e643  00                                         .byte $00               ; t2cl
>e644  00                                         .byte $00               ; t2ch
>e645  00                                         .byte $00               ; sr
>e646  00                                         .byte $00               ; acr
>e647  00                                         .byte $00               ; pcr
>e648  7f                                         .byte $7f               ; ifr
>e649  7f                                         .byte $7f               ; ier

.e64a  a2 ad      ldx #$ad         ACIA1_init     LDX   #<ACIA1_Input      ; set up RAM vectors for
.e64c  a9 e6      lda #$e6                        LDA   #>ACIA1_Input      ; Input, Output, and Scan
.e64e  a8         tay                             TAY                     	; Routines
.e64f  49 a5      eor #$a5                        EOR   #$A5              	;
.e651  8d ed 03   sta $03ed                       sta   ChrInVect+2       	;
.e654  8c ec 03   sty $03ec                       sty   ChrInVect+1       	;
.e657  8e eb 03   stx $03eb                       stx   ChrInVect         	;
.e65a  a2 b8      ldx #$b8                        LDX   #<ACIA1_Scan  	;
.e65c  a9 e6      lda #$e6                        LDA   #>ACIA1_Scan       ;
.e65e  a8         tay                             TAY                     	;
.e65f  49 a5      eor #$a5                        EOR   #$A5              	;
.e661  8d f0 03   sta $03f0                       sta   ScanInVect+2      	;
.e664  8c ef 03   sty $03ef                       sty   ScanInVect+1      	;
.e667  8e ee 03   stx $03ee                       stx   ScanInVect        	;
.e66a  a2 c5      ldx #$c5                        LDX   #<ACIA1_Output     ;
.e66c  a9 e6      lda #$e6                        LDA   #>ACIA1_Output     ;
.e66e  a8         tay                             TAY                     	;
.e66f  49 a5      eor #$a5                        EOR   #$A5              	;
.e671  8d f3 03   sta $03f3                       sta   ChrOutVect+2      	;
.e674  8c f2 03   sty $03f2                       sty   ChrOutVect+1      	;
.e677  8e f1 03   stx $03f1                       stx   ChrOutVect        	;
.e67a  a9 b8      lda #$b8                        lda   #<ACIA1_scan      	; setup BASIC vectors
.e67c  8d 05 02   sta $0205                       sta   VEC_IN
.e67f  a9 e6      lda #$e6         	       lda   #>ACIA1_scan	; BASIC's chr input
.e681  8d 06 02   sta $0206                       sta   VEC_IN+1
.e684  a9 c5      lda #$c5                        lda   #<ACIA1_Output	
.e686  8d 07 02   sta $0207                       sta   VEC_OUT
.e689  a9 e6      lda #$e6         	       lda   #>ACIA1_Output	; BASIC's chr output 
.e68b  8d 08 02   sta $0208                       sta   VEC_OUT+1
.e68e  a9 7e      lda #$7e         	       lda   #<Psave
.e690  8d 0b 02   sta $020b                       sta   VEC_SV
.e693  a9 ca      lda #$ca         	       lda   #>Psave		; SAVE cmd
.e695  8d 0c 02   sta $020c                       sta   VEC_SV+1
.e698  a9 a7      lda #$a7         	       lda   #<pload
.e69a  8d 09 02   sta $0209                       sta   VEC_LD
.e69d  a9 ca      lda #$ca         	       lda   #>pload		; LOAD cmd
.e69f  8d 0a 02   sta $020a                       sta   VEC_LD+1
.e6a2  a9 1f      lda #$1f         ACIA1portset   lda   #$1F               ; 19.2K/8/1
.e6a4  8d 73 7f   sta $7f73                       sta   ACIA1ctl           ; control reg 
.e6a7  a9 0b      lda #$0b                        lda   #$0B               ; N parity/echo off/rx int off/ dtr active low
.e6a9  8d 72 7f   sta $7f72                       sta   ACIA1cmd           ; command reg 
.e6ac  60         rts                             rts                      ; done
.e6ad                              acia1_input
.e6ad  ad 71 7f   lda $7f71                       lda   ACIA1Sta           ; Serial port status             
.e6b0  29 08      and #$08                        and   #$08               ; is recvr full
.e6b2  f0 f9      beq $e6ad                       beq   ACIA1_Input        ; no char to get
.e6b4  ad 70 7f   lda $7f70                       Lda   ACIA1dat           ; get chr
.e6b7  60         rts                             RTS                      ;
.e6b8  18         clc              ACIA1_Scan     clc
.e6b9  ad 71 7f   lda $7f71                       lda   ACIA1Sta           ; Serial port status
.e6bc  29 08      and #$08                        and   #$08               ; mask rcvr full bit
.e6be  f0 04      beq $e6c4                       beq   ACIA1_scan2
.e6c0  ad 70 7f   lda $7f70                       Lda   ACIA1dat           ; get chr
.e6c3  38         sec              	         sec
.e6c4  60         rts              ACIA1_scan2    rts
.e6c5  48         pha              ACIA1_Output   PHA                      ; save registers
.e6c6  ad 71 7f   lda $7f71        ACIA1_Out1     lda   ACIA1Sta           ; serial port status
.e6c9  29 10      and #$10                        and   #$10               ; is tx buffer empty
.e6cb  f0 f9      beq $e6c6                       beq   ACIA1_Out1         ; no
.e6cd  68         pla                             PLA                      ; get chr
.e6ce  8d 70 7f   sta $7f70                       sta   ACIA1dat           ; put character to Port
.e6d1  60         rts                             RTS                      ; done

.e700  4c 4a e8   jmp $e84a        Start_OS       jmp MonitorBoot         ; easy access to monitor program

>e703  20 50 43 3d 20 20 41 3d 20 20 58 3d 20 20 59 3d 20 20 53 3d 20 20 50 3d 20 28 4e 56 52 42 44 49 5a 43 29 3d  RegData        .byte" PC=  A=  X=  Y=  S=  P= (NVRBDIZC)="

.e727  20 5e e7   jsr $e75e        PrintReg       Jsr   Print_CR          ; Lead with a CR
.e72a  a2 ff      ldx #$ff                        ldx   #$ff              ;
.e72c  a0 ff      ldy #$ff                        ldy   #$ff              ;
.e72e  c8         iny              Printreg1      iny                     ;
.e72f  b9 03 e7   lda $e703,y                     lda   Regdata,y         ;
.e732  20 0d e8   jsr $e80d                       jsr   Output            ;
.e735  c9 3d      cmp #$3d                        cmp   #$3D              ; "="
.e737  d0 f5      bne $e72e                       bne   Printreg1         ;
.e739  e8         inx              Printreg2      inx                     ;
.e73a  e0 07      cpx #$07                        cpx   #$07              ;
.e73c  f0 0c      beq $e74a                       beq   Printreg3         ; done with first 6
.e73e  bd e0 03   lda $03e0,x                     lda   PCH,x             ;  
.e741  20 6f e7   jsr $e76f                       jsr   Print1Byte        ;
.e744  e0 00      cpx #$00                        cpx   #$00              ;
.e746  d0 e6      bne $e72e                       bne   Printreg1         ;
.e748  80 ef      bra $e739                       bra   Printreg2         ;
.e74a  ca         dex              Printreg3      dex                     ;
.e74b  bd e0 03   lda $03e0,x                     lda   PCH,x             ; get Preg
.e74e  a2 08      ldx #$08                        ldx   #$08              ; 
.e750  2a         rol              Printreg4      rol                     ;
.e751  a8         tay                             tay                     ;
.e752  a9 31      lda #$31                        lda   #$31              ;
.e754  b0 01      bcs $e757                       bcs   Printreg5         ;
.e756  3a         dec                             dec                     ;
.e757  20 0d e8   jsr $e80d        Printreg5      jsr   Output            ;
.e75a  98         tya                             tya                     ;
.e75b  ca         dex                             dex                     ;
.e75c  d0 f2      bne $e750                       bne   Printreg4         ;
.e75e  48         pha              Print_CR       PHA                     ; Save Acc
.e75f  a9 0d      lda #$0d                        LDA   #$0D              ; "cr"
.e761  20 0d e8   jsr $e80d                       JSR   OUTPUT            ; send it
.e764  a9 0a      lda #$0a                        LDA   #$0A              ; "lf"
.e766  20 0d e8   jsr $e80d                       JSR   OUTPUT            ; send it
.e769  68         pla                             PLA                     ; Restore Acc
.e76a  60         rts                             RTS                     ; 
.e76b  20 6f e7   jsr $e76f        Print2Byte     JSR   Print1Byte        ;  prints AAXX hex digits
.e76e  8a         txa                             TXA                     ;
.e76f  48         pha              Print1Byte     PHA                     ;  prints AA hex digits
.e770  4a         lsr                             LSR                     ;  MOVE UPPER NIBBLE TO LOWER
.e771  4a         lsr                             LSR                     ;
.e772  4a         lsr                             LSR                     ;
.e773  4a         lsr                             LSR                     ;
.e774  20 78 e7   jsr $e778                       JSR   PrintDig          ;
.e777  68         pla                             PLA                     ;
.e778  5a         phy              PrintDig       PHY                     ;  prints A hex nibble (low 4 bits)
.e779  29 0f      and #$0f                        AND   #$0F              ;
.e77b  a8         tay                             TAY                     ;
.e77c  b9 0d ef   lda $ef0d,y                     LDA   Hexdigdata,Y      ;
.e77f  7a         ply                             PLY                     ;
.e780  4c 0d e8   jmp $e80d                       jmp   output            ;
.e783  20 8f e7   jsr $e78f        PrintXSP1      JSR   Print1SP          ;
.e786  ca         dex                             dex                     ;
.e787  e0 00      cpx #$00         PrintXSP       cpx   #$00              ;
.e789  d0 f8      bne $e783                       bne   PrintXSP1         ;
.e78b  60         rts                             rts                     ;
.e78c  20 8f e7   jsr $e78f        Print2SP       jsr   Print1SP          ; print 2 SPACES
.e78f  a9 20      lda #$20         Print1SP       LDA   #$20              ; print 1 SPACE
.e791  4c 0d e8   jmp $e80d                       JMP   OUTPUT            ;
.e794  a9 3e      lda #$3e         Input_Dos      lda   #$3e	       ; DOS prompt ">"

>e796  2c                          		.byte $2c

.e797  a9 21      lda #$21         Input_Assem    lda   #$21              ; Assembler Prompt "!"

>e799  2c                                         .byte $2c               ; mask out next line to bypass 

.e79a  a9 2a      lda #$2a         Input          lda   #$2A              ; Monitor Prompt "*"
.e79c  85 32      sta $32                         sta   Prompt            ; save prompt chr 
.e79e  20 5e e7   jsr $e75e        Input1         jsr   Print_CR          ; New Line
.e7a1  a5 32      lda $32                         lda   Prompt            ; get prompt
.e7a3  20 0d e8   jsr $e80d                       jsr   Output            ; Print Prompt
.e7a6  a0 ff      ldy #$ff                        ldy   #$ff              ; pointer
.e7a8  20 07 e8   jsr $e807        InputWait      jsr   Input_Chr         ; get a character
.e7ab  c9 20      cmp #$20                        cmp   #$20              ; is ctrl char?
.e7ad  b0 3d      bcs $e7ec                       BCS   InputSave         ; no, echo chr 
.e7af  c9 0d      cmp #$0d                        cmp   #$0d              ; cr
.e7b1  f0 4a      beq $e7fd                       Beq   InputDone         ; done
.e7b3  c9 1b      cmp #$1b                        cmp   #$1B              ; esc
.e7b5  f0 e7      beq $e79e                       beq   Input1            ; cancel and new line
.e7b7  c9 08      cmp #$08                        cmp   #$08              ; bs
.e7b9  f0 09      beq $e7c4                       beq   backspace         ;
.e7bb  c9 09      cmp #$09         	       cmp   #$09		   ; TAB key
.e7bd  f0 1b      beq $e7da        	       beq   tabkey		   ;
.e7bf  c9 02      cmp #$02                        cmp   #$02              ; Ctrl-B
.e7c1  d0 e5      bne $e7a8                       bne   InputWait         ; Ignore other codes
.e7c3  00         brk                             brk                     ; Force a keyboard Break cmd
.e7c4  c0 ff      cpy #$ff         backspace      cpy   #$ff              ;
.e7c6  f0 e0      beq $e7a8                       beq   InputWait         ; nothing to do
.e7c8  88         dey                             dey                     ; remove last char
.e7c9  a9 08      lda #$08                        Lda   #$08              ; backup one space
.e7cb  20 0d e8   jsr $e80d                       jsr   Output            ;
.e7ce  a9 20      lda #$20                        Lda   #$20              ; Print space (destructive BS)
.e7d0  20 0d e8   jsr $e80d                       jsr   Output            ;
.e7d3  a9 08      lda #$08                        Lda   #$08              ; backup one space
.e7d5  20 0d e8   jsr $e80d                       jsr   Output            ;
.e7d8  80 ce      bra $e7a8                       BRA   InputWait         ; ready for next key
.e7da  a9 20      lda #$20         tabkey	   lda   #$20		   ; convert tab to space
.e7dc  c8         iny              		   iny			   ; move cursor
.e7dd  30 1f      bmi $e7fe                       bmi   InputTooLong	   ; line too long?
.e7df  99 00 03   sta $0300,y                     sta   Buffer,y		   ; no, save space in buffer
.e7e2  20 0d e8   jsr $e80d        		   jsr   output		   ; print the space too
.e7e5  98         tya                             tya   			   ; test to see if tab is on multiple of 8
.e7e6  29 07      and #$07         		   and   #$07		   ; mask remainder of cursor/8
.e7e8  d0 f0      bne $e7da                       bne   tabkey		   ; not done, add another space
.e7ea  80 bc      bra $e7a8        		   bra   InputWait	   ; done. 
.e7ec  c9 61      cmp #$61         InputSave      CMP   #$61              ;   ucase
.e7ee  90 02      bcc $e7f2                       BCC   InputSave1        ;
.e7f0  e9 20      sbc #$20                        SBC   #$20              ;
.e7f2  c8         iny              InputSave1     INY                     ;
.e7f3  30 09      bmi $e7fe                       BMI   InputTooLong      ; get next char (up to 127)
.e7f5  99 00 03   sta $0300,y                     STA   Buffer,y          ;
.e7f8  20 0d e8   jsr $e80d                       JSR   Output            ; OutputCharacter
.e7fb  80 ab      bra $e7a8                       BRA   InputWait         ;
.e7fd  c8         iny              InputDone      INY                     ;
.e7fe  a9 0d      lda #$0d         InputTooLong   LDA   #$0d              ; force CR at end of 128 characters 
.e800  99 00 03   sta $0300,y                     sta   Buffer,y          ;
.e803  20 0d e8   jsr $e80d                       JSR   Output            ;
.e806  60         rts                             RTS                     ;
.e807  6c eb 03   jmp ($03eb)      Input_chr      jmp   (ChrInVect)       ;
.e80a  6c ee 03   jmp ($03ee)      Scan_input     jmp   (ScanInVect)      ; 
.e80d  6c f1 03   jmp ($03f1)      Output         jmp   (ChrOutVect)      ;
.e810  a9 07      lda #$07         bell           LDA  #$07               ; Ctrl G Bell
.e812  4c 0d e8   jmp $e80d                       jmp  Output             ; 
.e815  48         pha              Delay          PHA                     ; use A to execute a delay loop
.e816  3a         dec              delay1         DEC                     ;
.e817  d0 fd      bne $e816                       BNE   delay1            ;
.e819  68         pla                             PLA                     ;
.e81a  3a         dec                             DEC                     ;
.e81b  d0 f8      bne $e815                       BNE   Delay             ;
.e81d  60         rts              GRTS           RTS                     ;
.e81e  8d e2 03   sta $03e2        BRKroutine     sta   ACC               ; save A    Monitor"s break handler
.e821  8e e3 03   stx $03e3                       stx   Xreg              ; save X
.e824  8c e4 03   sty $03e4                       sty   Yreg              ; save Y
.e827  68         pla                             pla                     ; 
.e828  8d e6 03   sta $03e6                       sta   Preg              ; save P
.e82b  68         pla                             pla                     ; PCL
.e82c  fa         plx                             plx                     ; PCH
.e82d  38         sec                             sec                     ;
.e82e  e9 02      sbc #$02                        sbc   #$02              ;
.e830  8d e1 03   sta $03e1                       sta   PCL               ; backup to BRK cmd
.e833  b0 01      bcs $e836                       bcs   Brk2              ;
.e835  ca         dex                             dex                     ;
.e836  8e e0 03   stx $03e0        Brk2           stx   PCH               ; save PC
.e839  ba         tsx                             TSX                     ; get stack pointer
.e83a  8e e5 03   stx $03e5                       stx   SPtr              ; save stack pointer
.e83d  20 10 e8   jsr $e810                       jsr   Bell              ; Beep speaker
.e840  20 27 e7   jsr $e727                       jsr   PrintReg          ; dump register contents 
.e843  a2 ff      ldx #$ff                        ldx   #$FF              ; 
.e845  9a         txs                             txs                     ; clear stack
.e846  58         cli                             cli                     ; enable interrupts again
.e847  4c 50 e8   jmp $e850                       jmp   Monitor           ; start the monitor
.e84a                              monitorboot
.e84a  20 10 e8   jsr $e810                       jsr   bell              ; beep ready
.e84d  20 c8 e8   jsr $e8c8                       JSR   Version           ;
.e850  a2 ff      ldx #$ff         Monitor        LDX   #$FF              ; 
.e852  9a         txs                             TXS		       ;  Init the stack
.e853  20 51 d9   jsr $d951                       JSR   IEC_Init	       ; call CBM_IEC initialization
.e856  20 9a e7   jsr $e79a                       JSR   input             ;  line input
.e859  a9 00      lda #$00                        LDA   #$00              ;
.e85b  a8         tay                             TAY                     ;  set to 1st character in line
.e85c  85 33      sta $33                         sta   LineCnt           ; normal list vs range list 
.e85e  85 37      sta $37          Mon01          STA   Memchr            ;
.e860  64 3c      stz $3c          Mon02          STZ   Hexdigits         ;  holds parsed hex
.e862  64 3d      stz $3d                         STZ   Hexdigits+1       ;
.e864  20 89 e8   jsr $e889                       JSR   ParseHexDig       ;  Get any Hex chars
.e867  a2 12      ldx #$12                        LDX   #CmdCount         ;  get # of cmds currently used
.e869  dd 1d ef   cmp $ef1d,x      Mon08          CMP   CmdAscii,X        ;  is non hex cmd chr?
.e86c  f0 05      beq $e873                       BEQ   Mon09             ;  yes x= cmd number
.e86e  ca         dex                             DEX                     ;
.e86f  10 f8      bpl $e869                       BPL   Mon08             ;
.e871  80 dd      bra $e850                       BRA   Monitor           ;  no
.e873  da         phx              Mon09          PHX                     ;  save command
.e874  5a         phy                             PHY                     ;  Save input line pointer
.e875  8a         txa                             TXA                     ;
.e876  0a         asl                             ASL                     ;  ptr * 2
.e877  aa         tax                             TAX                     ;  
.e878  20 86 e8   jsr $e886                       JSR   Mon10             ;  Execute cmd
.e87b  7a         ply                             PLY                     ;
.e87c  fa         plx                             PLX                     ;
.e87d  f0 d1      beq $e850                       BEQ   Monitor           ;  done
.e87f  bd 56 ef   lda $ef56,x                     LDA   Cmdseccode,X      ;  
.e882  30 dc      bmi $e860                       BMI   Mon02             ;
.e884  80 d8      bra $e85e                       BRA   Mon01             ;
.e886  7c 30 ef   jmp ($ef30,x)    Mon10          JMP   (Cmdjmptbl,X)     ;
.e889  64 35      stz $35          ParseHexDig    STZ   Hexdigcnt         ;  cntr
.e88b  80 0e      bra $e89b                       BRA   ParseHex05        ;
.e88d  8a         txa              ParseHex03     TXA                     ;  parse hex dig
.e88e  a2 04      ldx #$04                        LDX   #$04              ;  
.e890  06 3c      asl $3c          ParseHex04     ASL   Hexdigits         ;
.e892  26 3d      rol $3d                         ROL   Hexdigits+1       ;
.e894  ca         dex                             DEX                     ;
.e895  d0 f9      bne $e890                       BNE   ParseHex04        ;
.e897  04 3c      tsb $3c                         TSB   Hexdigits         ;
.e899  c6 35      dec $35                         DEC   Hexdigcnt         ;
.e89b  b9 00 03   lda $0300,y      ParseHex05     LDA   buffer,Y          ;
.e89e  a2 0f      ldx #$0f                        LDX   #$0F              ;   is hex chr?
.e8a0  c8         iny                             INY                     ;
.e8a1  dd 0d ef   cmp $ef0d,x      ParseHex07     CMP   Hexdigdata,X      ;
.e8a4  f0 e7      beq $e88d                       BEQ   ParseHex03        ;   yes
.e8a6  ca         dex                             DEX                     ;
.e8a7  10 f8      bpl $e8a1                       BPL   ParseHex07        ;
.e8a9  60         rts                             RTS                     ; Stored in HexDigits if HexDigCnt <> 0
.e8aa  a9 87      lda #$87         Help_cmd       lda   #<Helptxt         ;  lower byte - Menu of Commands
.e8ac  85 3a      sta $3a                         sta   addrptr           ;
.e8ae  a9 f2      lda #$f2                        lda   #>Helptxt         ;  upper byte
.e8b0  85 3b      sta $3b                         sta   addrptr+1         ;
.e8b2  80 0f      bra $e8c3                       bra   Help_cmd3         ;
.e8b4  c9 7e      cmp #$7e         Help_Cmd4      cmp   #$7e              ;  "~"
.e8b6  f0 05      beq $e8bd                       beq   Help_Cmd1         ;
.e8b8  20 0d e8   jsr $e80d                       jsr   Output            ;
.e8bb  80 03      bra $e8c0                       bra   Help_cmd2         ;
.e8bd  20 5e e7   jsr $e75e        Help_cmd1      jsr   Print_CR          ;     
.e8c0  20 7a e9   jsr $e97a        Help_cmd2      jsr   Inc_addrptr       ;
.e8c3  b2 3a      lda ($3a)        Help_cmd3      lda   (addrptr)         ;
.e8c5  d0 ed      bne $e8b4                       bne   Help_cmd4         ;
.e8c7  60         rts                             rts                     ;
.e8c8  20 5e e7   jsr $e75e        Version        jsr   Print_CR          ; 
.e8cb  a2 ff      ldx #$ff                        ldx   #$FF              ; set txt pointer
.e8cd  a9 0d      lda #$0d                        lda   #$0d              ; 
.e8cf  e8         inx              PortReadyMsg   inx                     ;
.e8d0  20 0d e8   jsr $e80d                       JSR   Output            ; put character to Port
.e8d3  bd a1 f8   lda $f8a1,x                     lda   porttxt,x         ; get message text
.e8d6  d0 f7      bne $e8cf                       bne   PortReadyMsg      ; 
.e8d8  60         rts                             rts                     ;
.e8d9  20 e2 e8   jsr $e8e2        Excute_cmd     jsr   exe1              ;
.e8dc  a2 ff      ldx #$ff                        ldx   #$FF              ; reset stack
.e8de  9a         txs                             txs                     ;
.e8df  4c 50 e8   jmp $e850                       jmp   Monitor           ;
.e8e2  6c 3c 00   jmp ($003c)      exe1           JMP   (Hexdigits)       ;
.e8e5  a6 3c      ldx $3c          DOT_cmd        LDX   Hexdigits         ; move address to addrptr
.e8e7  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e8e9  86 3a      stx $3a                         STX   Addrptr           ;
.e8eb  85 3b      sta $3b                         STA   Addrptr+1         ;
.e8ed  e6 33      inc $33                         inc   LineCnt           ; range list command
.e8ef  60         rts                             RTS                     ;
.e8f0  c0 01      cpy #$01         CR_cmd         CPY   #$01              ;
.e8f2  d0 0c      bne $e900                       BNE   SP_cmd            ;
.e8f4  a5 3a      lda $3a                         LDA   Addrptr           ; CR alone - move addrptr to hexdigits
.e8f6  09 0f      ora #$0f                        ORA   #$0F              ;  to simulate entering an address
.e8f8  85 3c      sta $3c                         STA   Hexdigits         ; *** change 07 to 0f for 16 byte/line
.e8fa  a5 3b      lda $3b                         LDA   Addrptr+1         ;
.e8fc  85 3d      sta $3d                         STA   Hexdigits+1       ;
.e8fe  80 17      bra $e917                       BRA   SP_cmd2           ;
.e900  a5 35      lda $35          SP_cmd         LDA   Hexdigcnt         ; Space command entry
.e902  f0 5a      beq $e95e                       BEQ   SP_cmd5           ; any digits to process? no - done
.e904  a6 37      ldx $37                         LDX   Memchr            ; yes - is sec cmd code 0 ? yes - 
.e906  f0 0a      beq $e912                       BEQ   SP_cmd1           ; yes - 
.e908  ca         dex                             DEX                     ; Is sec cmd = 1?       
.e909  f0 1c      beq $e927                       BEQ   SP_cmd3           ;       yes - is sec cmd code 1 ?
.e90b  a5 3c      lda $3c                         LDA   Hexdigits         ;             no - ":" cmd processed
.e90d  92 3a      sta ($3a)                       STA   (Addrptr)         ;
.e90f  4c 7a e9   jmp $e97a                       JMP   Inc_addrptr       ; set to next address and return
.e912  20 e5 e8   jsr $e8e5        SP_cmd1        JSR   DOT_cmd           ; sec dig = 0  move address to addrptr
.e915  80 10      bra $e927                       BRA   SP_cmd3           ;
.e917  a5 3a      lda $3a          SP_cmd2        LDA   Addrptr           ; CR cmd entry 
.e919  89 0f      bit #$0f                        BIT   #$0F              ; *** changed 07 to 0F for 16 bytes/line
.e91b  f0 0a      beq $e927                       BEQ   SP_cmd3           ; if 16, print new line
.e91d  c0 00      cpy #$00                        cpy   #$00              ; if TXT cmd, don"t print the - or spaces between chrs
.e91f  f0 46      beq $e967                       beq   TXT_cmd1          ;
.e921  89 07      bit #$07                        BIT   #$07              ; if 8, print -
.e923  f0 11      beq $e936                       BEQ   SP_cmd33          ;
.e925  80 19      bra $e940                       BRA   SP_cmd4           ; else print next byte
.e927  20 5e e7   jsr $e75e        SP_cmd3        JSR   Print_CR          ; "." cmd - display address and data 
.e92a  20 0a e8   jsr $e80a                       jsr   Scan_Input        ; see if brk requested
.e92d  b0 2d      bcs $e95c                       bcs   SP_brk            ; if so, stop 
.e92f  a5 3b      lda $3b                         LDA   Addrptr+1         ; print address
.e931  a6 3a      ldx $3a                         LDX   Addrptr           ;
.e933  20 6b e7   jsr $e76b                       JSR   Print2Byte        ;
.e936  a9 20      lda #$20         SP_cmd33       LDA   #$20              ; " " print 1 - 16 bytes of data
.e938  20 0d e8   jsr $e80d                       JSR   OUTPUT            ;
.e93b  a9 2d      lda #$2d                        LDA   #$2D              ; "-"
.e93d  20 0d e8   jsr $e80d                       JSR   OUTPUT            ;
.e940  a9 20      lda #$20         SP_cmd4        LDA   #$20              ; " " 
.e942  20 0d e8   jsr $e80d                       JSR   OUTPUT            ;
.e945  c0 00      cpy #$00                        cpy   #$00              ;
.e947  f0 1e      beq $e967                       beq   TXT_Cmd1          ;
.e949  b2 3a      lda ($3a)                       LDA   (Addrptr)         ;
.e94b  20 6f e7   jsr $e76f                       JSR   Print1Byte        ;
.e94e  38         sec              SP_cmd44       SEC                     ;  checks if range done
.e94f  a5 3a      lda $3a                         LDA   Addrptr           ;
.e951  e5 3c      sbc $3c                         SBC   Hexdigits         ;
.e953  a5 3b      lda $3b                         LDA   Addrptr+1         ;
.e955  e5 3d      sbc $3d                         SBC   Hexdigits+1       ;
.e957  20 7a e9   jsr $e97a                       jsr   Inc_addrptr       ;
.e95a  90 bb      bcc $e917                       BCC   SP_cmd2           ; loop until range done
.e95c  64 37      stz $37          SP_brk         STZ   Memchr            ; reset sec cmd code
.e95e  60         rts              SP_cmd5        RTS                     ; done or no digits to process
.e95f  5a         phy              TXT_Cmd        PHY                     ;
.e960  a0 00      ldy #$00                        ldy   #$00              ;
.e962  20 00 e9   jsr $e900                       jsr   SP_cmd            ;
.e965  7a         ply                             PLY                     ;
.e966  60         rts                             RTS                     ;
.e967  b2 3a      lda ($3a)        TXT_cmd1       LDA   (Addrptr)         ;
.e969  29 7f      and #$7f                        AND   #$7F              ;
.e96b  c9 7f      cmp #$7f                        CMP   #$7F              ;
.e96d  f0 04      beq $e973                       BEQ   TXT_Cmd2          ;
.e96f  c9 20      cmp #$20                        CMP   #$20              ; " "
.e971  b0 02      bcs $e975                       BCS   TXT_Cmd3          ;
.e973  a9 2e      lda #$2e         TXT_Cmd2       LDA   #$2E              ; "." use "." if not printable char
.e975  20 0d e8   jsr $e80d        TXT_Cmd3       JSR   OUTPUT            ;
.e978  80 d4      bra $e94e                       BRA   SP_cmd44          ;
.e97a  e6 3a      inc $3a          Inc_addrptr    INC   Addrptr           ;  increments addrptr
.e97c  d0 02      bne $e980                       BNE   Inc_addr1         ;
.e97e  e6 3b      inc $3b                         INC   Addrptr+1         ;
.e980  60         rts              Inc_addr1      RTS                     ;
.e981  a5 33      lda $33          Insert_cmd     lda   Linecnt           ;  "I" cmd code
.e983  f0 3e      beq $e9c3                       beq   Insert_3          ; abort if no . cmd entered
.e985  38         sec                             sec                     ;
.e986  a5 3c      lda $3c                         lda   Hexdigits         ;
.e988  e5 3a      sbc $3a                         sbc   addrptr           ;
.e98a  aa         tax                             tax                     ;
.e98b  a5 3d      lda $3d                         lda   Hexdigits+1       ;
.e98d  e5 3b      sbc $3b                         sbc   addrptr+1         ;
.e98f  a8         tay                             tay                     ;
.e990  90 31      bcc $e9c3                       bcc   Insert_3          ;
.e992  18         clc                             clc                     ;
.e993  8a         txa                             txa                     ;
.e994  65 3e      adc $3e                         adc   memptr            ;
.e996  85 3c      sta $3c                         sta   hexdigits         ;
.e998  98         tya                             tya                     ;
.e999  65 3f      adc $3f                         adc   memptr+1          ;
.e99b  85 3d      sta $3d                         sta   hexdigits+1       ;
.e99d  b2 3e      lda ($3e)        Insert_0       LDA   (memptr)          ;
.e99f  92 3c      sta ($3c)                       STA   (Hexdigits)       ;
.e9a1  a9 ff      lda #$ff                        lda   #$FF              ;
.e9a3  c6 3c      dec $3c                         DEC   Hexdigits         ;  
.e9a5  c5 3c      cmp $3c                         cmp   Hexdigits         ;  
.e9a7  d0 02      bne $e9ab                       BNE   Insert_1          ;
.e9a9  c6 3d      dec $3d                         DEC   Hexdigits+1       ;
.e9ab  c6 3e      dec $3e          Insert_1       dec   Memptr            ;  
.e9ad  c5 3e      cmp $3e                         cmp   Memptr            ;
.e9af  d0 02      bne $e9b3                       bne   Insert_2          ;
.e9b1  c6 3f      dec $3f                         dec   Memptr+1          ;
.e9b3  38         sec              Insert_2       SEC                     ;  
.e9b4  a5 3e      lda $3e                         LDA   memptr            ;
.e9b6  e5 3a      sbc $3a                         SBC   Addrptr           ;
.e9b8  a5 3f      lda $3f                         LDA   memptr+1          ;
.e9ba  e5 3b      sbc $3b                         SBC   Addrptr+1         ;
.e9bc  90 05      bcc $e9c3                       bcc   Insert_3          ;
.e9be  20 0a e8   jsr $e80a                       jsr   Scan_Input        ; see if brk requested
.e9c1  90 da      bcc $e99d                       bcc   Insert_0          ; if so, stop List
.e9c3  60         rts              Insert_3       RTS                     ;
.e9c4  a5 33      lda $33          Move_cmd       lda   Linecnt           ; *** any changes to this routine affect EEPROM_WR too!!!
.e9c6  d0 0d      bne $e9d5                       bne   Move_cmd3         ; abort if no . cmd was used
.e9c8  60         rts              Move_brk       RTS                     ;
.e9c9  e6 3a      inc $3a          Move_cmd1      INC   Addrptr           ;  increments addrptr
.e9cb  d0 02      bne $e9cf                       BNE   Move_cmd2         ;
.e9cd  e6 3b      inc $3b                         INC   Addrptr+1         ;
.e9cf  e6 3c      inc $3c          Move_cmd2      inc   Hexdigits         ;  "M" cmd code
.e9d1  d0 02      bne $e9d5                       bne   Move_cmd3         ;
.e9d3  e6 3d      inc $3d                         inc   Hexdigits+1       ;
.e9d5  38         sec              Move_cmd3      SEC                     ;  checks if range done
.e9d6  a5 3e      lda $3e                         LDA   Memptr            ;
.e9d8  e5 3a      sbc $3a                         SBC   Addrptr           ;
.e9da  a5 3f      lda $3f                         LDA   Memptr+1          ;
.e9dc  e5 3b      sbc $3b                         SBC   Addrptr+1         ;
.e9de  90 e8      bcc $e9c8                       BCC   Move_brk          ;  exit if range done
.e9e0  20 0a e8   jsr $e80a                       jsr   Scan_Input        ; see if brk requested
.e9e3  b0 e3      bcs $e9c8                       bcs   Move_brk          ; 
.e9e5  b2 3a      lda ($3a)                       LDA   (Addrptr)         ;  Moves one byte
.e9e7  92 3c      sta ($3c)                       STA   (Hexdigits)       ;
.e9e9  80 de      bra $e9c9                       BRA   Move_cmd1         ; (zapped after move from eeprom_wr)
.e9eb  b2 3a      lda ($3a)        EEPROM_TEST    lda   (Addrptr)         ;    moved along with Move_cmd for EEPROM_WR
.e9ed  52 3c      eor ($3c)                       eor   (Hexdigits)       ;    ""
.e9ef  30 fa      bmi $e9eb                       bmi   EEPROM_TEST       ;    ""
.e9f1  80 d6      bra $e9c9                       bra   Move_cmd1         ;    ""
.e9f3  a5 3a      lda $3a          EEPROM_WR      lda   Addrptr           ;  move the Move_cmd sub to $0280 (kybrd buffer)
.e9f5  48         pha                             pha                     ;  adding EEPROM test routine 
.e9f6  a5 3b      lda $3b                         lda   Addrptr+1         ;  then run the burn program from RAM
.e9f8  48         pha                             pha                     ;  
.e9f9  a9 c4      lda #$c4                        lda   #<Move_cmd        ;
.e9fb  85 3a      sta $3a                         sta   Addrptr           ;
.e9fd  a9 e9      lda #$e9                        lda   #>Move_cmd        ;
.e9ff  85 3b      sta $3b                         sta   Addrptr+1         ;
.ea01  a0 2e      ldy #$2e                        ldy   #$2E              ;  47 instructions
.ea03  b1 3a      lda ($3a),y      EEPROM_WR1     lda   (Addrptr),y       ;
.ea05  99 80 02   sta $0280,y                     sta   $0280,y           ;
.ea08  88         dey                             dey                     ;
.ea09  10 f8      bpl $ea03                       bpl   EEPROM_WR1        ;
.ea0b  a9 ea      lda #$ea                        lda   #$EA              ; NOP instruction
.ea0d  8d a5 02   sta $02a5                       sta   $02A5             ; *
.ea10  8d a6 02   sta $02a6                       sta   $02A6             ; * affected by changes to Move_cmd routine
.ea13  8d 9c 02   sta $029c                       sta   $029C             ; * affected by changes to Move_cmd routine
.ea16  8d 9d 02   sta $029d                       sta   $029D             ; * affected by changes to Move_cmd routine
.ea19  8d 9e 02   sta $029e                       sta   $029E             ; * affected by changes to Move_cmd routine
.ea1c  8d 9f 02   sta $029f                       sta   $029F             ; * affected by changes to Move_cmd routine
.ea1f  8d a0 02   sta $02a0                       sta   $02A0             ; * affected by changes to Move_cmd routine
.ea22  68         pla                             pla                     ;
.ea23  85 3b      sta $3b                         sta   Addrptr+1         ;
.ea25  68         pla                             pla                     ;
.ea26  85 3a      sta $3a                         sta   Addrptr           ;        
.ea28  4c 80 02   jmp $0280                       jmp   $0280             ;
.ea2b  a6 3c      ldx $3c          Dest_cmd       LDX   Hexdigits         ;  ">" cmd code
.ea2d  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.ea2f  86 3e      stx $3e                         STX   Memptr            ;  move address to memptr
.ea31  85 3f      sta $3f                         STA   Memptr+1          ;
.ea33  60         rts                             RTS                     ;  
.ea34  a5 33      lda $33          LIST_cmd       lda   LineCnt           ;  Check for normal/range
.ea36  f0 29      beq $ea61                       beq   List_cmd_1        ;  0 = normal  1=range 
.ea38  a5 3a      lda $3a                         LDA   Addrptr           ;  Dissassemble range of code
.ea3a  a6 3b      ldx $3b                         LDX   Addrptr+1         ;  move addrptr to startaddr
.ea3c  85 38      sta $38                         STA   Startaddr         ;
.ea3e  86 39      stx $39                         STX   Startaddr+1       ;
.ea40  38         sec              List_range     sec                     ;
.ea41  a5 38      lda $38                         lda   Startaddr         ;
.ea43  e5 3a      sbc $3a                         sbc   Addrptr           ;
.ea45  a5 39      lda $39                         lda   Startaddr+1       ; 
.ea47  e5 3b      sbc $3b                         sbc   Addrptr+1         ;
.ea49  90 15      bcc $ea60                       bcc   List_done         ;
.ea4b  20 79 ea   jsr $ea79                       jsr   List_Line         ;  list one line
.ea4e  20 0a e8   jsr $e80a                       jsr   Scan_Input        ; see if brk requested
.ea51  b0 0d      bcs $ea60                       bcs   List_done         ; if so, stop List
.ea53  38         sec                             SEC                     ;  checks if range done
.ea54  a5 3c      lda $3c                         LDA   Hexdigits         ;
.ea56  e5 38      sbc $38                         SBC   Startaddr         ;
.ea58  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.ea5a  e5 39      sbc $39                         SBC   Startaddr+1       ;
.ea5c  b0 e2      bcs $ea40                       BCS   List_range        ;  if not, loop until done
.ea5e  64 33      stz $33                         stz   LineCnt           ;
.ea60  60         rts              List_done      RTS                     ;
.ea61  a5 35      lda $35          List_cmd_1     LDA   Hexdigcnt         ; Dissassemble one page of cmds
.ea63  f0 08      beq $ea6d                       BEQ   List1             ; followed with more pages 
.ea65  a6 3c      ldx $3c                         LDX   Hexdigits         ;
.ea67  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.ea69  86 38      stx $38                         STX   Startaddr         ;
.ea6b  85 39      sta $39                         STA   Startaddr+1       ;
.ea6d  a9 14      lda #$14         List1          LDA   #$14              ; one page of dissassembly
.ea6f  85 33      sta $33                         STA   Linecnt           ;
.ea71  20 79 ea   jsr $ea79        List2          JSR   List_line         ;
.ea74  c6 33      dec $33                         DEC   Linecnt           ;
.ea76  d0 f9      bne $ea71                       BNE   List2             ;
.ea78  60         rts                             RTS                     ;
.ea79  20 5e e7   jsr $e75e        List_line      JSR   Print_CR          ; 
.ea7c  20 8b ea   jsr $ea8b                       JSR   List_one          ; one line of dissassembly
.ea7f  18         clc                             CLC                     ;
.ea80  a5 38      lda $38                         LDA   Startaddr         ; inc address pointer to next cmd
.ea82  65 35      adc $35                         ADC   Hexdigcnt         ;
.ea84  85 38      sta $38                         STA   Startaddr         ;
.ea86  90 02      bcc $ea8a                       BCC   List3             ;
.ea88  e6 39      inc $39                         INC   Startaddr+1       ;
.ea8a  60         rts              List3          RTS                     ;
.ea8b  b2 38      lda ($38)        List_one       LDA   (Startaddr)       ; Dissassemble one CMD from Startaddr
.ea8d  aa         tax                             TAX                     ; Initialize List Cmd pointers
.ea8e  bd 69 ef   lda $ef69,x                     LDA   OPCtxtidx,X       ;
.ea91  85 36      sta $36                         STA   OPCtxtptr         ;
.ea93  bd 69 f0   lda $f069,x                     LDA   OPCaddmode,X      ;
.ea96  29 0f      and #$0f                        AND   #$0F              ; mask out psuedo-modes
.ea98  85 34      sta $34                         STA   Modejmp           ;
.ea9a  aa         tax                             TAX                     ;
.ea9b  bd 69 f1   lda $f169,x                     LDA   ModeByteCnt,X     ;
.ea9e  85 35      sta $35                         STA   Hexdigcnt         ;
.eaa0  a5 39      lda $39                         LDA   Startaddr+1       ;
.eaa2  a6 38      ldx $38                         LDX   Startaddr         ;
.eaa4  20 6b e7   jsr $e76b                       JSR   Print2Byte        ; print address 
.eaa7  a9 2d      lda #$2d                        LDA   #$2D              ;  "-"
.eaa9  20 0d e8   jsr $e80d                       JSR   OUTPUT            ;
.eaac  20 8c e7   jsr $e78c                       JSR   Print2SP          ; print "  "
.eaaf  a2 01      ldx #$01                        LDX   #$01              ;---------
.eab1  a0 00      ldy #$00         List4          LDY   #$00              ;print up to 3 ascii chars...
.eab3  c4 35      cpy $35          List5          CPY   Hexdigcnt         ;  two spaces...
.eab5  b0 0b      bcs $eac2                       BCS   List6             ;  up to three hex chars...
.eab7  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;  two spaces
.eab9  e0 00      cpx #$00                        CPX   #$00              ;
.eabb  d0 0e      bne $eacb                       BNE   List8             ;
.eabd  20 6f e7   jsr $e76f                       JSR   Print1Byte        ;
.eac0  80 07      bra $eac9                       BRA   List7             ;
.eac2  e0 00      cpx #$00         List6          CPX   #$00              ;
.eac4  d0 03      bne $eac9                       BNE   List7             ;
.eac6  20 8c e7   jsr $e78c                       JSR   Print2SP          ;
.eac9  a9 20      lda #$20         List7          LDA   #$20              ; " "
.eacb  29 7f      and #$7f         List8          AND   #$7F              ;
.eacd  c9 7f      cmp #$7f                        CMP   #$7F              ;
.eacf  f0 04      beq $ead5                       BEQ   List9             ;
.ead1  c9 20      cmp #$20                        CMP   #$20              ; " "
.ead3  b0 02      bcs $ead7                       BCS   List10            ;
.ead5  a9 2e      lda #$2e         List9          LDA   #$2E              ; "." use "." if not printable char
.ead7  20 0d e8   jsr $e80d        List10         JSR   OUTPUT            ;
.eada  c8         iny                             INY                     ;
.eadb  c0 03      cpy #$03                        CPY   #$03              ;
.eadd  90 d4      bcc $eab3                       BCC   List5             ;
.eadf  20 8c e7   jsr $e78c                       JSR   Print2SP          ;
.eae2  ca         dex                             DEX                     ;
.eae3  f0 cc      beq $eab1                       BEQ   List4             ;---------
.eae5  a5 36      lda $36                         LDA   OPCtxtptr         ; get opcode text
.eae7  0a         asl                             ASL                     ;
.eae8  65 36      adc $36                         ADC   OPCtxtptr         ;
.eaea  aa         tax                             TAX                     ;
.eaeb  a0 fd      ldy #$fd                        LDY   #$FD              ;
.eaed  bd a9 f1   lda $f1a9,x      List11         LDA   OPCtxtData,X      ;
.eaf0  20 0d e8   jsr $e80d                       JSR   OUTPUT            ; print opcode text
.eaf3  e8         inx                             INX                     ;
.eaf4  c8         iny                             INY                     ;
.eaf5  d0 f6      bne $eaed                       BNE   List11            ;
.eaf7  a5 36      lda $36                         LDA   OPCtxtptr         ;
.eaf9  c9 42      cmp #$42                        CMP   #$42              ; 4chr opcodes start
.eafb  30 19      bmi $eb16                       BMI   List12		   ;
.eafd  c9 46      cmp #$46                        CMP   #$46              ; the .xx cmds
.eaff  10 15      bpl $eb16                       BPL   List12            ; 
.eb01  b2 38      lda ($38)                       lda   (startaddr)	   ; get opcode of 4byte code
.eb03  4a         lsr                             lsr
.eb04  4a         lsr                             lsr
.eb05  4a         lsr                             lsr
.eb06  4a         lsr                             lsr
.eb07  29 07      and #$07                        AND   #$07              ; strip last 3 bits
.eb09  09 30      ora #$30                        ora   #$30              ; add CHR '0'
.eb0b  20 0d e8   jsr $e80d                       jsr   Output            ; print it
.eb0e  a9 20      lda #$20                        lda   #$20              ; " "
.eb10  20 0d e8   jsr $e80d                       jsr   Output            ; 
.eb13  4c 19 eb   jmp $eb19                       jmp   List13            ;
.eb16  20 8c e7   jsr $e78c        List12         JSR   Print2SP          ;
.eb19  a5 34      lda $34          List13         LDA   Modejmp           ; setup to print operand
.eb1b  0a         asl                             ASL                     ;
.eb1c  aa         tax                             TAX                     ;
.eb1d  7c 79 f1   jmp ($f179,x)                   JMP   (ModeJmpTbl,X)    ; goto operand printing command
.eb20  a9 23      lda #$23         IMM_mode       LDA   #$23              ; print #$HH
.eb22  20 0d e8   jsr $e80d                       JSR   output            ;
.eb25  a9 24      lda #$24         ZP_mode        LDA   #$24              ; print $HH
.eb27  20 0d e8   jsr $e80d                       JSR   output            ;
.eb2a  a0 01      ldy #$01                        LDY   #$01              ;
.eb2c  b1 38      lda ($38),y      Byte_mode      LDA   (Startaddr),Y     ;
.eb2e  4c 6f e7   jmp $e76f                       JMP   Print1Byte        ;
.eb31  20 25 eb   jsr $eb25        ZP_X_mode      JSR   ZP_mode           ; print $HH,X
.eb34  a9 2c      lda #$2c         X_mode         LDA   #$2C              ; print ,X
.eb36  20 0d e8   jsr $e80d                       JSR   output            ;
.eb39  a9 58      lda #$58                        LDA   #$58              ; 
.eb3b  4c 0d e8   jmp $e80d                       JMP   output            ;
.eb3e  20 25 eb   jsr $eb25        ZP_Y_mode      JSR   ZP_mode           ; print $HH,Y
.eb41  a9 2c      lda #$2c         Y_mode         LDA   #$2C              ; Print ,Y
.eb43  20 0d e8   jsr $e80d                       JSR   output            ;
.eb46  a9 59      lda #$59                        LDA   #$59              ; 
.eb48  4c 0d e8   jmp $e80d                       JMP   output            ;
.eb4b  20 91 eb   jsr $eb91        INDZP_mode     JSR   IND0_mode         ; Print ($HH)
.eb4e  20 25 eb   jsr $eb25                       JSR   ZP_mode           ;
.eb51  a9 29      lda #$29         IND1_mode      LDA   #$29              ; Print )
.eb53  4c 0d e8   jmp $e80d                       JMP   output            ;
.eb56  20 91 eb   jsr $eb91        INDZP_X_mode   JSR   IND0_mode         ; Print ($HH,X)
.eb59  20 25 eb   jsr $eb25                       JSR   ZP_mode           ;
.eb5c  20 34 eb   jsr $eb34                       JSR   X_mode            ;
.eb5f  80 f0      bra $eb51                       BRA   IND1_mode         ;
.eb61  20 4b eb   jsr $eb4b        INDZP_Y_mode   JSR   INDZP_mode        ; Print ($HH),Y
.eb64  80 db      bra $eb41                       BRA   Y_mode            ;
.eb66  a9 24      lda #$24         ABS_mode       LDA   #$24              ; Print $HHHH
.eb68  20 0d e8   jsr $e80d                       JSR   output            ;
.eb6b  a0 02      ldy #$02                        LDY   #$02              ;
.eb6d  20 2c eb   jsr $eb2c                       JSR   Byte_mode         ;
.eb70  88         dey                             DEY                     ;
.eb71  80 b9      bra $eb2c                       BRA   Byte_mode         ;
.eb73  20 66 eb   jsr $eb66        ABS_X_mode     JSR   ABS_mode          ; Print $HHHH,X
.eb76  80 bc      bra $eb34                       BRA   X_mode            ;
.eb78  20 66 eb   jsr $eb66        ABS_Y_mode     JSR   ABS_mode          ; Print $HHHH,Y
.eb7b  80 c4      bra $eb41                       BRA   Y_mode            ;
.eb7d  20 91 eb   jsr $eb91        INDABS_mode    JSR   IND0_mode         ; Print ($HHHH)
.eb80  20 66 eb   jsr $eb66                       JSR   ABS_mode          ;
.eb83  80 cc      bra $eb51                       BRA   IND1_mode         ;
.eb85  20 91 eb   jsr $eb91        INDABSX_mode   JSR   IND0_mode         ; Print ($HHHH,X)
.eb88  20 66 eb   jsr $eb66                       JSR   ABS_mode          ;
.eb8b  20 34 eb   jsr $eb34                       JSR   X_mode            ;
.eb8e  80 c1      bra $eb51                       BRA   IND1_mode         ;
.eb90  60         rts              IMPLIED_mode   RTS                     ; Implied/Accumulator mode 
.eb91  a9 28      lda #$28         IND0_mode      LDA   #$28              ; Print (
.eb93  4c 0d e8   jmp $e80d                       JMP   output            ;
.eb96  20 25 eb   jsr $eb25        BBREL_mode     JSR   ZP_mode		   ;
.eb99  a9 2c      lda #$2c         		   LDA   #$2C              ; Print ,
.eb9b  20 0d e8   jsr $e80d                       JSR   output            ;
.eb9e  a9 24      lda #$24                        LDA   #$24              ; Print $
.eba0  20 0d e8   jsr $e80d                       JSR   output            ;
.eba3  a0 02      ldy #$02                        LDY   #$02		   ;
.eba5  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;
.eba7  85 37      sta $37                         STA   Memchr            ;
.eba9  18         clc                             CLC                     ;
.ebaa  a5 38      lda $38                         LDA   Startaddr         ;
.ebac  69 03      adc #$03                        ADC   #$03              ;
.ebae  4c c1 eb   jmp $ebc1                       JMP   REL_mode0         ;
.ebb1  a9 24      lda #$24         REL_mode       LDA   #$24              ; Print $HHHH as Relative Branch
.ebb3  20 0d e8   jsr $e80d                       JSR   output            ;
.ebb6  a0 01      ldy #$01                        LDY   #$01              ;
.ebb8  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;
.ebba  85 37      sta $37                         STA   Memchr            ;
.ebbc  18         clc                             CLC                     ;
.ebbd  a5 38      lda $38                         LDA   Startaddr         ;
.ebbf  69 02      adc #$02                        ADC   #$02              ;
.ebc1  aa         tax              REL_mode0      TAX                     ;
.ebc2  a5 39      lda $39                         LDA   Startaddr+1       ;
.ebc4  69 00      adc #$00                        ADC   #$00              ;
.ebc6  a8         tay                             TAY                     ;
.ebc7  18         clc                             CLC                     ;
.ebc8  8a         txa                             TXA                     ;
.ebc9  65 37      adc $37                         ADC   Memchr            ;
.ebcb  aa         tax                             TAX                     ;
.ebcc  98         tya                             TYA                     ;
.ebcd  a4 37      ldy $37                         LDY   Memchr            ;
.ebcf  10 01      bpl $ebd2                       BPL   Rel_mode1         ;
.ebd1  3a         dec                             DEC                     ;
.ebd2  69 00      adc #$00         Rel_mode1      ADC   #$00              ;
.ebd4  4c 6b e7   jmp $e76b                       JMP   Print2Byte        ;
.ebd7  ba         tsx              Assem_Init     tsx                     ;
.ebd8  e8         inx                             inx                     ;
.ebd9  e8         inx                             inx                     ;
.ebda  e8         inx                             inx                     ;
.ebdb  e8         inx                             inx                     ;
.ebdc  9e 00 01   stz $0100,x                     stz   $0100,x           ;
.ebdf  20 c8 e8   jsr $e8c8                       jsr   version           ;  show version and ? prompt
.ebe2  4c 05 ec   jmp $ec05                       jmp   Assembler         ;
.ebe5  a9 e3      lda #$e3         Asm_Help       lda   #<AsmHelptxt      ;  lower byte - Menu of Commands
.ebe7  85 3a      sta $3a                         sta   addrptr           ;
.ebe9  a9 f6      lda #$f6                        lda   #>AsmHelptxt      ;  upper byte
.ebeb  85 3b      sta $3b                         sta   addrptr+1         ;
.ebed  80 0f      bra $ebfe                       bra   AsmHelp3          ;
.ebef  c9 7e      cmp #$7e         ASmHelp4       cmp   #$7e              ;  "~"
.ebf1  f0 05      beq $ebf8                       beq   AsmHelp1          ;
.ebf3  20 0d e8   jsr $e80d                       jsr   Output            ;
.ebf6  80 03      bra $ebfb                       bra   AsmHelp2          ;
.ebf8  20 5e e7   jsr $e75e        AsmHelp1       jsr   Print_CR          ;     
.ebfb  20 7a e9   jsr $e97a        AsmHelp2       jsr   Inc_addrptr       ;
.ebfe  b2 3a      lda ($3a)        AsmHelp3       lda   (addrptr)         ;
.ec00  d0 ed      bne $ebef                       bne   AsmHelp4          ;
.ec02  20 d3 ee   jsr $eed3                       jsr   Opcode_List       ;  
.ec05  a2 ff      ldx #$ff         Assembler      LDX   #$FF              ;
.ec07  9a         txs                             TXS                     ; init stack
.ec08  64 35      stz $35                         stz   HexDigCnt         ;
.ec0a  20 97 e7   jsr $e797                       jsr   Input_assem       ;
.ec0d  a0 00      ldy #$00                        ldy   #$00              ; beginning of input line
.ec0f  ad 00 03   lda $0300                       lda   buffer            ;
.ec12  c9 0d      cmp #$0d                        cmp   #$0d              ; Enter = done 
.ec14  d0 03      bne $ec19                       bne   Asm01             ;
.ec16  4c 50 e8   jmp $e850                       JMP   Monitor           ; exit assembler
.ec19  c9 3f      cmp #$3f         Asm01          cmp   #$3f              ; "?" Print Help
.ec1b  f0 c8      beq $ebe5                       beq   Asm_Help          ;
.ec1d  c9 20      cmp #$20                        cmp   #$20              ; space
.ec1f  f0 3b      beq $ec5c                       beq   Asm_opfetch       ;
.ec21  c9 3b      cmp #$3b                        cmp   #$3b              ;  ";" ignore line
.ec23  f0 e0      beq $ec05                       beq   Assembler         ;
.ec25  c9 4c      cmp #$4c                        cmp   #$4C              ;  "L" list
.ec27  f0 2c      beq $ec55                       beq   Asm_List          ;
.ec29  c9 24      cmp #$24                        cmp   #$24              ;  "$" ignore this
.ec2b  d0 01      bne $ec2e                       bne   Asm02             ;
.ec2d  c8         iny                             iny                     ;
.ec2e  64 3c      stz $3c          Asm02          STZ   Hexdigits         ;  holds parsed hex
.ec30  64 3d      stz $3d                         STZ   Hexdigits+1       ;
.ec32  20 89 e8   jsr $e889                       JSR   ParseHexDig       ;  get Hex Chars 
.ec35  a6 35      ldx $35                         LDX   Hexdigcnt         ;
.ec37  f0 08      beq $ec41                       Beq   Asm_Err           ;
.ec39  c9 4c      cmp #$4c                        cmp   #$4C              ; "L" do list               ???
.ec3b  f0 1a      beq $ec57                       Beq   Asm_List1         ;
.ec3d  c9 20      cmp #$20                        cmp   #$20              ; Space
.ec3f  f0 1b      beq $ec5c                       Beq   Asm_opfetch       ;
.ec41  98         tya              Asm_Err        tya                     ;  get line pointer
.ec42  aa         tax                             tax                     ;
.ec43  a9 0a      lda #$0a                        lda   #$0a              ; LF move down one line
.ec45  20 0d e8   jsr $e80d                       jsr   output            ;
.ec48  20 87 e7   jsr $e787                       jsr   PrintXSP          ; move to where error occured
.ec4b  a9 5e      lda #$5e                        lda   #$5E              ; "^"                       ???
.ec4d  20 0d e8   jsr $e80d                       jsr   Output            ; mark it 
.ec50  20 10 e8   jsr $e810                       jsr   bell              ; 
.ec53  80 b0      bra $ec05                       bra   Assembler         ;
.ec55  64 35      stz $35          Asm_list       stz   HexDigcnt         ;
.ec57  20 61 ea   jsr $ea61        Asm_List1      jsr   List_Cmd_1        ;
.ec5a  80 a9      bra $ec05        Asm_hop        bra   Assembler         ;
.ec5c  a5 35      lda $35          Asm_opfetch    lda   HexDigCnt         ;
.ec5e  f0 0a      beq $ec6a                       beq   Asm_op01          ; no address change
.ec60  a6 3c      ldx $3c                         LDX   Hexdigits         ;
.ec62  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.ec64  86 3a      stx $3a                         STX   AddrPtr           ;
.ec66  85 3b      sta $3b                         STA   AddrPtr+1         ;
.ec68  88         dey                             dey                     ;
.ec69  c8         iny              Asm_stripSP    iny                     ;
.ec6a  b9 00 03   lda $0300,y      Asm_op01       lda   buffer,y          ;
.ec6d  c9 20      cmp #$20                        cmp   #$20              ; strip spaces
.ec6f  f0 f8      beq $ec69                       beq   Asm_stripSP       ;
.ec71  c9 0d      cmp #$0d                        cmp   #$0d              ; done
.ec73  f0 e5      beq $ec5a                       beq   Asm_hop           ;
.ec75  c9 3b      cmp #$3b                        cmp   #$3b              ; ";" comment char done
.ec77  f0 e1      beq $ec5a                       beq   Asm_hop           ;
.ec79  a2 00      ldx #$00                        ldx   #$00              ;
.ec7b  86 36      stx $36                         stx   OpcTxtPtr         ;
.ec7d  84 33      sty $33                         sty   LineCnt           ;
.ec7f  a4 33      ldy $33          Asm_opclp      ldy   LineCnt           ;
.ec81  a5 36      lda $36                         lda   OpcTxtPtr         ;
.ec83  0a         asl                             ASL                     ;
.ec84  65 36      adc $36                         adc   OpcTxtPtr         ;
.ec86  aa         tax                             tax                     ;
.ec87  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.ec8a  c8         iny                             iny                     ;
.ec8b  dd a9 f1   cmp $f1a9,x                     cmp   OpcTxtData,x      ;
.ec8e  d0 14      bne $eca4                       bne   Asm_getnext       ;
.ec90  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.ec93  e8         inx                             inx                     ;
.ec94  c8         iny                             iny                     ;
.ec95  dd a9 f1   cmp $f1a9,x                     cmp   OpcTxtData,x      ;
.ec98  d0 0a      bne $eca4                       bne   Asm_getnext       ;
.ec9a  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.ec9d  e8         inx                             inx                     ;
.ec9e  c8         iny                             iny                     ;
.ec9f  dd a9 f1   cmp $f1a9,x                     cmp   OpcTxtData,x      ;
.eca2  f0 0c      beq $ecb0                       beq   Asm_goodop        ;
.eca4  a6 36      ldx $36          Asm_getnext    ldx   OpcTxtPtr         ;
.eca6  e8         inx                             inx                     ;
.eca7  86 36      stx $36                         stx   OpcTxtPtr         ;
.eca9  e0 4a      cpx #$4a                        cpx   #$4A              ; last one? then err
.ecab  d0 d2      bne $ec7f                       bne   Asm_opclp
.ecad  4c 41 ec   jmp $ec41        Asm_err2       jmp   Asm_err
.ecb0  a9 00      lda #$00         Asm_goodop     lda   #$00
.ecb2  85 34      sta $34                         sta   ModeJmp           ; 
.ecb4  c6 34      dec $34                         dec   ModeJmp           ; init to FF for () check
.ecb6  85 3c      sta $3c                         sta   HexDigits         ; and Byte holder
.ecb8  85 3d      sta $3d                         sta   HexDigits+1       ; 
.ecba  85 35      sta $35                         sta   HexDigCnt         ;
.ecbc  a6 36      ldx $36                         ldx   OpcTxtPtr         ;
.ecbe  e0 42      cpx #$42                        cpx   #$42              ; 
.ecc0  30 18      bmi $ecda                       bmi   Asm_goodSP        ; not a 4 chr opcode
.ecc2  e0 46      cpx #$46                        cpx   #$46              
.ecc4  10 14      bpl $ecda                       bpl   Asm_goodSP        ; not a 4 chr opcode
.ecc6  b9 00 03   lda $0300,y                     lda   buffer,y          ; get next chr
.ecc9  c8         iny                             iny                     ; advance pointer
.ecca  c9 38      cmp #$38                        cmp   #$38              ; 
.eccc  10 df      bpl $ecad                       bpl   Asm_err2          ; not chr "0"-"7"
.ecce  c9 30      cmp #$30                        cmp   #$30
.ecd0  30 db      bmi $ecad                       bmi   Asm_err2          ; not chr "0"-"7"
.ecd2  0a         asl                             ASL
.ecd3  0a         asl                             ASL
.ecd4  0a         asl                             ASL
.ecd5  0a         asl                             ASL
.ecd6  85 39      sta $39                         sta   startaddr_H       ; temp holder for 4th chr opcode
.ecd8  a9 80      lda #$80                        LDA   #$80              ; flag for 
.ecda  be 00 03   ldx $0300,y      Asm_goodSP     ldx   buffer,y          ; get next operand char
.ecdd  c8         iny                             iny                     ; point to next operand chr
.ecde  e0 20      cpx #$20                        cpx   #$20              ;  sp
.ece0  d0 24      bne $ed06                       bne   Asm_GoodSP2
.ece2  c9 80      cmp #$80                        cmp   #$80
.ece4  30 f4      bmi $ecda                       bmi   Asm_goodSP
.ece6  a6 36      ldx $36          Asm_goodSP1    ldx   OpcTxtPtr         ; check if its a BBRx or BBSx opcode
.ece8  e0 44      cpx #$44                        cpx   #$44              ; 
.ecea  10 ee      bpl $ecda                       bpl   Asm_GoodSP        ;
.ecec  a6 35      ldx $35                         ldx   HexDigCnt         ;
.ecee  f0 ea      beq $ecda                       beq   Asm_goodSP        ;
.ecf0  c9 d0      cmp #$d0                        cmp   #$D0              ; already have zp & rel?
.ecf2  10 e6      bpl $ecda                       bpl   Asm_GoodSP        ; we don't care then
.ecf4  c9 c0      cmp #$c0                        cmp   #$C0              ; already got a zp address?
.ecf6  10 b5      bpl $ecad                       bpl   Asm_Err2          ; then error
.ecf8  a6 3d      ldx $3d                         ldx   HexDigits+1
.ecfa  d0 b1      bne $ecad                       bne   Asm_err2          ; not zero page
.ecfc  a6 3c      ldx $3c                         ldx   HexDigits
.ecfe  86 38      stx $38                         stx   startaddr         ; temp zp value for BBRx & BBSx cmds 
.ed00  09 40      ora #$40                        ora   #$40              ; mark zp address fetched
.ed02  29 f7      and #$f7                        and   #$F7              ; mask out zp address found
.ed04  80 d4      bra $ecda                       bra   Asm_goodSP        ; get next chr
.ed06  e0 0d      cpx #$0d         Asm_goodSp2    cpx   #$0d              ;  CR
.ed08  d0 03      bne $ed0d                       bne   Asm_eol
.ed0a  4c c4 ed   jmp $edc4        Asm_jmp1       jmp   Asm_modeSrch
.ed0d  e0 3b      cpx #$3b         Asm_eol        cpx   #$3b              ;  ";"
.ed0f  f0 f9      beq $ed0a                       beq   Asm_jmp1
.ed11  48         pha                             pha
.ed12  a5 36      lda $36                         lda   OpcTxtPtr
.ed14  c9 46      cmp #$46                        cmp   #$46              ; normal opcode if <=45h
.ed16  30 44      bmi $ed5c                       bmi   Asm_opnd1
.ed18  d0 19      bne $ed33                       bne   Asm_xtra1
.ed1a  e0 24      cpx #$24                        cpx   #$24              ; $ .db pseudo-opcode
.ed1c  f0 01      beq $ed1f                       beq   Asm_db1
.ed1e  88         dey                             dey
.ed1f  20 89 e8   jsr $e889        Asm_db1        jsr   ParseHexDig
.ed22  fa         plx                             plx
.ed23  a6 35      ldx $35                         ldx   HexDigCnt
.ed25  f0 86      beq $ecad                       beq   Asm_err2          ; no digits retrieved
.ed27  a0 00      ldy #$00                        ldy   #$00
.ed29  a9 01      lda #$01                        lda   #$01
.ed2b  48         pha                             PHA
.ed2c  a5 3c      lda $3c                         lda   HexDigits
.ed2e  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ed30  4c 5f ee   jmp $ee5f                       jmp   Asm_save
.ed33  c9 47      cmp #$47         Asm_xtra1      cmp   #$47              ; .dw pseudo-opcode
.ed35  d0 1e      bne $ed55                       bne   Asm_xtra2 
.ed37  e0 24      cpx #$24                        cpx   #$24              ; $
.ed39  f0 01      beq $ed3c                       beq   Asm_dw1
.ed3b  88         dey                             dey
.ed3c  20 89 e8   jsr $e889        Asm_dw1        jsr   ParseHexDig
.ed3f  fa         plx                             plx
.ed40  a6 35      ldx $35                         ldx   HexDigCnt
.ed42  f0 7d      beq $edc1                       beq   Asm_err1          ; no digits retrieved
.ed44  a0 00      ldy #$00                        ldy   #$00
.ed46  a9 02      lda #$02                        lda   #$02
.ed48  48         pha                             PHA
.ed49  a5 3c      lda $3c                         lda   HexDigits
.ed4b  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ed4d  a5 3d      lda $3d                         lda   HexDigits+1
.ed4f  c8         iny                             iny
.ed50  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ed52  4c 5f ee   jmp $ee5f                       jmp   Asm_save
.ed55  c9 48      cmp #$48         Asm_xtra2      cmp   #$48              ; .ds pseudo-opcode
.ed57  d0 68      bne $edc1                       bne   Asm_err1 
.ed59  4c a5 ee   jmp $eea5                       jmp   Asm_txt
.ed5c  68         pla              Asm_opnd1      pla
.ed5d  e0 23      cpx #$23                        cpx   #$23              ;  #    20
.ed5f  d0 05      bne $ed66                       bne   Asm_parse01
.ed61  09 20      ora #$20                        ora   #$20
.ed63  4c da ec   jmp $ecda                       jmp   Asm_goodSP 
.ed66  e0 28      cpx #$28         Asm_parse01    cpx   #$28              ;  (   04
.ed68  d0 0b      bne $ed75                       bne   Asm_parse02
.ed6a  09 04      ora #$04                        ora   #$04
.ed6c  a6 34      ldx $34                         ldx   modeJmp
.ed6e  10 51      bpl $edc1                       bpl   Asm_err1          ;  more than one ( 
.ed70  e6 34      inc $34                         inc   ModeJmp
.ed72  4c da ec   jmp $ecda                       jmp   Asm_goodSP 
.ed75  e0 29      cpx #$29         Asm_parse02    cpx   #$29              ;  )
.ed77  d0 09      bne $ed82                       bne   Asm_parse03
.ed79  a6 34      ldx $34                         ldx   ModeJmp
.ed7b  d0 44      bne $edc1                       bne   Asm_err1          ;  ) without (
.ed7d  e6 34      inc $34                         inc   ModeJmp
.ed7f  4c da ec   jmp $ecda                       jmp   Asm_goodSP 
.ed82  e0 2c      cpx #$2c         Asm_parse03    cpx   #$2C              ;  ,
.ed84  d0 1e      bne $eda4                       bne   Asm_parse04
.ed86  be 00 03   ldx $0300,y                     ldx   buffer,y
.ed89  e0 58      cpx #$58                        cpx   #$58              ;  X        02
.ed8b  d0 06      bne $ed93                       bne   Asm_parse31
.ed8d  09 02      ora #$02                        ora   #$02
.ed8f  c8         iny                             iny
.ed90  4c da ec   jmp $ecda                       jmp   Asm_goodSP
.ed93  e0 59      cpx #$59         Asm_parse31    cpx   #$59              ;  Y        01 
.ed95  f0 07      beq $ed9e                       beq   Asm_parse32
.ed97  c9 80      cmp #$80                        cmp   #$80              ;  is BBRx or BBSx cmd active?
.ed99  30 26      bmi $edc1                       bmi   Asm_err1          ;  , without X or Y or 4byte opcode      
.ed9b  4c e6 ec   jmp $ece6                       jmp   Asm_goodSP1       ;  save zp address
.ed9e  09 01      ora #$01         Asm_parse32    ora   #$01
.eda0  c8         iny                             iny
.eda1  4c da ec   jmp $ecda                       jmp   Asm_goodSP 
.eda4  e0 24      cpx #$24         Asm_parse04    cpx   #$24              ;  $
.eda6  f0 01      beq $eda9                       beq   Asm_parse42       ;   
.eda8  88         dey                             dey                     ; not #$(),X,Y  so try Hexdig, if not err
.eda9  48         pha              Asm_parse42    pha
.edaa  20 89 e8   jsr $e889                       jsr   ParseHexDig
.edad  88         dey                             dey                     ; adjust input line pointer
.edae  68         pla                             pla
.edaf  a6 35      ldx $35                         ldx   HexDigCnt
.edb1  f0 0e      beq $edc1                       beq   Asm_err1          ; no digits retrieved
.edb3  a6 3d      ldx $3d                         ldx   HexDigits+1    
.edb5  d0 05      bne $edbc                       bne   Asm_parse41
.edb7  09 08      ora #$08                        ora   #$08              ; <256               08
.edb9  4c da ec   jmp $ecda                       jmp   Asm_goodSP
.edbc  09 10      ora #$10         Asm_parse41    ora   #$10              ; 2 bytes            10 
.edbe  4c da ec   jmp $ecda                       jmp   Asm_goodSP 
.edc1  4c 41 ec   jmp $ec41        Asm_err1       jmp   Asm_Err
.edc4  a2 0f      ldx #$0f         Asm_ModeSrch   ldx   #$0F              ; # of modes
.edc6  dd 99 f1   cmp $f199,x      Asm_ModeS1     cmp   Asm_ModeLst,x
.edc9  f0 05      beq $edd0                       beq   Asm_ModeFnd 
.edcb  ca         dex                             dex   
.edcc  10 f8      bpl $edc6                       bpl   Asm_ModeS1
.edce  80 f1      bra $edc1                       bra   Asm_Err1          ; invalid Mode
.edd0  86 37      stx $37          Asm_ModeFnd    stx   Memchr            ; save mode
.edd2  c9 80      cmp #$80                        cmp   #$80              ; is it 4 chr opcode?
.edd4  30 05      bmi $eddb                       bmi   Asm_opcSrch       ;no
.edd6  8a         txa                             txa
.edd7  05 39      ora $39                         ora   startaddr_H       ; adjust the psuedo mode               
.edd9  85 37      sta $37                         sta   Memchr            ; set proper mode
.eddb  a2 00      ldx #$00         Asm_opcSrch    ldx   #$00
.eddd  bd 69 ef   lda $ef69,x      Asm_opcSrch1   lda   OpcTxtidx,x
.ede0  c5 36      cmp $36                         cmp   OpcTxtPtr
.ede2  d0 07      bne $edeb                       bne   Asm_srchNxt   
.ede4  bd 69 f0   lda $f069,x                     lda   OPCaddmode,x
.ede7  c5 37      cmp $37                         cmp   Memchr
.ede9  f0 2d      beq $ee18                       beq   Asm_OpcFnd
.edeb  e8         inx              Asm_srchNxt    inx
.edec  d0 ef      bne $eddd                       bne   Asm_opcSrch1 
.edee  a5 37      lda $37                         lda   Memchr            ;
.edf0  c9 02      cmp #$02                        cmp   #$02              ; ZP
.edf2  d0 06      bne $edfa                       bne   Asm_srchAlt 
.edf4  a9 01      lda #$01                        LDA   #$01              ; ABS
.edf6  85 37      sta $37                         sta   Memchr
.edf8  80 e1      bra $eddb                       bra   Asm_opcSrch
.edfa  c9 01      cmp #$01         Asm_srchAlt    cmp   #$01              ; ABS
.edfc  d0 06      bne $ee04                       bne   Asm_srchA0
.edfe  a9 0a      lda #$0a                        LDA   #$0A              ; REL
.ee00  85 37      sta $37                         sta   Memchr
.ee02  80 d7      bra $eddb                       bra   Asm_opcSrch
.ee04  c9 0d      cmp #$0d         Asm_srchA0     cmp   #$0d               ;  ind zp
.ee06  d0 06      bne $ee0e                       bne   Asm_srchA1
.ee08  a9 0b      lda #$0b                        LDA   #$0b              ; ind Abs
.ee0a  85 37      sta $37                         sta   Memchr
.ee0c  80 cd      bra $eddb                       bra   Asm_opcSrch
.ee0e  c9 07      cmp #$07         Asm_SrchA1     cmp   #$07              ; zp,y
.ee10  d0 af      bne $edc1                       bne   Asm_Err1          ; no more modes to try, bad mode err
.ee12  a9 09      lda #$09                        LDA   #$09              ; ABS,y
.ee14  85 37      sta $37                         sta   Memchr
.ee16  80 c3      bra $eddb                       bra   Asm_opcSrch
.ee18  a5 37      lda $37          Asm_OpcFnd     lda   Memchr
.ee1a  29 0f      and #$0f                        and   #$0F              ; mask out psuedo modes
.ee1c  85 37      sta $37                         sta   Memchr            ;
.ee1e  c9 0e      cmp #$0e                        CMP   #$0E              ; BBR mode?
.ee20  d0 0b      bne $ee2d                       bne   Asm_opcFnd0       ;
.ee22  20 6c ee   jsr $ee6c                       jsr   Asm_BRelCalc      ;
.ee25  85 3d      sta $3d                         sta   HexDigits_H       ;
.ee27  a5 38      lda $38                         lda   Startaddr         ;
.ee29  85 3c      sta $3c                         sta   Hexdigits         ;
.ee2b  80 07      bra $ee34                       bra   Asm_OpcFnd1       ;   
.ee2d  c9 0a      cmp #$0a         Asm_OpcFnd0    cmp   #$0A              ; is Rel Mode?
.ee2f  d0 03      bne $ee34                       bne   Asm_OpcFnd1 
.ee31  20 84 ee   jsr $ee84                       jsr   Asm_RelCalc       ; adjust rel address
.ee34  a0 00      ldy #$00         Asm_OpcFnd1    ldy   #$00
.ee36  8a         txa                             txa
.ee37  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ee39  c8         iny                             iny
.ee3a  a6 37      ldx $37                         ldx   Memchr            ; 
.ee3c  bd 69 f1   lda $f169,x                     lda   ModeByteCnt,x
.ee3f  48         pha                             PHA                     ; Save # of bytes
.ee40  c9 01      cmp #$01                        cmp   #$01
.ee42  f0 10      beq $ee54                       beq   Asm_EchoL
.ee44  a5 3c      lda $3c                         lda   HexDigits
.ee46  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ee48  c8         iny                             iny
.ee49  bd 69 f1   lda $f169,x                     lda   ModeByteCnt,x
.ee4c  c9 02      cmp #$02                        cmp   #$02
.ee4e  f0 04      beq $ee54                       beq   Asm_EchoL
.ee50  a5 3d      lda $3d                         lda   HexDigits+1
.ee52  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ee54  a5 3a      lda $3a          Asm_EchoL      lda   AddrPtr
.ee56  85 38      sta $38                         sta   StartAddr
.ee58  a5 3b      lda $3b                         lda   AddrPtr+1
.ee5a  85 39      sta $39                         sta   StartAddr+1
.ee5c  20 8b ea   jsr $ea8b                       jsr   List_One
.ee5f  18         clc              Asm_Save       clc
.ee60  68         pla                             PLA
.ee61  65 3a      adc $3a                         adc   AddrPtr
.ee63  85 3a      sta $3a                         sta   AddrPtr
.ee65  90 02      bcc $ee69                       bcc   Asm_done
.ee67  e6 3b      inc $3b                         inc   AddrPtr+1
.ee69  4c 05 ec   jmp $ec05        Asm_done       jmp   Assembler
.ee6c  20 73 ee   jsr $ee73        Asm_BRelCalc   jsr   Asm_relsub
.ee6f  e9 03      sbc #$03                        sbc   #$03
.ee71  80 16      bra $ee89                       bra   Asm_RelC1
.ee73  38         sec              Asm_RelSub     sec
.ee74  a5 3c      lda $3c                         lda   Hexdigits
.ee76  e5 3a      sbc $3a                         sbc   AddrPtr
.ee78  85 3e      sta $3e                         sta   Memptr
.ee7a  a5 3d      lda $3d                         lda   Hexdigits+1
.ee7c  e5 3b      sbc $3b                         sbc   AddrPtr+1
.ee7e  85 3f      sta $3f                         sta   Memptr+1
.ee80  38         sec                             sec
.ee81  a5 3e      lda $3e                         lda   Memptr
.ee83  60         rts                             rts 
.ee84  20 73 ee   jsr $ee73        Asm_RelCalc    jsr   Asm_relsub
.ee87  e9 02      sbc #$02                        sbc   #$02
.ee89  85 3e      sta $3e          Asm_Relc1      sta   Memptr
.ee8b  b0 02      bcs $ee8f                       bcs   Asm_relC2
.ee8d  c6 3f      dec $3f                         dec   Memptr+1
.ee8f  a5 3f      lda $3f          Asm_relC2      lda   Memptr+1               
.ee91  f0 0b      beq $ee9e                       beq   Asm_relC4         ; positive
.ee93  c9 ff      cmp #$ff                        cmp   #$FF              ; negative
.ee95  d0 0b      bne $eea2                       bne   Asm_txtErr
.ee97  a5 3e      lda $3e                         lda   Memptr
.ee99  10 07      bpl $eea2                       bpl   Asm_txtErr
.ee9b  85 3c      sta $3c          Asm_relC3      sta   HexDigits
.ee9d  60         rts                             rts
.ee9e  a5 3e      lda $3e          Asm_relC4      lda   Memptr
.eea0  10 f9      bpl $ee9b                       bpl   Asm_relC3
.eea2  4c 41 ec   jmp $ec41        Asm_txtErr     jmp   Asm_Err
.eea5  fa         plx              Asm_txt        plx                      ; process the .ds pseudo-opcode
.eea6  88         dey                             dey
.eea7  98         tya                             tya
.eea8  aa         tax                             tax
.eea9  a0 fe      ldy #$fe                        ldy   #$fe
.eeab  c8         iny              Asm_txt1       iny
.eeac  bd 00 03   lda $0300,x      Asm_txt2       lda   buffer,x           ; get next operand char
.eeaf  e8         inx                             inx                      ; point to next operand chr
.eeb0  c9 0d      cmp #$0d                        cmp   #$0d             ;  CR
.eeb2  f0 1a      beq $eece                       beq   Asm_txt9
.eeb4  c9 27      cmp #$27                        cmp   #$27             ; "
.eeb6  d0 06      bne $eebe                       bne   Asm_txt3
.eeb8  c0 ff      cpy #$ff                        cpy   #$ff             ; opening " found?
.eeba  d0 12      bne $eece                       bne   Asm_txt9         ; no, closing, so done
.eebc  80 ed      bra $eeab                       bra   Asm_txt1         ; yes, get first text chr
.eebe  c0 ff      cpy #$ff         Asm_txt3       cpy   #$ff             ; already found opening "?
.eec0  f0 04      beq $eec6                       beq   Asm_txt4         ; 
.eec2  91 3a      sta ($3a),y                     sta   (AddrPtr),y      ; yes, save chr
.eec4  80 e5      bra $eeab                       bra   Asm_txt1
.eec6  c9 20      cmp #$20         Asm_txt4       cmp   #$20             ; no, if not a space, then err
.eec8  f0 e2      beq $eeac                       beq   Asm_txt2
.eeca  8a         txa                             txa
.eecb  a8         tay                             tay
.eecc  80 d4      bra $eea2                       bra   Asm_txtErr
.eece  98         tya              Asm_txt9       tya
.eecf  48         pha                             pha
.eed0  4c 5f ee   jmp $ee5f                       jmp   Asm_save
.eed3  a0 49      ldy #$49         Opcode_List    ldy   #$49              ; Number of Opcodes (64)
.eed5  a2 00      ldx #$00                        ldx   #$00              ; pointer to characters
.eed7  8a         txa              Opcode_List1   txa                     ; 
.eed8  29 0f      and #$0f                        and   #$0F              ; Print CR after each 16 opcodes 
.eeda  d0 03      bne $eedf                       bne   Opcode_List2      ; not divisible by 16
.eedc  20 5e e7   jsr $e75e                       jsr   Print_CR          ;
.eedf  bd a9 f1   lda $f1a9,x      Opcode_List2   lda   OPCtxtData,x      ; get opcode chr data
.eee2  20 0d e8   jsr $e80d                       jsr   Output            ; print 1st char
.eee5  e8         inx                             inx                     ;
.eee6  bd a9 f1   lda $f1a9,x                     lda   OPCtxtData,x      ; 
.eee9  20 0d e8   jsr $e80d                       jsr   Output            ; print 2nd char
.eeec  e8         inx                             inx                     ;
.eeed  bd a9 f1   lda $f1a9,x                     lda   OPCtxtData,x      ;
.eef0  20 0d e8   jsr $e80d                       jsr   Output            ; print 3rd char
.eef3  e8         inx                             inx                     ;
.eef4  c0 08      cpy #$08                        cpy   #$08              ; 
.eef6  10 09      bpl $ef01                       bpl   Opcode_List3      ; not 4 byte code
.eef8  c0 04      cpy #$04                        cpy   #$04              ;
.eefa  30 05      bmi $ef01                       bmi   Opcode_list3      ;
.eefc  a9 78      lda #$78                        lda   #$78              ; add 'x'
.eefe  20 0d e8   jsr $e80d                       jsr   output            ; for RMBx, SMBx,BBRx, & BBSx
.ef01  a9 20      lda #$20         Opcode_List3   lda   #$20              ; print space
.ef03  20 0d e8   jsr $e80d                       jsr   Output            ;
.ef06  88         dey                             dey                     ;
.ef07  d0 ce      bne $eed7                       bne   Opcode_List1      ; 
.ef09  20 5e e7   jsr $e75e                       jsr   Print_CR          ; one last CR-LF
.ef0c  60         rts                             rts                     ;

>ef0d  30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46  Hexdigdata     .byte "0123456789ABCDEF";hex char table 
>ef1d  0d                          CmdAscii       .byte $0D               ; 0 enter    cmd codes
>ef1e  20                                         .byte $20               ; 1 SPACE
>ef1f  2e                                         .byte $2E               ; 2 .
>ef20  3a                                         .byte $3A               ; 3 :
>ef21  3e                                         .byte $3E               ; 4 >  
>ef22  3f                                         .byte $3f               ; 5 ? - Help
>ef23  21                                         .byte $21               ; 6 ! - Assembler
>ef24  24                          	       .byte $24	       ; 7 $ - DOS command interpreter
>ef25  47                                         .byte $47               ; 8 g - Go
>ef26  49                                         .byte $49               ; 9 i - Insert
>ef27  4c                                         .byte $4C               ; A l - List
>ef28  4d                                         .byte $4D               ; B m - Move
>ef29  51                                         .byte $51               ; C q - Query memory (text dump)
>ef2a  52                                         .byte $52               ; D r - Registers
>ef2b  40                                         .byte $40               ; E @ - Cold Start Basic
>ef2c  23                                         .byte $23               ; F # - Warm Start Basic
>ef2d  55                                         .byte $55               ;10 U - Xmodem/IntelHEX uploader   
>ef2e  56                                         .byte $56               ;11 v - Version
>ef2f  57                                         .byte $57               ;12 w - "(W)rite" eeprom
>ef30  f0 e8                       Cmdjmptbl      .word CR_cmd            ; 0  enter   cmd jmp table
>ef32  00 e9                                      .word SP_cmd            ; 1   space
>ef34  e5 e8                                      .word DOT_cmd           ; 2    .
>ef36  e5 e8                                      .word DOT_cmd           ; 3    :
>ef38  2b ea                                      .word Dest_cmd          ; 4    >  
>ef3a  aa e8                                      .word Help_Cmd          ; 5    ?
>ef3c  d7 eb                                      .word Assem_init        ; 6    !
>ef3e  ff df                                      .word Dos_Init	       ; 7    $
>ef40  d9 e8                                      .word Excute_cmd        ; 8    g
>ef42  81 e9                                      .word Insert_Cmd        ; 9    i
>ef44  34 ea                                      .word LIST_cmd          ; A    l
>ef46  c4 e9                                      .word Move_cmd          ; B    m
>ef48  5f e9                                      .word TXT_cmd           ; C    q
>ef4a  27 e7                                      .word Printreg          ; D    r
>ef4c  00 a3                                      .word LAB_COLD	       ; E    @ $A300
>ef4e  00 00                                      .word $0000             ; F    #
>ef50  00 fc                                      .word Xmodem	       ;10    U
>ef52  c8 e8                                      .word Version           ;11    v
>ef54  f3 e9                                      .word EEPROM_WR         ;12    w  
>ef56  00                          Cmdseccode     .byte $00               ; 0   enter       secondary command table
>ef57  ff                                         .byte $FF               ; 1   sp
>ef58  01                                         .byte $01               ; 2   .
>ef59  02                                         .byte $02               ; 3   :
>ef5a  00                                         .byte $00               ; 4   > 
>ef5b  00                                         .byte $00               ; 5   ?
>ef5c  00                                         .byte $00               ; 6   !
>ef5d  00                          		.byte $00	       ; 7   $
>ef5e  00                                         .byte $00               ; 8   g
>ef5f  00                                         .byte $00               ; 9   i
>ef60  00                                         .byte $00               ; A   l
>ef61  00                                         .byte $00               ; B   m
>ef62  00                                         .byte $00               ; C   q
>ef63  00                                         .byte $00               ; D   r
>ef64  00                                         .byte $00               ; E   @
>ef65  00                                         .byte $00               ; F   #
>ef66  00                                         .byte $00               ;10   U
>ef67  00                                         .byte $00               ;11   V
>ef68  00                                         .byte $00               ;12   W
>ef69  0b                          OPCtxtidx      .byte $0B               ;0   operand text index
>ef6a  23                                         .byte $23               ;1
>ef6b  49                                         .byte $49               ;2
>ef6c  49                                         .byte $49               ;3
>ef6d  3b                                         .byte $3B               ;4
>ef6e  23                                         .byte $23               ;5
>ef6f  02                                         .byte $02               ;6
>ef70  44                                         .byte $44               ;7
>ef71  25                                         .byte $25               ;8
>ef72  23                                         .byte $23               ;9
>ef73  02                                         .byte $02               ;A
>ef74  49                                         .byte $49               ;B
>ef75  3b                                         .byte $3B               ;C
>ef76  23                                         .byte $23               ;D
>ef77  02                                         .byte $02               ;E
>ef78  42                                         .byte $42               ;F
>ef79  09                                         .byte $09               ;10
>ef7a  23                                         .byte $23               ;11
>ef7b  23                                         .byte $23               ;12
>ef7c  49                                         .byte $49               ;13
>ef7d  3a                                         .byte $3A               ;14
>ef7e  23                                         .byte $23               ;15
>ef7f  02                                         .byte $02               ;16
>ef80  44                                         .byte $44               ;17
>ef81  0e                                         .byte $0E               ;18
>ef82  23                                         .byte $23               ;19
>ef83  19                                         .byte $19               ;1A
>ef84  49                                         .byte $49               ;1B
>ef85  3a                                         .byte $3A               ;1C
>ef86  23                                         .byte $23               ;1D
>ef87  02                                         .byte $02               ;1E
>ef88  42                                         .byte $42               ;1F
>ef89  1d                                         .byte $1D               ;20
>ef8a  01                                         .byte $01               ;21
>ef8b  49                                         .byte $49               ;22
>ef8c  49                                         .byte $49               ;23
>ef8d  06                                         .byte $06               ;24
>ef8e  01                                         .byte $01               ;25
>ef8f  2c                                         .byte $2C               ;26
>ef90  44                                         .byte $44               ;27
>ef91  29                                         .byte $29               ;28
>ef92  01                                         .byte $01               ;29
>ef93  2c                                         .byte $2C               ;2A
>ef94  49                                         .byte $49               ;2B
>ef95  06                                         .byte $06               ;2C
>ef96  01                                         .byte $01               ;2D
>ef97  2c                                         .byte $2C               ;2E
>ef98  42                                         .byte $42               ;2F
>ef99  07                                         .byte $07               ;30
>ef9a  01                                         .byte $01               ;31
>ef9b  01                                         .byte $01               ;32
>ef9c  49                                         .byte $49               ;33
>ef9d  06                                         .byte $06               ;34
>ef9e  01                                         .byte $01               ;35
>ef9f  2c                                         .byte $2C               ;36
>efa0  44                                         .byte $44               ;37
>efa1  31                                         .byte $31               ;38
>efa2  01                                         .byte $01               ;39
>efa3  15                                         .byte $15               ;3A
>efa4  49                                         .byte $49               ;3B
>efa5  06                                         .byte $06               ;3C
>efa6  01                                         .byte $01               ;3D
>efa7  2c                                         .byte $2C               ;3E
>efa8  42                                         .byte $42               ;3F
>efa9  2e                                         .byte $2E               ;40
>efaa  18                                         .byte $18               ;41
>efab  49                                         .byte $49               ;42
>efac  49                                         .byte $49               ;43
>efad  49                                         .byte $49               ;44
>efae  18                                         .byte $18               ;45
>efaf  21                                         .byte $21               ;46
>efb0  44                                         .byte $44               ;47
>efb1  24                                         .byte $24               ;48
>efb2  18                                         .byte $18               ;49
>efb3  21                                         .byte $21               ;4A
>efb4  49                                         .byte $49               ;4B
>efb5  1c                                         .byte $1C               ;4C
>efb6  18                                         .byte $18               ;4D
>efb7  21                                         .byte $21               ;4E
>efb8  42                                         .byte $42               ;4F
>efb9  0c                                         .byte $0C               ;50
>efba  18                                         .byte $18               ;51
>efbb  18                                         .byte $18               ;52
>efbc  49                                         .byte $49               ;53
>efbd  49                                         .byte $49               ;54
>efbe  18                                         .byte $18               ;55
>efbf  21                                         .byte $21               ;56
>efc0  44                                         .byte $44               ;57
>efc1  10                                         .byte $10               ;58
>efc2  18                                         .byte $18               ;59
>efc3  27                                         .byte $27               ;5A
>efc4  49                                         .byte $49               ;5B
>efc5  49                                         .byte $49               ;5C
>efc6  18                                         .byte $18               ;5D
>efc7  21                                         .byte $21               ;5E
>efc8  42                                         .byte $42               ;5F
>efc9  2f                                         .byte $2F               ;60
>efca  00                                         .byte $00               ;61
>efcb  49                                         .byte $49               ;62
>efcc  49                                         .byte $49               ;63
>efcd  37                                         .byte $37               ;64
>efce  00                                         .byte $00               ;65
>efcf  2d                                         .byte $2D               ;66
>efd0  44                                         .byte $44               ;67
>efd1  28                                         .byte $28               ;68
>efd2  00                                         .byte $00               ;69
>efd3  2d                                         .byte $2D               ;6A
>efd4  49                                         .byte $49               ;6B
>efd5  1c                                         .byte $1C               ;6C
>efd6  00                                         .byte $00               ;6D
>efd7  2d                                         .byte $2D               ;6E
>efd8  42                                         .byte $42               ;6F
>efd9  0d                                         .byte $0D               ;70
>efda  00                                         .byte $00               ;71
>efdb  00                                         .byte $00               ;72
>efdc  49                                         .byte $49               ;73
>efdd  37                                         .byte $37               ;74
>efde  00                                         .byte $00               ;75
>efdf  2d                                         .byte $2D               ;76
>efe0  44                                         .byte $44               ;77
>efe1  33                                         .byte $33               ;78
>efe2  00                                         .byte $00               ;79
>efe3  2b                                         .byte $2B               ;7A
>efe4  49                                         .byte $49               ;7B
>efe5  1c                                         .byte $1C               ;7C
>efe6  00                                         .byte $00               ;7D
>efe7  2d                                         .byte $2D               ;7E
>efe8  42                                         .byte $42               ;7F
>efe9  0a                                         .byte $0A               ;80
>efea  34                                         .byte $34               ;81
>efeb  49                                         .byte $49               ;82
>efec  49                                         .byte $49               ;83
>efed  36                                         .byte $36               ;84
>efee  34                                         .byte $34               ;85
>efef  35                                         .byte $35               ;86
>eff0  45                                         .byte $45               ;87
>eff1  17                                         .byte $17               ;88
>eff2  06                                         .byte $06               ;89
>eff3  3d                                         .byte $3D               ;8A
>eff4  49                                         .byte $49               ;8B
>eff5  36                                         .byte $36               ;8C
>eff6  34                                         .byte $34               ;8D
>eff7  35                                         .byte $35               ;8E
>eff8  43                                         .byte $43               ;8F
>eff9  03                                         .byte $03               ;90
>effa  34                                         .byte $34               ;91
>effb  34                                         .byte $34               ;92
>effc  49                                         .byte $49               ;93
>effd  36                                         .byte $36               ;94
>effe  34                                         .byte $34               ;95
>efff  35                                         .byte $35               ;96
>f000  45                                         .byte $45               ;97
>f001  3f                                         .byte $3F               ;98
>f002  34                                         .byte $34               ;99
>f003  3e                                         .byte $3E               ;9A
>f004  49                                         .byte $49               ;9B
>f005  37                                         .byte $37               ;9C
>f006  34                                         .byte $34               ;9D
>f007  37                                         .byte $37               ;9E
>f008  43                                         .byte $43               ;9F
>f009  20                                         .byte $20               ;A0
>f00a  1e                                         .byte $1E               ;A1
>f00b  1f                                         .byte $1F               ;A2
>f00c  49                                         .byte $49               ;A3
>f00d  20                                         .byte $20               ;A4
>f00e  1e                                         .byte $1E               ;A5
>f00f  1f                                         .byte $1F               ;A6
>f010  45                                         .byte $45               ;A7
>f011  39                                         .byte $39               ;A8
>f012  1e                                         .byte $1E               ;A9
>f013  38                                         .byte $38               ;AA
>f014  49                                         .byte $49               ;AB
>f015  20                                         .byte $20               ;AC
>f016  1e                                         .byte $1E               ;AD
>f017  1f                                         .byte $1F               ;AE
>f018  43                                         .byte $43               ;AF
>f019  04                                         .byte $04               ;B0
>f01a  1e                                         .byte $1E               ;B1
>f01b  1e                                         .byte $1E               ;B2
>f01c  49                                         .byte $49               ;B3
>f01d  20                                         .byte $20               ;B4
>f01e  1e                                         .byte $1E               ;B5
>f01f  1f                                         .byte $1F               ;B6
>f020  45                                         .byte $45               ;B7
>f021  11                                         .byte $11               ;B8
>f022  1e                                         .byte $1E               ;B9
>f023  3c                                         .byte $3C               ;BA
>f024  49                                         .byte $49               ;BB
>f025  20                                         .byte $20               ;BC
>f026  1e                                         .byte $1E               ;BD
>f027  1f                                         .byte $1F               ;BE
>f028  43                                         .byte $43               ;BF
>f029  14                                         .byte $14               ;C0
>f02a  12                                         .byte $12               ;C1
>f02b  49                                         .byte $49               ;C2
>f02c  49                                         .byte $49               ;C3
>f02d  14                                         .byte $14               ;C4
>f02e  12                                         .byte $12               ;C5
>f02f  15                                         .byte $15               ;C6
>f030  45                                         .byte $45               ;C7
>f031  1b                                         .byte $1B               ;C8
>f032  12                                         .byte $12               ;C9
>f033  16                                         .byte $16               ;CA
>f034  40                                         .byte $40               ;CB
>f035  14                                         .byte $14               ;CC
>f036  12                                         .byte $12               ;CD
>f037  15                                         .byte $15               ;CE
>f038  43                                         .byte $43               ;CF
>f039  08                                         .byte $08               ;D0
>f03a  12                                         .byte $12               ;D1
>f03b  12                                         .byte $12               ;D2
>f03c  49                                         .byte $49               ;D3
>f03d  49                                         .byte $49               ;D4
>f03e  12                                         .byte $12               ;D5
>f03f  15                                         .byte $15               ;D6
>f040  45                                         .byte $45               ;D7
>f041  0f                                         .byte $0F               ;D8
>f042  12                                         .byte $12               ;D9
>f043  26                                         .byte $26               ;DA
>f044  41                                         .byte $41               ;DB
>f045  49                                         .byte $49               ;DC
>f046  12                                         .byte $12               ;DD
>f047  15                                         .byte $15               ;DE
>f048  43                                         .byte $43               ;DF
>f049  13                                         .byte $13               ;E0
>f04a  30                                         .byte $30               ;E1
>f04b  49                                         .byte $49               ;E2
>f04c  49                                         .byte $49               ;E3
>f04d  13                                         .byte $13               ;E4
>f04e  30                                         .byte $30               ;E5
>f04f  19                                         .byte $19               ;E6
>f050  45                                         .byte $45               ;E7
>f051  1a                                         .byte $1A               ;E8
>f052  30                                         .byte $30               ;E9
>f053  22                                         .byte $22               ;EA
>f054  49                                         .byte $49               ;EB
>f055  13                                         .byte $13               ;EC
>f056  30                                         .byte $30               ;ED
>f057  19                                         .byte $19               ;EE
>f058  43                                         .byte $43               ;EF
>f059  05                                         .byte $05               ;F0
>f05a  30                                         .byte $30               ;F1
>f05b  30                                         .byte $30               ;F2
>f05c  49                                         .byte $49               ;F3
>f05d  49                                         .byte $49               ;F4
>f05e  30                                         .byte $30               ;F5
>f05f  19                                         .byte $19               ;F6
>f060  45                                         .byte $45               ;F7
>f061  32                                         .byte $32               ;F8
>f062  30                                         .byte $30               ;F9
>f063  2a                                         .byte $2A               ;FA
>f064  49                                         .byte $49               ;FB
>f065  49                                         .byte $49               ;FC
>f066  30                                         .byte $30               ;FD
>f067  19                                         .byte $19               ;FE
>f068  43                                         .byte $43               ;FF
>f069  03                          OPCaddmode     .byte $03               ;0   opcode address mode
>f06a  04                                         .byte $04               ;1
>f06b  03                                         .byte $03               ;2
>f06c  03                                         .byte $03               ;3
>f06d  02                                         .byte $02               ;4
>f06e  02                                         .byte $02               ;5
>f06f  02                                         .byte $02               ;6
>f070  0f                                         .byte $0F               ;7
>f071  03                                         .byte $03               ;8
>f072  00                                         .byte $00               ;9
>f073  03                                         .byte $03               ;A
>f074  03                                         .byte $03               ;B
>f075  01                                         .byte $01               ;C
>f076  01                                         .byte $01               ;D
>f077  01                                         .byte $01               ;E
>f078  0e                                         .byte $0E               ;F
>f079  0a                                         .byte $0A               ;10
>f07a  05                                         .byte $05               ;11
>f07b  0d                                         .byte $0D               ;12
>f07c  03                                         .byte $03               ;13
>f07d  02                                         .byte $02               ;14
>f07e  06                                         .byte $06               ;15
>f07f  06                                         .byte $06               ;16
>f080  1f                                         .byte $1F               ;17
>f081  03                                         .byte $03               ;18
>f082  09                                         .byte $09               ;19
>f083  03                                         .byte $03               ;1A
>f084  03                                         .byte $03               ;1B
>f085  01                                         .byte $01               ;1C
>f086  08                                         .byte $08               ;1D
>f087  08                                         .byte $08               ;1E
>f088  1e                                         .byte $1E               ;1F
>f089  01                                         .byte $01               ;20
>f08a  04                                         .byte $04               ;21
>f08b  03                                         .byte $03               ;22
>f08c  03                                         .byte $03               ;23
>f08d  02                                         .byte $02               ;24
>f08e  02                                         .byte $02               ;25
>f08f  02                                         .byte $02               ;26
>f090  2f                                         .byte $2F               ;27
>f091  03                                         .byte $03               ;28
>f092  00                                         .byte $00               ;29
>f093  03                                         .byte $03               ;2A
>f094  03                                         .byte $03               ;2B
>f095  01                                         .byte $01               ;2C
>f096  01                                         .byte $01               ;2D
>f097  01                                         .byte $01               ;2E
>f098  2e                                         .byte $2E               ;2F
>f099  0a                                         .byte $0A               ;30
>f09a  05                                         .byte $05               ;31
>f09b  0d                                         .byte $0D               ;32
>f09c  03                                         .byte $03               ;33
>f09d  06                                         .byte $06               ;34
>f09e  06                                         .byte $06               ;35
>f09f  06                                         .byte $06               ;36
>f0a0  3f                                         .byte $3F               ;37
>f0a1  03                                         .byte $03               ;38
>f0a2  09                                         .byte $09               ;39
>f0a3  03                                         .byte $03               ;3A
>f0a4  03                                         .byte $03               ;3B
>f0a5  08                                         .byte $08               ;3C
>f0a6  08                                         .byte $08               ;3D
>f0a7  08                                         .byte $08               ;3E
>f0a8  3e                                         .byte $3E               ;3F
>f0a9  03                                         .byte $03               ;40
>f0aa  04                                         .byte $04               ;41
>f0ab  03                                         .byte $03               ;42
>f0ac  03                                         .byte $03               ;43
>f0ad  03                                         .byte $03               ;44
>f0ae  02                                         .byte $02               ;45
>f0af  02                                         .byte $02               ;46
>f0b0  4f                                         .byte $4F               ;47
>f0b1  03                                         .byte $03               ;48
>f0b2  00                                         .byte $00               ;49
>f0b3  03                                         .byte $03               ;4A
>f0b4  03                                         .byte $03               ;4B
>f0b5  01                                         .byte $01               ;4C
>f0b6  01                                         .byte $01               ;4D
>f0b7  01                                         .byte $01               ;4E
>f0b8  4e                                         .byte $4E               ;4F
>f0b9  0a                                         .byte $0A               ;50
>f0ba  05                                         .byte $05               ;51
>f0bb  0d                                         .byte $0D               ;52
>f0bc  03                                         .byte $03               ;53
>f0bd  03                                         .byte $03               ;54
>f0be  06                                         .byte $06               ;55
>f0bf  06                                         .byte $06               ;56
>f0c0  5f                                         .byte $5F               ;57
>f0c1  03                                         .byte $03               ;58
>f0c2  09                                         .byte $09               ;59
>f0c3  03                                         .byte $03               ;5A
>f0c4  03                                         .byte $03               ;5B
>f0c5  03                                         .byte $03               ;5C
>f0c6  08                                         .byte $08               ;5D
>f0c7  08                                         .byte $08               ;5E
>f0c8  5e                                         .byte $5E               ;5F
>f0c9  03                                         .byte $03               ;60
>f0ca  04                                         .byte $04               ;61
>f0cb  03                                         .byte $03               ;62
>f0cc  03                                         .byte $03               ;63
>f0cd  02                                         .byte $02               ;64
>f0ce  02                                         .byte $02               ;65
>f0cf  02                                         .byte $02               ;66
>f0d0  6f                                         .byte $6F               ;67
>f0d1  03                                         .byte $03               ;68
>f0d2  00                                         .byte $00               ;69
>f0d3  03                                         .byte $03               ;6A
>f0d4  03                                         .byte $03               ;6B
>f0d5  0b                                         .byte $0B               ;6C
>f0d6  01                                         .byte $01               ;6D
>f0d7  01                                         .byte $01               ;6E
>f0d8  6e                                         .byte $6E               ;6F
>f0d9  0a                                         .byte $0A               ;70
>f0da  05                                         .byte $05               ;71
>f0db  0d                                         .byte $0D               ;72
>f0dc  03                                         .byte $03               ;73
>f0dd  06                                         .byte $06               ;74
>f0de  06                                         .byte $06               ;75
>f0df  06                                         .byte $06               ;76
>f0e0  7f                                         .byte $7F               ;77
>f0e1  03                                         .byte $03               ;78
>f0e2  09                                         .byte $09               ;79
>f0e3  03                                         .byte $03               ;7A
>f0e4  03                                         .byte $03               ;7B
>f0e5  0c                                         .byte $0C               ;7C
>f0e6  08                                         .byte $08               ;7D
>f0e7  08                                         .byte $08               ;7E
>f0e8  7e                                         .byte $7E               ;7F
>f0e9  0a                                         .byte $0A               ;80
>f0ea  04                                         .byte $04               ;81
>f0eb  03                                         .byte $03               ;82
>f0ec  03                                         .byte $03               ;83
>f0ed  02                                         .byte $02               ;84
>f0ee  02                                         .byte $02               ;85
>f0ef  02                                         .byte $02               ;86
>f0f0  0f                                         .byte $0F               ;87
>f0f1  03                                         .byte $03               ;88
>f0f2  00                                         .byte $00               ;89
>f0f3  03                                         .byte $03               ;8A
>f0f4  03                                         .byte $03               ;8B
>f0f5  01                                         .byte $01               ;8C
>f0f6  01                                         .byte $01               ;8D
>f0f7  01                                         .byte $01               ;8E
>f0f8  0e                                         .byte $0E               ;8F
>f0f9  0a                                         .byte $0A               ;90
>f0fa  05                                         .byte $05               ;91
>f0fb  0d                                         .byte $0D               ;92
>f0fc  03                                         .byte $03               ;93
>f0fd  06                                         .byte $06               ;94
>f0fe  06                                         .byte $06               ;95
>f0ff  07                                         .byte $07               ;96
>f100  1f                                         .byte $1F               ;97
>f101  03                                         .byte $03               ;98
>f102  09                                         .byte $09               ;99
>f103  03                                         .byte $03               ;9A
>f104  03                                         .byte $03               ;9B
>f105  01                                         .byte $01               ;9C
>f106  08                                         .byte $08               ;9D
>f107  08                                         .byte $08               ;9E
>f108  1e                                         .byte $1E               ;9F
>f109  00                                         .byte $00               ;A0
>f10a  04                                         .byte $04               ;A1    changed from 0d to 04
>f10b  00                                         .byte $00               ;A2
>f10c  03                                         .byte $03               ;A3
>f10d  02                                         .byte $02               ;A4
>f10e  02                                         .byte $02               ;A5
>f10f  02                                         .byte $02               ;A6
>f110  2f                                         .byte $2F               ;A7
>f111  03                                         .byte $03               ;A8
>f112  00                                         .byte $00               ;A9
>f113  03                                         .byte $03               ;AA
>f114  03                                         .byte $03               ;AB
>f115  01                                         .byte $01               ;AC
>f116  01                                         .byte $01               ;AD
>f117  01                                         .byte $01               ;AE
>f118  2e                                         .byte $2E               ;AF
>f119  0a                                         .byte $0A               ;B0
>f11a  05                                         .byte $05               ;B1
>f11b  0d                                         .byte $0D               ;B2     
>f11c  03                                         .byte $03               ;B3
>f11d  06                                         .byte $06               ;B4
>f11e  06                                         .byte $06               ;B5
>f11f  07                                         .byte $07               ;B6
>f120  3f                                         .byte $3F               ;B7
>f121  03                                         .byte $03               ;B8
>f122  09                                         .byte $09               ;B9
>f123  03                                         .byte $03               ;BA
>f124  03                                         .byte $03               ;BB
>f125  08                                         .byte $08               ;BC
>f126  08                                         .byte $08               ;BD
>f127  09                                         .byte $09               ;BE
>f128  3e                                         .byte $3E               ;BF
>f129  00                                         .byte $00               ;C0
>f12a  04                                         .byte $04               ;C1
>f12b  03                                         .byte $03               ;C2
>f12c  03                                         .byte $03               ;C3
>f12d  02                                         .byte $02               ;C4
>f12e  02                                         .byte $02               ;C5
>f12f  02                                         .byte $02               ;C6
>f130  4f                                         .byte $4F               ;C7
>f131  03                                         .byte $03               ;C8
>f132  00                                         .byte $00               ;C9
>f133  03                                         .byte $03               ;CA
>f134  03                                         .byte $03               ;CB
>f135  01                                         .byte $01               ;CC
>f136  01                                         .byte $01               ;CD
>f137  01                                         .byte $01               ;CE
>f138  4e                                         .byte $4E               ;CF
>f139  0a                                         .byte $0A               ;D0
>f13a  05                                         .byte $05               ;D1
>f13b  0d                                         .byte $0D               ;D2
>f13c  03                                         .byte $03               ;D3
>f13d  03                                         .byte $03               ;D4
>f13e  06                                         .byte $06               ;D5
>f13f  06                                         .byte $06               ;D6
>f140  5f                                         .byte $5F               ;D7
>f141  03                                         .byte $03               ;D8
>f142  09                                         .byte $09               ;D9
>f143  03                                         .byte $03               ;DA
>f144  03                                         .byte $03               ;DB
>f145  03                                         .byte $03               ;DC
>f146  08                                         .byte $08               ;DD
>f147  08                                         .byte $08               ;DE
>f148  5e                                         .byte $5E               ;DF
>f149  00                                         .byte $00               ;E0
>f14a  04                                         .byte $04               ;E1
>f14b  03                                         .byte $03               ;E2
>f14c  03                                         .byte $03               ;E3
>f14d  02                                         .byte $02               ;E4
>f14e  02                                         .byte $02               ;E5
>f14f  02                                         .byte $02               ;E6
>f150  6f                                         .byte $6F               ;E7
>f151  03                                         .byte $03               ;E8
>f152  00                                         .byte $00               ;E9
>f153  03                                         .byte $03               ;EA
>f154  03                                         .byte $03               ;EB
>f155  01                                         .byte $01               ;EC
>f156  01                                         .byte $01               ;ED
>f157  01                                         .byte $01               ;EE
>f158  6e                                         .byte $6E               ;EF
>f159  0a                                         .byte $0A               ;F0
>f15a  05                                         .byte $05               ;F1
>f15b  0d                                         .byte $0D               ;F2
>f15c  03                                         .byte $03               ;F3
>f15d  03                                         .byte $03               ;F4
>f15e  06                                         .byte $06               ;F5
>f15f  06                                         .byte $06               ;F6
>f160  7f                                         .byte $7F               ;F7
>f161  03                                         .byte $03               ;F8
>f162  09                                         .byte $09               ;F9
>f163  03                                         .byte $03               ;FA
>f164  03                                         .byte $03               ;FB
>f165  03                                         .byte $03               ;FC
>f166  08                                         .byte $08               ;FD
>f167  08                                         .byte $08               ;FE
>f168  7e                                         .byte $7E               ;FF
>f169  02                          ModeByteCnt    .byte $02               ;0  opcode mode byte count
>f16a  03                                         .byte $03               ;1
>f16b  02                                         .byte $02               ;2
>f16c  01                                         .byte $01               ;3
>f16d  02                                         .byte $02               ;4
>f16e  02                                         .byte $02               ;5
>f16f  02                                         .byte $02               ;6
>f170  02                                         .byte $02               ;7
>f171  03                                         .byte $03               ;8
>f172  03                                         .byte $03               ;9
>f173  02                                         .byte $02               ;A
>f174  03                                         .byte $03               ;B
>f175  03                                         .byte $03               ;C
>f176  02                                         .byte $02               ;D
>f177  03                                         .byte $03               ;E
>f178  02                                         .byte $02               ;F 
>f179  20 eb                       ModeJmpTbl     .word IMM_mode          ;0  Operand print table
>f17b  66 eb                                      .word ABS_mode          ;1
>f17d  25 eb                                      .word ZP_mode           ;2
>f17f  90 eb                                      .word IMPLIED_mode      ;3
>f181  56 eb                                      .word INDZP_X_mode      ;4
>f183  61 eb                                      .word INDZP_Y_mode      ;5
>f185  31 eb                                      .word ZP_X_mode         ;6
>f187  3e eb                                      .word ZP_Y_mode         ;7
>f189  73 eb                                      .word ABS_X_mode        ;8
>f18b  78 eb                                      .word ABS_Y_mode        ;9
>f18d  b1 eb                                      .word REL_mode          ;a
>f18f  7d eb                                      .word INDABS_mode       ;b
>f191  85 eb                                      .word INDABSX_mode      ;c
>f193  4b eb                                      .word INDZP_mode        ;d
>f195  96 eb                       		   .word BBREL_mode        ;e
>f197  25 eb                                      .word ZP_mode           ;f  dup of ZP for RMB,SMB cmds
>f199  28                          Asm_ModeLst    .byte $28               ;0 IMM_mode
>f19a  10                                         .byte $10               ;1 ABS_mode
>f19b  08                                         .byte $08               ;2 ZP_mode
>f19c  00                                         .byte $00               ;3 IMPLIED_mode
>f19d  0e                                         .byte $0E               ;4 INDZP_X_mode
>f19e  0d                                         .byte $0D               ;5 INDZP_Y_mode
>f19f  0a                                         .byte $0A               ;6 ZP_X_mode
>f1a0  09                                         .byte $09               ;7 ZP_Y_mode
>f1a1  12                                         .byte $12               ;8 ABS_X_mode
>f1a2  11                                         .byte $11               ;9 ABS_Y_mode
>f1a3  40                                         .byte $40               ;A REL_mode   Never set!!!
>f1a4  14                                         .byte $14               ;B INDABS_mode
>f1a5  16                                         .byte $16               ;C INDABSX_mode
>f1a6  0c                                         .byte $0C               ;D INDZP_mode
>f1a7  d0                                         .byte $D0               ;E BBREL_mode
>f1a8  88                                         .byte $88               ;F used for RMBx & SMBx 
>f1a9  41 44 43                    OPCtxtData     .byte "ADC"             ;0
>f1ac  41 4e 44                                   .byte "AND"             ;1
>f1af  41 53 4c                                   .byte "ASL"             ;2
>f1b2  42 43 43                                   .byte "BCC"             ;3
>f1b5  42 43 53                                   .byte "BCS"             ;4
>f1b8  42 45 51                                   .byte "BEQ"             ;5
>f1bb  42 49 54                                   .byte "BIT"             ;6
>f1be  42 4d 49                                   .byte "BMI"             ;7
>f1c1  42 4e 45                                   .byte "BNE"             ;8
>f1c4  42 50 4c                                   .byte "BPL"             ;9
>f1c7  42 52 41                                   .byte "BRA"             ;A
>f1ca  42 52 4b                                   .byte "BRK"             ;B
>f1cd  42 56 43                                   .byte "BVC"             ;C
>f1d0  42 56 53                                   .byte "BVS"             ;D
>f1d3  43 4c 43                                   .byte "CLC"             ;E
>f1d6  43 4c 44                                   .byte "CLD"             ;F
>f1d9  43 4c 49                                   .byte "CLI"             ;10
>f1dc  43 4c 56                                   .byte "CLV"             ;11
>f1df  43 4d 50                                   .byte "CMP"             ;12
>f1e2  43 50 58                                   .byte "CPX"             ;13
>f1e5  43 50 59                                   .byte "CPY"             ;14
>f1e8  44 45 43                                   .byte "DEC"             ;15
>f1eb  44 45 58                                   .byte "DEX"             ;16
>f1ee  44 45 59                                   .byte "DEY"             ;17
>f1f1  45 4f 52                                   .byte "EOR"             ;18
>f1f4  49 4e 43                                   .byte "INC"             ;19
>f1f7  49 4e 58                                   .byte "INX"             ;1A
>f1fa  49 4e 59                                   .byte "INY"             ;1B
>f1fd  4a 4d 50                                   .byte "JMP"             ;1C
>f200  4a 53 52                                   .byte "JSR"             ;1D
>f203  4c 44 41                                   .byte "LDA"             ;1E
>f206  4c 44 58                                   .byte "LDX"             ;1F
>f209  4c 44 59                                   .byte "LDY"             ;20
>f20c  4c 53 52                                   .byte "LSR"             ;21
>f20f  4e 4f 50                                   .byte "NOP"             ;22
>f212  4f 52 41                                   .byte "ORA"             ;23
>f215  50 48 41                                   .byte "PHA"             ;24
>f218  50 48 50                                   .byte "PHP"             ;25
>f21b  50 48 58                                   .byte "PHX"             ;26
>f21e  50 48 59                                   .byte "PHY"             ;27
>f221  50 4c 41                                   .byte "PLA"             ;28
>f224  50 4c 50                                   .byte "PLP"             ;29
>f227  50 4c 58                                   .byte "PLX"             ;2A
>f22a  50 4c 59                                   .byte "PLY"             ;2B
>f22d  52 4f 4c                                   .byte "ROL"             ;2C
>f230  52 4f 52                                   .byte "ROR"             ;2D
>f233  52 54 49                                   .byte "RTI"             ;2E
>f236  52 54 53                                   .byte "RTS"             ;2F
>f239  53 42 43                                   .byte "SBC"             ;30
>f23c  53 45 43                                   .byte "SEC"             ;31
>f23f  53 45 44                                   .byte "SED"             ;32
>f242  53 45 49                                   .byte "SEI"             ;33
>f245  53 54 41                                   .byte "STA"             ;34
>f248  53 54 58                                   .byte "STX"             ;35
>f24b  53 54 59                                   .byte "STY"             ;36
>f24e  53 54 5a                                   .byte "STZ"             ;37
>f251  54 41 58                                   .byte "TAX"             ;38
>f254  54 41 59                                   .byte "TAY"             ;39
>f257  54 52 42                                   .byte "TRB"             ;3A
>f25a  54 53 42                                   .byte "TSB"             ;3B
>f25d  54 53 58                                   .byte "TSX"             ;3C
>f260  54 58 41                                   .byte "TXA"             ;3D
>f263  54 58 53                                   .byte "TXS"             ;3E
>f266  54 59 41                                   .byte "TYA"             ;3F
>f269  57 41 49                                   .byte "WAI"             ;40
>f26c  53 54 50                                   .byte "STP"             ;41
>f26f  42 42 52                                   .byte "BBR"             ;42 4Byte Opcodes
>f272  42 42 53                                   .byte "BBS"             ;43
>f275  52 4d 42                                   .byte "RMB"             ;44
>f278  53 4d 42                                   .byte "SMB"             ;45
>f27b  2e 44 42                                   .byte ".DB"             ;46 define 1 byte for assembler
>f27e  2e 44 57                                   .byte ".DW"             ;47 define 1 word for assembler
>f281  2e 44 53                                   .byte ".DS"             ;48 define a string block for assembler
>f284  3f 3f 3f                                   .byte "???"             ;49 for invalid opcode
>f287  7e 43 75 72 72 65 6e 74 20 63 6f 6d 6d 61 6e 64 73 20 61 72 65 20 3a 7e  HelpTxt        .byte "~Current commands are :~"
>f29f  53 79 6e 74 61 78 20 3d 20 7b 7d 20 72 65 71 75 69 72 65 64 2c 20 5b 5d 20 6f 70 74 69 6f 6e 61 6c 2c 20 48 48 48 48 20 68 65 78 20 61 64 64 72 65 73 73 2c 20 44 44 20 68 65 78 20 64 61 74 61 7e                 .byte "Syntax = {} required, [] optional, HHHH hex address, DD hex data~"
>f2e0  7e                                         .byte "~"
>f2e1  5b 48 48 48 48 5d 5b 20 48 48 48 48 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 48 65 78 20 64 75 6d 70 20 61 64 64 72 65 73 73 28 73 29 28 75 70 20 74 6f 20 31 36 20 69 66 20 6e 6f 20 61 64 64 72 65 73 73 20 65 6e 74 65 72 65 64 29 7e                 .byte "[HHHH][ HHHH]{Return} - Hex dump address(s)(up to 16 if no address entered)~"
>f32d  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 48 65 78 20 64 75 6d 70 20 72 61 6e 67 65 20 6f 66 20 61 64 64 72 65 73 73 65 73 20 28 31 36 20 70 65 72 20 6c 69 6e 65 29 7e                 .byte "[HHHH]{.HHHH}{Return} - Hex dump range of addresses (16 per line)~"
>f36f  5b 48 48 48 48 5d 7b 3a 44 44 7d 5b 20 44 44 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 43 68 61 6e 67 65 20 64 61 74 61 20 62 79 74 65 73 7e                 .byte "[HHHH]{:DD}[ DD]{Return} - Change data bytes~"
>f39c  5b 48 48 48 48 5d 7b 47 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 45 78 65 63 75 74 65 20 61 20 70 72 6f 67 72 61 6d 20 28 75 73 65 20 52 54 53 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20 6d 6f 6e 69 74 6f 72 29 7e                 .byte "[HHHH]{G}{Return} - Execute a program (use RTS to return to monitor)~"
>f3e1  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 49 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 6d 6f 76 65 20 72 61 6e 67 65 20 61 74 20 32 6e 64 20 48 48 48 48 20 64 6f 77 6e 20 74 6f 20 31 73 74 20 74 6f 20 33 72 64 20 48 48 48 48 7e                 .byte "{HHHH.HHHH>HHHH{I}{Return} - move range at 2nd HHHH down to 1st to 3rd HHHH~"
>f42d  5b 48 48 48 48 5d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4c 69 73 74 20 28 64 69 73 61 73 73 65 6d 62 6c 65 29 20 32 30 20 6c 69 6e 65 73 20 6f 66 20 70 72 6f 67 72 61 6d 7e                 .byte "[HHHH]{L}{Return} - List (disassemble) 20 lines of program~"
>f468  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 44 69 73 73 61 73 73 65 6d 62 6c 65 20 61 20 72 61 6e 67 65 7e                 .byte "[HHHH]{.HHHH}{L}{Return} - Dissassemble a range~"
>f498  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 4d 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4d 6f 76 65 20 72 61 6e 67 65 20 61 74 20 31 73 74 20 48 48 48 48 20 74 68 72 75 20 32 6e 64 20 74 6f 20 33 72 64 20 48 48 48 48 7e                 .byte "{HHHH.HHHH>HHHH{M}{Return} - Move range at 1st HHHH thru 2nd to 3rd HHHH~"
>f4e1  5b 48 48 48 48 5d 5b 20 48 48 48 48 5d 7b 51 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 54 65 78 74 20 64 75 6d 70 20 61 64 64 72 65 73 73 28 73 29 7e                 .byte "[HHHH][ HHHH]{Q}{Return} - Text dump address(s)~"
>f511  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 51 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 54 65 78 74 20 64 75 6d 70 20 72 61 6e 67 65 20 6f 66 20 61 64 64 72 65 73 73 65 73 20 28 31 36 20 70 65 72 20 6c 69 6e 65 29 7e                 .byte "[HHHH]{.HHHH}{Q}{Return} - Text dump range of addresses (16 per line)~"
>f557  7b 52 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 72 65 67 69 73 74 65 72 20 63 6f 6e 74 65 6e 74 73 20 66 72 6f 6d 20 6d 65 6d 6f 72 79 20 6c 6f 63 61 74 69 6f 6e 73 7e                 .byte "{R}{Return} - Print register contents from memory locations~"
>f593  7b 55 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 55 70 6c 6f 61 64 20 46 69 6c 65 20 28 58 6d 6f 64 65 6d 2f 43 52 43 20 6f 72 20 49 6e 74 65 6c 20 48 65 78 29 7e                 .byte "{U}{Return} - Upload File (Xmodem/CRC or Intel Hex)~"
>f5c7  7b 56 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4d 6f 6e 69 74 6f 72 20 56 65 72 73 69 6f 6e 7e                 .byte "{V}{Return} - Monitor Version~"
>f5e5  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 57 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 57 72 69 74 65 20 64 61 74 61 20 69 6e 20 52 41 4d 20 74 6f 20 45 45 50 52 4f 4d 7e                 .byte "{HHHH.HHHH>HHHH{W}{Return} - Write data in RAM to EEPROM~"
>f61e  7b 21 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 45 6e 74 65 72 20 41 73 73 65 6d 62 6c 65 72 7e                 .byte "{!}{Return} - Enter Assembler~"
>f63c  7b 40 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 43 6f 6c 64 2d 53 74 61 72 74 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 7e                 .byte "{@}{Return} - Cold-Start Enhanced Basic~"
>f664  7b 23 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 57 61 72 6d 5f 53 74 61 72 74 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 7e                 .byte "{#}{Return} - Warm_Start Enhanced Basic~"
>f68c  3c 24 3e 7b 52 65 74 75 72 6e 7d 20 2d 20 45 6e 74 65 72 20 43 42 4d 2d 44 4f 53 20 43 6f 6d 6d 61 6e 64 20 49 6e 74 65 72 70 72 65 74 65 72 7e  	       .byte "<$>{Return} - Enter CBM-DOS Command Interpreter~"
>f6bc  7b 3f 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 6d 65 6e 75 20 6f 66 20 63 6f 6d 6d 61 6e 64 73 7e 7e                 .byte "{?}{Return} - Print menu of commands~~"
>f6e2  00                                         .byte $00
>f6e3  7e 43 75 72 72 65 6e 74 20 63 6f 6d 6d 61 6e 64 73 20 61 72 65 20 3a 7e  AsmHelpTxt     .byte "~Current commands are :~"
>f6fb  53 79 6e 74 61 78 20 3d 20 7b 7d 20 72 65 71 75 69 72 65 64 2c 20 5b 5d 20 6f 70 74 69 6f 6e 61 6c 7e                 .byte "Syntax = {} required, [] optional~"
>f71d  48 48 48 48 3d 68 65 78 20 61 64 64 72 65 73 73 2c 20 4f 50 43 3d 4f 70 63 6f 64 65 2c 20 44 44 3d 68 65 78 20 64 61 74 61 2c 20 27 5f 27 3d 53 70 61 63 65 20 42 61 72 20 6f 72 20 54 61 62 7e                 .byte "HHHH=hex address, OPC=Opcode, DD=hex data, '_'=Space Bar or Tab~"
>f75d  27 24 27 20 53 79 6d 62 6f 6c 73 20 61 72 65 20 6f 70 74 69 6f 6e 61 6c 2c 20 61 6c 6c 20 76 61 6c 75 65 73 20 61 72 65 20 48 45 58 2e 7e                 .byte "'$' Symbols are optional, all values are HEX.~"
>f78b  41 6e 79 20 69 6e 70 75 74 20 61 66 74 65 72 20 61 20 27 73 65 6d 69 2d 63 6f 6c 6f 6e 27 20 69 73 20 69 67 6e 6f 72 65 64 2e 7e                 .byte "Any input after a 'semi-colon' is ignored.~"
>f7b6  7e                                         .byte "~"
>f7b7  7b 48 48 48 48 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 53 65 74 20 69 6e 70 75 74 20 61 64 64 72 65 73 73 7e                 .byte "{HHHH}{Return} - Set input address~"
>f7da  5b 48 48 48 48 5d 5b 5f 5d 7b 4f 50 43 7d 5b 5f 5d 5b 23 28 24 44 44 5f 48 48 48 48 2c 58 29 2c 59 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 41 73 73 65 6d 62 6c 65 20 6c 69 6e 65 7e                 .byte "[HHHH][_]{OPC}[_][#($DD_HHHH,X),Y]{Return} - Assemble line~"
>f815  5b 48 48 48 48 5d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4c 69 73 74 20 28 64 69 73 61 73 73 65 6d 62 6c 65 29 20 32 30 20 6c 69 6e 65 73 20 6f 66 20 70 72 6f 67 72 61 6d 7e                 .byte "[HHHH]{L}{Return} - List (disassemble) 20 lines of program~"
>f850  7b 52 65 74 75 72 6e 7d 20 2d 20 45 78 69 74 20 41 73 73 65 6d 62 6c 65 72 20 62 61 63 6b 20 74 6f 20 4d 6f 6e 69 74 6f 72 7e                 .byte "{Return} - Exit Assembler back to Monitor~"
>f87a  7b 3f 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 6d 65 6e 75 20 6f 66 20 63 6f 6d 6d 61 6e 64 73 7e 7e                 .byte "{?}{Return} - Print menu of commands~~"
>f8a0  00                                         .byte $00
>f8a1  36 35 43 30 32 20 4d 6f 6e 69 74 6f 72 20 76 35 2e 30 20 28 38 2d 31 39 2d 30 33 29 20 52 65 61 64 79  Porttxt        .byte "65C02 Monitor v5.0 (8-19-03) Ready"
>f8c3  0d 0a                                      .byte  $0d, $0a
>f8c5  4d 6f 64 75 6c 65 73 20 69 6e 73 74 61 6c 6c 65 64 3a 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 20 49 6e 74 65 72 70 72 65 74 65 72 20 28 63 29 20 4c 65 65 20 44 61 76 69 73 6f 6e                 .byte "Modules installed: Enhanced Basic Interpreter (c) Lee Davison"
>f902  0d 0a                                      .byte  $0d, $0a
>f904  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3a 20 43 6f 6d 6d 6f 64 6f 72 65 20 53 65 72 69 61 6c 20 49 45 43 20 42 49 4f 53 20 28 63 29 20 52 69 63 68 61 72 64 20 43 69 6e 69                 .byte "                 : Commodore Serial IEC BIOS (c) Richard Cini"
>f941  0d 0a                                      .byte  $0d, $0a
>f943  28 50 72 65 73 73 20 3f 20 66 6f 72 20 68 65 6c 70 29                 .byte "(Press ? for help)"
>f955  00                                         .byte $00
.fa00                              crclo

>fa00  00 21 42 63 84 a5 c6 e7 08 29 4a 6b 8c ad ce ef   .byte $00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
>fa10  31 10 73 52 b5 94 f7 d6 39 18 7b 5a bd 9c ff de   .byte $31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
>fa20  62 43 20 01 e6 c7 a4 85 6a 4b 28 09 ee cf ac 8d   .byte $62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
>fa30  53 72 11 30 d7 f6 95 b4 5b 7a 19 38 df fe 9d bc   .byte $53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
>fa40  c4 e5 86 a7 40 61 02 23 cc ed 8e af 48 69 0a 2b   .byte $C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
>fa50  f5 d4 b7 96 71 50 33 12 fd dc bf 9e 79 58 3b 1a   .byte $F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
>fa60  a6 87 e4 c5 22 03 60 41 ae 8f ec cd 2a 0b 68 49   .byte $A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
>fa70  97 b6 d5 f4 13 32 51 70 9f be dd fc 1b 3a 59 78   .byte $97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
>fa80  88 a9 ca eb 0c 2d 4e 6f 80 a1 c2 e3 04 25 46 67   .byte $88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
>fa90  b9 98 fb da 3d 1c 7f 5e b1 90 f3 d2 35 14 77 56   .byte $B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
>faa0  ea cb a8 89 6e 4f 2c 0d e2 c3 a0 81 66 47 24 05   .byte $EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
>fab0  db fa 99 b8 5f 7e 1d 3c d3 f2 91 b0 57 76 15 34   .byte $DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
>fac0  4c 6d 0e 2f c8 e9 8a ab 44 65 06 27 c0 e1 82 a3   .byte $4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
>fad0  7d 5c 3f 1e f9 d8 bb 9a 75 54 37 16 f1 d0 b3 92   .byte $7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
>fae0  2e 0f 6c 4d aa 8b e8 c9 26 07 64 45 a2 83 e0 c1   .byte $2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
>faf0  1f 3e 5d 7c 9b ba d9 f8 17 36 55 74 93 b2 d1 f0   .byte $1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0 
.fb00                              crchi
>fb00  00 10 20 30 40 50 60 70 81 91 a1 b1 c1 d1 e1 f1   .byte $00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
>fb10  12 02 32 22 52 42 72 62 93 83 b3 a3 d3 c3 f3 e3   .byte $12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
>fb20  24 34 04 14 64 74 44 54 a5 b5 85 95 e5 f5 c5 d5   .byte $24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
>fb30  36 26 16 06 76 66 56 46 b7 a7 97 87 f7 e7 d7 c7   .byte $36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
>fb40  48 58 68 78 08 18 28 38 c9 d9 e9 f9 89 99 a9 b9   .byte $48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
>fb50  5a 4a 7a 6a 1a 0a 3a 2a db cb fb eb 9b 8b bb ab   .byte $5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
>fb60  6c 7c 4c 5c 2c 3c 0c 1c ed fd cd dd ad bd 8d 9d   .byte $6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
>fb70  7e 6e 5e 4e 3e 2e 1e 0e ff ef df cf bf af 9f 8f   .byte $7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
>fb80  91 81 b1 a1 d1 c1 f1 e1 10 00 30 20 50 40 70 60   .byte $91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
>fb90  83 93 a3 b3 c3 d3 e3 f3 02 12 22 32 42 52 62 72   .byte $83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
>fba0  b5 a5 95 85 f5 e5 d5 c5 34 24 14 04 74 64 54 44   .byte $B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
>fbb0  a7 b7 87 97 e7 f7 c7 d7 26 36 06 16 66 76 46 56   .byte $A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
>fbc0  d9 c9 f9 e9 99 89 b9 a9 58 48 78 68 18 08 38 28   .byte $D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
>fbd0  cb db eb fb 8b 9b ab bb 4a 5a 6a 7a 0a 1a 2a 3a   .byte $CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
>fbe0  fd ed dd cd bd ad 9d 8d 7c 6c 5c 4c 3c 2c 1c 0c   .byte $FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
>fbf0  ef ff cf df af bf 8f 9f 6e 7e 4e 5e 2e 3e 0e 1e   .byte $EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E 

.fc00  20 fc fc   jsr $fcfc        XModem		jsr   	prtMsg		; send prompt and info
.fc03  a9 01      lda #$01         		lda   	#$01
.fc05  85 3c      sta $3c          		sta	blkno		; set block # to 1
.fc07  85 3f      sta $3f          		sta	bflag		; set flag to get address from block 1
.fc09  a9 43      lda #$43         StartCrc	lda	#"C"		; "C" start with CRC mode
.fc0b  20 0d e8   jsr $e80d        		jsr	output		; send it
.fc0e  a9 ff      lda #$ff         		lda	#$FF	
.fc10  85 3e      sta $3e          		sta	retry2		; set loop counter for ~3 sec delay
.fc12  a9 00      lda #$00         		lda   	#$00
.fc14  85 38      sta $38                          sta	crc
.fc16  85 39      sta $39          		sta	crch		; init CRC value	
.fc18  20 e9 fc   jsr $fce9        		jsr	GetByte		; wait for input
.fc1b  b0 11      bcs $fc2e                        bcs     GotByte         ; byte received, process it
.fc1d  90 ea      bcc $fc09        		bcc	StartCrc	; resend "C"
.fc1f  a9 ff      lda #$ff         StartBlk	lda	#$FF		; 
.fc21  85 3e      sta $3e          		sta	retry2		; set loop counter for ~3 sec delay
.fc23  a9 00      lda #$00         		lda   	#$00		;
.fc25  85 38      sta $38          		sta	crc		;
.fc27  85 39      sta $39          		sta	crch		; init CRC value	
.fc29  20 e9 fc   jsr $fce9        		jsr	GetByte		; get first byte of block
.fc2c  90 f1      bcc $fc1f        		bcc	StartBlk	; timed out, keep waiting...
.fc2e  c9 1b      cmp #$1b         GotByte         cmp     #ESC            ; quitting?
.fc30  d0 01      bne $fc33                        bne     GotByte3
.fc32  00         brk                              brk
.fc33  c9 01      cmp #$01         GotByte3        cmp     #SOH            ; start of block?
.fc35  f0 0e      beq $fc45        		beq	BegBlk		; yes
.fc37  c9 3a      cmp #$3a         		cmp	#":"		; Intel-Hex format - jump to its handler below
.fc39  d0 03      bne $fc3e        		bne	GotByte1	; 
.fc3b  4c 5a fd   jmp $fd5a        		jmp	HexUpLd		; 
.fc3e  c9 04      cmp #$04         GotByte1	cmp	#EOT		;
.fc40  d0 59      bne $fc9b        		bne	BadCrc		; Not SOH, ":", EOT, so flush buffer & send NAK	
.fc42  4c dc fc   jmp $fcdc        		jmp	Done		; EOT - all done!
.fc45  a2 00      ldx #$00         BegBlk		ldx	#$00
.fc47  a9 ff      lda #$ff         GetBlk		lda	#$ff		; 3 sec window to receive characters
.fc49  85 3e      sta $3e          		sta 	retry2		;
.fc4b  20 e9 fc   jsr $fce9        GetBlk1		jsr	GetByte		; get next character
.fc4e  90 4b      bcc $fc9b        		bcc	BadCrc		; chr rcv error, flush and send NAK
.fc50  9d 00 03   sta $0300,x      GetBlk2		sta	Rbuff,x		; good char, save it in the rcv buffer
.fc53  e8         inx              		inx			; inc buffer pointer	
.fc54  e0 84      cpx #$84         		cpx	#$84		; <01> <FE> <128 bytes> <CRCH> <CRCL>
.fc56  d0 ef      bne $fc47        		bne	GetBlk		; get 132 characters
.fc58  a2 00      ldx #$00         		ldx	#$00		;
.fc5a  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get block # from buffer
.fc5d  c5 3c      cmp $3c          		cmp	blkno		; compare to expected block #	
.fc5f  f0 0b      beq $fc6c        		beq	GoodBlk1	; matched!
.fc61  a9 fe      lda #$fe         		lda	#>MsgCrcBadBlkno
.fc63  a2 45      ldx #$45         		ldx	#<MsgCrcBadBlkno
.fc65  20 30 fe   jsr $fe30        		jsr	PrintStrAX	; Unexpected block number - abort	
.fc68  20 40 fd   jsr $fd40        		jsr	Flush		; mismatched - flush buffer and then do BRK
.fc6b  00         brk              		brk			; unexpected block # - fatal error
.fc6c  49 ff      eor #$ff         GoodBlk1	eor	#$ff		; 1's comp of block #
.fc6e  e8         inx              		inx			;
.fc6f  dd 00 03   cmp $0300,x      		cmp	Rbuff,x		; compare with expected 1's comp of block #
.fc72  f0 0b      beq $fc7f        		beq	GoodBlk2 	; matched!
.fc74  a9 fe      lda #$fe         		lda	#>MsgCrcBadBlkno
.fc76  a2 45      ldx #$45         		ldx	#<MsgCrcBadBlkno
.fc78  20 30 fe   jsr $fe30        		jsr	PrintStrAX	; Unexpected block number - abort	
.fc7b  20 40 fd   jsr $fd40        		jsr 	Flush		; mismatched - flush buffer and then do BRK
.fc7e  00         brk              		brk			; bad 1's comp of block#	
.fc7f  a0 02      ldy #$02         GoodBlk2	ldy	#$02		; 
.fc81  b9 00 03   lda $0300,y      CalcCrc		lda	Rbuff,y		; calculate the CRC for the 128 bytes of data	
.fc84  20 4a fd   jsr $fd4a        		jsr	UpdCrc		; could inline sub here for speed
.fc87  c8         iny              		iny			;
.fc88  c0 82      cpy #$82         		cpy	#$82		; 128 bytes
.fc8a  d0 f5      bne $fc81        		bne	CalcCrc		;
.fc8c  b9 00 03   lda $0300,y      		lda	Rbuff,y		; get hi CRC from buffer
.fc8f  c5 39      cmp $39          		cmp	crch		; compare to calculated hi CRC
.fc91  d0 08      bne $fc9b        		bne	BadCrc		; bad crc, send NAK
.fc93  c8         iny              		iny			;
.fc94  b9 00 03   lda $0300,y      		lda	Rbuff,y		; get lo CRC from buffer
.fc97  c5 38      cmp $38          		cmp	crc		; compare to calculated lo CRC
.fc99  f0 0b      beq $fca6        		beq	GoodCrc		; good CRC
.fc9b  20 40 fd   jsr $fd40        BadCrc		jsr	Flush		; flush the input port
.fc9e  a9 15      lda #$15         		lda	#NAK		;
.fca0  20 0d e8   jsr $e80d        		jsr	output		; send NAK to resend block
.fca3  4c 1f fc   jmp $fc1f        		jmp	StartBlk	; start over, get the block again			
.fca6  a2 02      ldx #$02         GoodCrc		ldx	#$02		;
.fca8  a5 3c      lda $3c          		lda	blkno		; get the block number
.fcaa  c9 01      cmp #$01         		cmp	#$01		; 1st block?
.fcac  d0 12      bne $fcc0        		bne	CopyBlk		; no, copy all 128 bytes
.fcae  a5 3f      lda $3f          		lda	bflag		; is it really block 1, not block 257, 513 etc.
.fcb0  f0 0e      beq $fcc0        		beq	CopyBlk		; no, copy all 128 bytes
.fcb2  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get target address from 1st 2 bytes of blk 1
.fcb5  85 3a      sta $3a          		sta	ptr		; save lo address
.fcb7  e8         inx              		inx			;
.fcb8  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get hi address
.fcbb  85 3b      sta $3b          		sta	ptr+1		; save it
.fcbd  e8         inx              		inx			; point to first byte of data
.fcbe  c6 3f      dec $3f          		dec	bflag		; set the flag so we won't get another address		
.fcc0  a0 00      ldy #$00         CopyBlk		ldy	#$00		; set offset to zero
.fcc2  bd 00 03   lda $0300,x      CopyBlk3	lda	Rbuff,x		; get data byte from buffer
.fcc5  91 3a      sta ($3a),y      		sta	(ptr),y		; save to target
.fcc7  e6 3a      inc $3a          		inc	ptr		; point to next address
.fcc9  d0 02      bne $fccd        		bne	CopyBlk4	; did it step over page boundry?
.fccb  e6 3b      inc $3b          		inc	ptr+1		; adjust high address for page crossing
.fccd  e8         inx              CopyBlk4	inx			; point to next data byte
.fcce  e0 82      cpx #$82         		cpx	#$82		; is it the last byte
.fcd0  d0 f0      bne $fcc2        		bne	CopyBlk3	; no, get the next one
.fcd2  e6 3c      inc $3c          IncBlk		inc	blkno		; done.  Inc the block #
.fcd4  a9 06      lda #$06         		lda	#ACK		; send ACK
.fcd6  20 0d e8   jsr $e80d        		jsr	output
.fcd9  4c 1f fc   jmp $fc1f        		jmp	StartBlk	; get next block
.fcdc  a9 06      lda #$06         Done		lda	#ACK		; last block, send ACK and exit.
.fcde  20 0d e8   jsr $e80d        		jsr	output
.fce1  a9 fe      lda #$fe         		lda	#>MsgCrcDone
.fce3  a2 75      ldx #$75         		ldx	#<MsgCrcDone
.fce5  20 30 fe   jsr $fe30        		jsr	PrintStrAX	;
.fce8  60         rts              		rts			;
.fce9  a9 00      lda #$00         GetByte		lda	#$00		; wait for chr input and cycle timing loop
.fceb  85 3d      sta $3d          		sta	retry		; set low value of timing loop
.fced  20 0a e8   jsr $e80a        StartCrcLp	jsr	Scan_Input	; get chr from serial port, don't wait 
.fcf0  b0 09      bcs $fcfb        		bcs	GetByte1	; got one, so exit
.fcf2  c6 3d      dec $3d          		dec   	retry		; no character received, so dec counter
.fcf4  d0 f7      bne $fced        		bne	StartCrcLp	;
.fcf6  c6 3e      dec $3e          		dec	retry2		; dec hi byte of counter
.fcf8  d0 f3      bne $fced        		bne	StartCrcLp	; look for character again
.fcfa  18         clc              		clc			; if loop times out, CLC, else SEC and return
.fcfb  60         rts              GetByte1	rts			; with character in "A"
.fcfc  a2 00      ldx #$00         PrtMsg		ldx	#$00		; PRINT starting message
.fcfe  bd 0b fd   lda $fd0b,x      PrtMsg1		lda   	Msg,x
.fd01  f0 07      beq $fd0a        		beq	PrtMsg2
.fd03  20 0d e8   jsr $e80d        		jsr   	output
.fd06  e8         inx              		inx
.fd07  4c fe fc   jmp $fcfe                        jmp     PrtMsg1
.fd0a  60         rts              PrtMsg2		rts

>fd0b  42 65 67 69 6e 20 58 4d 4f 44 45 4d 2f 43 52 43 20 74 72 61 6e 73 66 65 72 2e  Msg             .byte   "Begin XMODEM/CRC transfer."
>fd25  0d 0a                                       .byte   CR,LF
>fd27  50 72 65 73 73 20 3c 45 73 63 3e 20 74 6f 20 61 62 6f 72 74 2e 2e 2e 20                  .byte   "Press <Esc> to abort... "
>fd3f  00                                          .byte   0

.fd40  a9 70      lda #$70         Flush		lda	#$70		; flush receive buffer
.fd42  85 3e      sta $3e          		sta	retry2		; flush until empty for ~1 sec.
.fd44  20 e9 fc   jsr $fce9        Flush1		jsr	GetByte		; read the port
.fd47  b0 f7      bcs $fd40        		bcs	Flush
.fd49  60         rts              		rts	
.fd4a  45 39      eor $39          UpdCrc		eor 	crc+1 		; Quick CRC computation with lookup tables
.fd4c  aa         tax                       	tax		 
.fd4d  a5 38      lda $38                   	lda 	crc
.fd4f  5d 00 fb   eor $fb00,x               	eor 	CRCHI,X
.fd52  85 39      sta $39                   	sta 	crc+1
.fd54  bd 00 fa   lda $fa00,x               	lda 	CRCLO,X
.fd57  85 38      sta $38                   	sta 	crc
.fd59  60         rts                       	rts
.fd5a  a9 0d      lda #$0d         HexUpLd 	lda     #CR
.fd5c  20 0d e8   jsr $e80d        		jsr	output
.fd5f  a9 0a      lda #$0a         		lda	#LF
.fd61  20 0d e8   jsr $e80d        		jsr	output
.fd64  a9 00      lda #$00         		lda    	#0
.fd66  85 3e      sta $3e                  	sta	dlfail          ;Start by assuming no D/L failure
.fd68  f0 07      beq $fd71        	  	beq	IHex		
.fd6a  20 0a fe   jsr $fe0a        HdwRecs 	jsr     GetSer          ; Wait for start of record mark ':'
.fd6d  c9 3a      cmp #$3a                 	cmp     #":"
.fd6f  d0 f9      bne $fd6a                	bne     HdwRecs         ; not found yet
.fd71  20 13 fe   jsr $fe13        IHex    	jsr     GetHex          ; Get the record length
.fd74  85 39      sta $39                  	sta     reclen          ; save it
.fd76  85 38      sta $38                 	 	sta     chksum          ; and save first byte of checksum
.fd78  20 13 fe   jsr $fe13                	jsr     GetHex          ; Get the high part of start address
.fd7b  85 3c      sta $3c                  	sta     start_hi
.fd7d  18         clc                      	clc
.fd7e  65 38      adc $38                  	adc     chksum          ; Add in the checksum       
.fd80  85 38      sta $38                  	sta     chksum          ; 
.fd82  20 13 fe   jsr $fe13                	jsr     GetHex          ; Get the low part of the start address
.fd85  85 3b      sta $3b                  	sta     start_lo
.fd87  18         clc                      	clc
.fd88  65 38      adc $38                  	adc     chksum
.fd8a  85 38      sta $38                  	sta     chksum  
.fd8c  20 13 fe   jsr $fe13                	jsr     GetHex          ; Get the record type
.fd8f  85 3d      sta $3d                  	sta     rectype         ; & save it
.fd91  18         clc                      	clc
.fd92  65 38      adc $38                  	adc     chksum
.fd94  85 38      sta $38                  	sta     chksum   
.fd96  a5 3d      lda $3d                  	lda     rectype
.fd98  d0 2c      bne $fdc6                	bne     HdEr1           ; end-of-record
.fd9a  a6 39      ldx $39                  	ldx     reclen          ; number of data bytes to write to memory
.fd9c  a0 00      ldy #$00                 	ldy     #0              ; start offset at 0
.fd9e  20 13 fe   jsr $fe13        HdLp1   	jsr     GetHex          ; Get the first/next/last data byte
.fda1  91 3b      sta ($3b),y              	sta     (start_lo),y    ; Save it to RAM
.fda3  18         clc                      	clc
.fda4  65 38      adc $38                  	adc     chksum
.fda6  85 38      sta $38                  	sta     chksum          ; 
.fda8  c8         iny                      	iny                     ; update data pointer
.fda9  ca         dex                      	dex                     ; decrement count
.fdaa  d0 f2      bne $fd9e                	bne     HdLp1
.fdac  20 13 fe   jsr $fe13                	jsr     GetHex          ; get the checksum
.fdaf  18         clc                      	clc
.fdb0  65 38      adc $38                  	adc     chksum
.fdb2  d0 08      bne $fdbc                	bne     HdDlF1          ; If failed, report it
.fdb4  a9 23      lda #$23                 	lda     #"#"            ; Character indicating record OK = '#'
.fdb6  8d 70 7f   sta $7f70                	sta	ACIA1dat        ; write it out but don't wait for output 
.fdb9  4c 6a fd   jmp $fd6a                	jmp     HdwRecs         ; get next record     
.fdbc  a9 46      lda #$46         HdDlF1  	lda     #"F"            ; Character indicating record failure = 'F'
.fdbe  85 3e      sta $3e                  	sta     dlfail          ; upload failed if non-zero
.fdc0  8d 70 7f   sta $7f70                	sta	ACIA1dat        ; write it to transmit buffer register
.fdc3  4c 6a fd   jmp $fd6a                	jmp     HdwRecs         ; wait for next record start
.fdc6  c9 01      cmp #$01         HdEr1   	cmp     #1              ; Check for end-of-record type
.fdc8  f0 1b      beq $fde5                	beq     HdEr2
.fdca  a9 fe      lda #$fe         		lda	#>MsgUnknownRecType
.fdcc  a2 97      ldx #$97         		ldx	#<MsgUnknownRecType
.fdce  20 30 fe   jsr $fe30                        jsr     PrintStrAX      ; Warn user of unknown record type
.fdd1  a5 3d      lda $3d          		lda     rectype         ; Get it
.fdd3  85 3e      sta $3e                  	sta     dlfail          ; non-zero --> upload has failed
.fdd5  20 6f e7   jsr $e76f                	jsr     Print1Byte      ; print it
.fdd8  a9 0d      lda #$0d         		lda     #CR		; but we'll let it finish so as not to 
.fdda  20 0d e8   jsr $e80d                	jsr     output		; falsely start a new d/l from existing 
.fddd  a9 0a      lda #$0a                 	lda     #LF		; file that may still be coming in for 
.fddf  20 0d e8   jsr $e80d                	jsr     output          ; quite some time yet.
.fde2  4c 6a fd   jmp $fd6a        		jmp	HdwRecs
.fde5  20 13 fe   jsr $fe13        HdEr2   	jsr     GetHex          ; get the checksum 
.fde8  18         clc                      	clc
.fde9  65 38      adc $38                  	adc     chksum          ; Add previous checksum accumulator value
.fdeb  f0 07      beq $fdf4                	beq     HdEr3           ; checksum = 0 means we're OK!
.fded  a9 fe      lda #$fe         		lda	#>MsgBadRecChksum
.fdef  a2 b1      ldx #$b1         		ldx	#<MsgBadRecChksum
.fdf1  4c 30 fe   jmp $fe30                        jmp     PrintStrAX
.fdf4  a5 3e      lda $3e          HdEr3   	lda     dlfail
.fdf6  f0 07      beq $fdff                	beq     HdErOK
.fdf8  a9 fe      lda #$fe         		lda	#>MsgUploadFail
.fdfa  a2 ca      ldx #$ca         		ldx	#<MsgUploadFail
.fdfc  4c 30 fe   jmp $fe30                        jmp     PrintStrAX
.fdff  a9 fe      lda #$fe         HdErOK  	lda	#>MsgUploadOK
.fe01  a2 e7      ldx #$e7         		ldx	#<MsgUploadOK
.fe03  20 30 fe   jsr $fe30                        jsr     PrintStrAX
.fe06  20 40 fd   jsr $fd40        	  	jsr     Flush		; flush the input buffer
.fe09  60         rts              HdErNX  	rts
.fe0a  20 0a e8   jsr $e80a        GetSer  	jsr	scan_input	; get input from Serial Port	    
.fe0d  c9 1b      cmp #$1b                         cmp     #ESC            ; check for abort 
.fe0f  d0 01      bne $fe12                	bne     GSerXit         ; return character if not
.fe11  00         brk                              brk
.fe12  60         rts              GSerXit 	rts
.fe13  a9 00      lda #$00         GetHex  	lda     #$00
.fe15  85 3f      sta $3f          	  	sta     temp
.fe17  20 20 fe   jsr $fe20                	jsr     GetNibl
.fe1a  0a         asl                      	asl     a
.fe1b  0a         asl                      	asl     a
.fe1c  0a         asl                      	asl     a
.fe1d  0a         asl                     	 	asl     a       	; This is the upper nibble
.fe1e  85 3f      sta $3f                  	sta     temp
.fe20  20 0a fe   jsr $fe0a        GetNibl 	jsr     GetSer
.fe23  c9 3a      cmp #$3a         	        cmp     #"9"+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.fe25  90 02      bcc $fe29               	 	bcc     MkNnh   	; If we borrowed, we lost the carry so 0..9
.fe27  e9 08      sbc #$08                 	sbc     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.fe29  e9 2f      sbc #$2f         MkNnh   	sbc     #"0"-1  	; subtract off '0' (if carry clear coming in)
.fe2b  29 0f      and #$0f                 	and     #$0F    	; no upper nibble no matter what
.fe2d  05 3f      ora $3f                  	ora     temp
.fe2f  60         rts                      	rts             	; return with the nibble received
.fe30  85 41      sta $41          PrintStrAX      sta     strptr+1
.fe32  86 40      stx $40          		stx	strptr
.fe34  98         tya              		tya
.fe35  48         pha              		pha
.fe36  a0 00      ldy #$00         		ldy	#0
.fe38  b1 40      lda ($40),y      PrintStrAXL1    lda     (strptr),y
.fe3a  f0 06      beq $fe42                        beq     PrintStrAXX1      ; quit if NULL
.fe3c  20 0d e8   jsr $e80d            		jsr	output
.fe3f  c8         iny              		iny
.fe40  d0 f6      bne $fe38                        bne     PrintStrAXL1      ; quit if > 255
.fe42  68         pla              PrintStrAXX1    pla
.fe43  a8         tay              		tay
.fe44  60         rts              		rts   

>fe45  0d 0a 0d 0a                 MsgCrcBadBlkno  .byte	CR,LF,CR,LF
>fe49  55 6e 65 78 70 65 63 74 65 64 20 62 6c 6f 63 6b 20 6e 75 6d 62 65 72 20 72 65 63 65 69 76 65 64  		.byte  	"Unexpected block number received"
>fe69  20 41 62 6f 72 74 69 6e 67   		.byte	" Aborting"
>fe72  0d 0a                       		.byte 	CR,LF
>fe74  00                          		.byte 	0
>fe75  0d 0a                       MsgCrcDone	.byte 	CR,LF
>fe77  58 4d 4f 44 45 4d 2d 43 52 43 20 64 6f 77 6e 6c 6f 61 64 20 69 73 20 63 6f 6d 70 6c 65 74 65                  .byte   "XMODEM-CRC download is complete"
>fe96  00                          		.byte 	0
.fe97                              msgunknownrectype
>fe97  0d 0a 0d 0a                 		.byte   CR,LF,CR,LF
>fe9b  55 6e 6b 6e 6f 77 6e 20 72 65 63 6f 72 64 20 74 79 70 65 20 24        		.byte   "Unknown record type $"
>feb0  00                          		.byte	0		; null-terminate every string
>feb1  0d 0a 0d 0a                 MsgBadRecChksum .byte   CR,LF,CR,LF
>feb5  42 61 64 20 72 65 63 6f 72 64 20 63 68 65 63 6b 73 75 6d 21                  .byte   "Bad record checksum!"
>fec9  00                                  	.byte   0		; Null-terminate  
>feca  0d 0a 0d 0a                 MsgUploadFail   .byte   CR,LF,CR,LF
>fece  55 70 6c 6f 61 64 20 46 61 69 6c 65 64 0d 0a                  .byte   "Upload Failed",CR,LF
>fedd  41 62 6f 72 74 69 6e 67 21                  .byte   "Aborting!"
>fee6  00                                          .byte   0               ; null-terminate every string or crash'n'burn
>fee7  0d 0a 0d 0a                 MsgUploadOK	.byte   CR,LF,CR,LF
>feeb  55 70 6c 6f 61 64 20 53 75 63 63 65 73 73 66 75 6c 21                  .byte   "Upload Successful!"
>fefd  00                                  	.byte   0         	

.ff00  78         sei              Reset          SEI                     ; diable interupts
.ff01  d8         cld                             CLD                     ; clear decimal mode                      
.ff02  a2 ff      ldx #$ff                        LDX   #$FF              ;
.ff04  9a         txs                             TXS                     ; init stack pointer
.ff05  a9 7f      lda #$7f         Zeromem        lda   #$7F              ; top page of RAM
.ff07  85 01      sta $01                         sta   $01               ; 
.ff09  a9 00      lda #$00                        lda   #$00              ; top of page & fill chr
.ff0b  85 00      sta $00                         sta   $00               ;
.ff0d  92 00      sta ($00)        Zeromem1       sta   ($00)             ; loop will fill loc 0 of each page then 
.ff0f  c6 00      dec $00                         dec   $00               ; fill from ff->01 of that page
.ff11  d0 fa      bne $ff0d                       bne   zeromem1          ; then will drop one page and fill loc 0
.ff13  c6 01      dec $01                         dec   $01               ; doing that until page is back to FF
.ff15  10 f6      bpl $ff0d                       bpl   Zeromem1          ;
.ff17  85 01      sta $01                         sta   $01               ; fix last byte from ff to 00
.ff19  ad f8 03   lda $03f8        Set_Vectors    lda   RESvector+1       ; reset vector 
.ff1c  49 a5      eor #$a5                        EOR   #$A5              ; on reset, perform code @ label reset
.ff1e  cd f9 03   cmp $03f9                       CMP   RESvector+2       ; if checksm ok, then jmp ind to address
.ff21  f0 10      beq $ff33                       beq   nextvec1          ; else set up to jmp to monitor
.ff23  a2 00      ldx #$00                        LDX   #<Start_OS        ; *** only outside reference in reset routine
.ff25  a9 e7      lda #$e7                        LDA   #>Start_OS        ; *** points to Monitor Boot routine
.ff27  a8         tay                             TAY                     ;
.ff28  49 a5      eor #$a5                        EOR   #$A5              ;
.ff2a  8d f9 03   sta $03f9                       sta   RESvector+2       ;
.ff2d  8c f8 03   sty $03f8                       sty   RESvector+1       ;
.ff30  8e f7 03   stx $03f7                       stx   RESvector         ;
.ff33  ad fe 03   lda $03fe        Nextvec1       lda   NMIvector+1       ; set up NMI vectors if checksum invalid
.ff36  49 a5      eor #$a5                        EOR   #$A5              ;  
.ff38  cd ff 03   cmp $03ff                       CMP   NMIvector+2       ;
.ff3b  f0 10      beq $ff4d                       beq   nextvec2          ;
.ff3d  a2 bf      ldx #$bf                        LDX   #<INTret          ; set up to point to RTI command 
.ff3f  a9 ff      lda #$ff                        LDA   #>INTret          ; (no system NMI applications)
.ff41  a8         tay                             TAY                     ;
.ff42  49 a5      eor #$a5                        EOR   #$A5              ;
.ff44  8d ff 03   sta $03ff                       sta   NMIvector+2       ;
.ff47  8c fe 03   sty $03fe                       sty   NMIvector+1       ;
.ff4a  8e fd 03   stx $03fd                       stx   NMIvector         ;
.ff4d  ad fb 03   lda $03fb        Nextvec2       lda   INTvector+1       ;
.ff50  49 a5      eor #$a5                        EOR   #$A5              ;
.ff52  cd fc 03   cmp $03fc                       CMP   INTvector+2       ;
.ff55  f0 10      beq $ff67                       beq   Nextvec3          ;
.ff57  a2 bf      ldx #$bf                        LDX   #<INTret          ; set up to point to RTI command 
.ff59  a9 ff      lda #$ff                        LDA   #>INTret          ; (no system INT applications)
.ff5b  a8         tay                             TAY                     ;
.ff5c  49 a5      eor #$a5                        EOR   #$A5              ;
.ff5e  8d fc 03   sta $03fc                       sta   INTvector+2       ;
.ff61  8c fb 03   sty $03fb                       sty   INTvector+1       ;
.ff64  8e fa 03   stx $03fa                       stx   INTvector         ;
.ff67  ad f5 03   lda $03f5        Nextvec3       lda   BRKvector+1       ;
.ff6a  49 a5      eor #$a5                        EOR   #$A5              ;
.ff6c  cd f6 03   cmp $03f6                       CMP   BRKvector+2       ;
.ff6f  f0 10      beq $ff81                       beq   Nextvec4          ;
.ff71  a2 1e      ldx #$1e                        LDX   #<BRKroutine      ; set up to point to my BRK routine
.ff73  a9 e8      lda #$e8                        LDA   #>BRKroutine      ; 
.ff75  a8         tay                             TAY                     ;
.ff76  49 a5      eor #$a5                        EOR   #$A5              ;
.ff78  8d f6 03   sta $03f6                       sta   BRKvector+2       ;
.ff7b  8c f5 03   sty $03f5                       sty   BRKvector+1       ;
.ff7e  8e f4 03   stx $03f4                       stx   BRKvector         ;
.ff81  a9 b8      lda #$b8         Nextvec4       lda   #<ACIA1_Scan
.ff83  8d 05 02   sta $0205                       sta   VEC_IN
.ff86  a9 e6      lda #$e6         		   lda   #>ACIA1_Scan
.ff88  8d 06 02   sta $0206                       sta   VEC_IN+1
.ff8b  a9 c5      lda #$c5         	         lda   #<ACIA1_Output
.ff8d  8d 07 02   sta $0207                       sta   VEC_OUT
.ff90  a9 e6      lda #$e6         		   lda   #>ACIA1_OUTPUT
.ff92  8d 08 02   sta $0208                       sta   VEC_OUT+1
.ff95  a9 7e      lda #$7e         	         lda   #<Psave
.ff97  8d 0b 02   sta $020b                       sta   VEC_SV
.ff9a  a9 ca      lda #$ca         	         lda   #>Psave
.ff9c  8d 0c 02   sta $020c                       sta   VEC_SV+1
.ff9f  a9 a7      lda #$a7         		   lda   #<pload
.ffa1  8d 09 02   sta $0209                       sta   VEC_LD
.ffa4  a9 ca      lda #$ca         		   lda   #>pload
.ffa6  8d 0a 02   sta $020a                       sta   VEC_LD+1
.ffa9  20 00 e6   jsr $e600        		   jsr   VIA1_init	   ; init the I/O devices
.ffac  20 2d e6   jsr $e62d        		   jsr   VIA2_init	   ; init the I/O devices
.ffaf  20 4a e6   jsr $e64a        		   jsr   ACIA1_init	   ; init the I/O devices
.ffb2  a9 00      lda #$00         Clr_regs       lda   #$00              ; Clear registers
.ffb4  a8         tay                             TAY                     ;
.ffb5  aa         tax                             TAX                     ;
.ffb6  18         clc                             CLC                     ; clear flags
.ffb7  d8         cld                             CLD                     ; clear decimal mode
.ffb8  58         cli                             CLI                     ; Enable interrupt system
.ffb9  6c f7 03   jmp ($03f7)                     JMP  (RESvector)        ; Monitor for cold reset                       
.ffbc  6c fd 03   jmp ($03fd)      NMIjump        jmp  (NMIvector)        ;
.ffbf  40         rti              INTret         RTI                     ; Null Interrupt return
.ffc0  da         phx              Interrupt      PHX                     ;
.ffc1  48         pha                             PHA                     ;
.ffc2  ba         tsx                             TSX                     ; get stack pointer
.ffc3  bd 03 01   lda $0103,x                     LDA   $0103,X           ; load INT-P Reg off stack
.ffc6  29 10      and #$10                        AND   #$10              ; mask BRK
.ffc8  d0 05      bne $ffcf                       BNE   BrkCmd            ; BRK CMD
.ffca  68         pla                             PLA                     ;
.ffcb  fa         plx                             PLX                     ;
.ffcc  6c fa 03   jmp ($03fa)                     jmp   (INTvector)       ; let user routine have it 
.ffcf  68         pla              BrkCmd         pla                     ;
.ffd0  fa         plx                             plx                     ;
.ffd1  6c f4 03   jmp ($03f4)                     jmp   (BRKvector)       ; patch in user BRK routine
.ffd4  60         rts              RRTS           rts                     ; documented RTS instruction

>fffa  bc ff                                      .word  NMIjump
>fffc  00 ff                                      .word  Reset 
>fffe  c0 ff                                      .word  Interrupt

--- end of code ---
